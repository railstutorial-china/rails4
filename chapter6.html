<!doctype html>
<html lang="zh_CN">
<head>
	<meta charset="utf-8" />
	<title>第 6 章 用户模型</title>
    <meta name="author" content="Andor Chen" />
    <link rel="stylesheet" href="/assets/styles/style.css" />
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/global.js"></script>
</head>

<body>
	<div class="wrapper">
		<div class="header">
            <h1 class="logo"><a class="ir" href="http://railstutorial-china.org">Ruby on Rails 教程</a></h1>
            <p class="subtitle">Ruby on Rails Tutorial 原书第 2 版（涵盖 Rails 4）</p>
        </div>
        <div class="content">
			
<div class="item chapter">
	<h1 id="chapter-6"><span>第 6 章</span> 用户模型</h1>
	<ol class="toc">          <li class="level-2">
            <a href="#section-6-1">6.1 User 模型</a>
          </li>
          <li class="level-3">
            <a href="#section-6-1-1">6.1.1 数据库迁移</a>
          </li>
          <li class="level-3">
            <a href="#section-6-1-2">6.1.2 模型文件</a>
          </li>
          <li class="level-3">
            <a href="#section-6-1-3">6.1.3 创建用户对象</a>
          </li>
          <li class="level-3">
            <a href="#section-6-1-4">6.1.4 查找用户对象</a>
          </li>
          <li class="level-3">
            <a href="#section-6-1-5">6.1.5 更新用户对象</a>
          </li>
          <li class="level-2">
            <a href="#section-6-2">6.2 用户数据验证</a>
          </li>
          <li class="level-3">
            <a href="#section-6-2-1">6.2.1 用户模型测试</a>
          </li>
          <li class="level-3">
            <a href="#section-6-2-2">6.2.2 验证存在性</a>
          </li>
          <li class="level-3">
            <a href="#section-6-2-3">6.2.3 长度验证</a>
          </li>
          <li class="level-3">
            <a href="#section-6-2-4">6.2.4 格式验证</a>
          </li>
          <li class="level-3">
            <a href="#section-6-2-5">6.2.5 唯一性验证</a>
          </li>
          <li class="level-2">
            <a href="#section-6-3">6.3 加上安全密码</a>
          </li>
          <li class="level-3">
            <a href="#section-6-3-1">6.3.1 加密密码</a>
          </li>
          <li class="level-3">
            <a href="#section-6-3-2">6.3.2 密码和密码确认</a>
          </li>
          <li class="level-3">
            <a href="#section-6-3-3">6.3.3 用户身份验证</a>
          </li>
          <li class="level-3">
            <a href="#section-6-3-4">6.3.4 用户的安全密码</a>
          </li>
          <li class="level-3">
            <a href="#section-6-3-5">6.3.5 创建用户</a>
          </li>
          <li class="level-2">
            <a href="#section-6-4">6.4 小结</a>
          </li>
          <li class="level-2">
            <a href="#section-6-5">6.5 练习</a>
          </li>
</ol>
  	<div class="main">
  		<p><a href="chapter5.html">第 5 章</a>的末尾我们创建了一个临时的用户注册页面（<a href="chapter5.html#section-5-4">5.4 节</a>），本教程接下来的四章会逐步丰富这个页面的功能。第一个关键的步骤是为网站的用户创建一个数据模型，以及存储数据的方式。<a href="chapter7.html">第 7 章</a>会实现用户注册功能，并创建用户资料页面。用户能注册后，我们就要实现登录和退出功能（<a href="chapter8.html">第 8 章</a>）。<a href="chapter9.html">第 9 章</a>（<a href="chapter9.html#section-9-2-1">9.2.1 节</a>）会介绍如何保护页面避免被无权限的人员访问。第 6 章到第 9 章的内容结合在一起，我们就开发出了一个功能完整的 Rails 登录和用户验证系统。或许你知道已经有很多开发好了的 Rails 用户验证方案，<a href="chapter6.html#aside-6-1">旁注 6.1</a>解释了为什么，至少在初学阶段，自己开发一个用户验证系统或许是更好的方法。</p>

<p>这一章很长，内容很多，你也许会觉得有些挑战性，特别是对数据模型新手来说。不过学完本章后，我们会开发出一个可在实际应用程序中使用的系统，包括数据验证、存储和用户信息获取等功能。</p>

          <div class="aside box" id="aside-6-1">
  <h4><span>旁注 6.1：</span>为什么要自己开发用户验证系统</h4>

  <p>基本上所有的 Web 应用程序都会需要某种登录和用户验证系统。所以 Web 框架大都有很多验证系统的实现方案，Rails 当然也不例外。用户验证及授权系统有很多，包括 Clearance、Authlogic、Devise 和 CanCan（还有一些不是专门针对 Rails 的基于 OpenID 和 OAuth 开发的系统）。所以你肯定就会问，为什么还要重复制造轮子，为什么不直接用现有的解决方案，而要自己开发呢？</p>

  <p>首先，实践已经证明，大多数网站的用户验证系统都要对第三方代码库做一些定制和修改，这往往比重新开发一个验证系统的工作量还大。再者，现有的方案就像一个“黑盒”，你无法了解其中到底有些什么功能，而自己开发的话就能更好的理解实现的过程。而且，Rails 最近的更新（参见<a href="chapter6.html#section-6-3">6.3 节</a>），使开发验证系统变得很简单。最后，如果后续开发要用第三方代码库的话，因为自己开发过，所以你可以更好的理解其实现过程，便于定制功能。</p>
</div>


<p>和之前一样，如果你一直使用 Git 做版本控制，现在最好为本章创建一个从分支：</p>

<div class="codeblock"><div class="highlight type-sh"><pre><span class="nv">$ </span>git checkout master
<span class="nv">$ </span>git checkout -b modeling-users
</pre></div>
</div>
<p>（第一个命令是要确保处在主分支，这样创建的 <code>modeling-users</code> 从分支才会基于 <code>master</code> 分支的当前状态。如果你已经处在主分支的话，可以跳过第一个命令。）</p>

<h2 id='section-6-1'><span>6.1</span> User 模型</h2>


<p>接下来的三章最终是要实现网站的“注册”页面（构思图如图 6.1 所示），在此之前我们要解决用户的存储问题，因为现在还没有地方存储用户信息。所以，实现用户注册功能的第一步是，创建一个数据结构，获取并存储用户的信息。</p>

<div class="figure" id="figure-6-1">
  <img src="figures/signup_mockup_bootstrap.png" alt="signup mockup bootstrap" /><p class="caption"><span>图 6.1：</span>用户注册页面的构思图</p>
</div>
<p>在 Rails 中，数据模型的默认数据结构叫做模型（model，MVC 中的 M，参见<a href="chapter1.html#section-1-2-6">1.2.6 节</a>）。Rails 为解决数据持久化提供的默认解决方案是，使用数据库存储需要长期使用的数据。和数据库交互默认的代码库是 Active Record<sup class="footnote" id="fnref-6-1"><a href="#fn-6-1" rel="footnote">1</a></sup>。Active Record 提供了一系列的方法，可直接用于创建、保存、查询数据对象，而无需使用关系数据库所用的结构化查询语言（structured query language， SQL）<sup class="footnote" id="fnref-6-2"><a href="#fn-6-2" rel="footnote">2</a></sup>。Rails 还支持数据库迁移（migration）功能，允许我们使用纯 Ruby 代码定义数据结构，而不用学习数据定义语言（data definition language, DDL）。Active Record 把你和数据库层完全隔开了。本教程开发的应用程序在本地使用的是 SQLite 数据库，部署后使用 PostgreSQL 数据库（由 Heroku 提供，参见 <a href="chapter1.html#section-1-4">1.4 节</a>）。这就引入了一个更深层次的话题，那就是在不同的环境中，即便使用的是不同类型的数据库，我们也无需关心 Rails 是如何存储数据的。</p>

<h3 id='section-6-1-1'><span>6.1.1</span> 数据库迁移</h3>


<p>回顾一下 <a href="chapter4.html#section-4-4-5">4.4.5 节</a>的内容，在我们自己创建的 <code>User</code> 类中已经使用了用户对象，有 <code>name</code> 和 <code>email</code> 两个属性。那是个很有用的例子，但没有实现持久性最关键的要求：在 Rails 控制台中创建的用户对象，退出控制台后就会消失。本节的目的就是创建一个用户模型，持久化存储数据。</p>

<p>和 <a href="chapter4.html#section-4-4-5">4.4.5 节</a>中的 <code>User</code> 类一样，我们先把用户模型设计为只有两个属性，分别是 <code>name</code> 和 <code>email</code>。Email 地址稍后会作为用户登录的用户名。<sup class="footnote" id="fnref-6-3"><a href="#fn-6-3" rel="footnote">3</a></sup>（<a href="chapter6.html#section-6-3">6.3 节</a>会添加用户密码相关的属性）代码 4.9 使用 Ruby 的 <code>attr_accessor</code> 方法创建了这两个属性：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">User</span>
  <span class="kp">attr_accessor</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div>
<p>在 Rails 中不用这样定义属性。如前面提到的，Rails 默认使用关系型数据库存储数据，数据库中的表（table）是由记录行（row）组成的，每行中都有相应的数据属性列（column）。例如，要存储用户的名字和 Email 地址，我们要创建 <code>users</code> 表，表中包含 <code>name</code> 列和 <code>email</code> 列（每一行代表一个用户）。这样命名列，Active Record 就能找到用户对象的属性了。</p>

<p>让我们看一下 Active Record 是怎么找到的。（如果下面这些讨论对你来说太抽象了，请耐心的看下去。<a href="chapter6.html#section-6-1-3">6.1.3 节</a>在控制台中的操作示例，以及图 6.3 和图 6.6 中的数据库浏览器截图应该会让你更清楚的理解这些内容。）代码 5.29 使用下面的命令生成了 Users 控制器和 <code>new</code> 动作：</p>

<div class="codeblock"><div class="highlight type-sh"><pre><span class="nv">$ </span>rails generate controller Users new --no-test-framework
</pre></div>
</div>
<p>创建模型可以使用类似的命令：<code>generate model</code>。代码 6.1 所示为生成 <code>User</code> 模型，以及 <code>name</code> 和 <code>email</code> 属性所用的命令。</p>

<div class="codeblock has-caption" id="codeblock-6-1"><p class="caption"><span>代码 6.1：</span>生成用户模型</p><div class="highlight type-sh"><pre><span class="nv">$ </span>rails generate model User name:string email:string
      invoke active record
      create db/migrate/<span class="o">[</span>timestamp<span class="o">]</span>_create_users.rb
      create app/models/user.rb
      invoke rspec
      create   spec/models/user_spec.rb
</pre></div>
</div>
<p>（注意，和生成控制器的命令习惯不同，模型的名字是单数：控制器是 Users，而模型是 User。）我们提供了可选的参数 <code>name:string</code> 和 <code>email:string</code>，告诉 Rails 我们需要的两个属性是什么，以及各自的类型（两个都是字符串）。你可以把这两个参数与代码 3.4 和代码 5.29 中的动作名称对比一下，看看有什么不同。</p>

<p>代码 6.1 中的 <code>generate</code> 命令带来的结果之一是创建了一个数据库迁移文件。迁移是一种精确修改数据库结构的方式，可以根据需求修改数据模型。本例中 User 模型的迁移文件是直接通过 <code>generate model</code> 命令生成的。迁移文件会创建 <code>users</code> 表，包含两个列，即 <code>name</code> 和 <code>email</code>，如代码 6.2 所示。（我们会在 <a href="chapter6.html#section-6-2-5">6.2.5 节</a>以及 <a href="chapter6.html#section-6-3">6.3 节</a>介绍如何手动创建迁移文件。）</p>

<div class="codeblock has-caption" id="codeblock-6-2"><p class="caption"><span>代码 6.2：</span>User 模型的迁移文件（创建 <code>users</code> 表）</p><p class="file"><code>db/migrate/[timestamp]_create_users.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">CreateUsers</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:users</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="o">.</span><span class="n">string</span> <span class="ss">:name</span>
      <span class="n">t</span><span class="o">.</span><span class="n">string</span> <span class="ss">:email</span>
      <span class="n">t</span><span class="o">.</span><span class="n">timestamps</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>注意一下迁移文件名的前面有个时间戳（timestamp），这是该文件被创建时的时间。早期迁移文件名的前缀是个递增的数字，在协作团队中如果多个编程人员生成了相同序号的迁移文件就可能会发生冲突。除非两个迁移文件在同一秒钟生成这种小概率事件发生了，否则使用时间戳基本可以避免冲突的发生。迁移文件的代码中有一个名为 <code>change</code> 的方法，这个方法定义要对数据库做什么操作。代码 6.2 中，<code>change</code> 方法使用 Rails 提供的 <code>create_table</code> 方法在数据库中新建一个表，用来存储用户数据。<code>create_table</code> 后跟着一个块，指定了一个块参数 <code>t</code>（代表这个表对象）。在块中，<code>create_table</code> 方法通过 <code>t</code> 对象创建了 <code>name</code> 和 <code>email</code> 两个列，均为 <code>string</code> 类型。<sup class="footnote" id="fnref-6-4"><a href="#fn-6-4" rel="footnote">4</a></sup>这里使用的表名是复数形式（<code>users</code>），不过模型名是单数形式（User），这是 Rails 在用词上的一个约定，即模型表现的是单个用户的特性，而数据库表却存储了很多用户。块中最后一行 <code>t.timestamps</code> 是个特殊的方法，它会自动创建两个列，<code>created_at</code> 和 <code>updated_at</code>，这两个列分别记录创建用户的时间戳和更新用户数据的时间戳。（<a href="chapter6.html#section-6-1-3">6.1.3 节</a>会介绍使用这两个列的例子。）这个迁移文件表示的完整数据模型如图 6.2 所示。</p>

<div class="figure" id="figure-6-2">
  <img src="figures/user_model_initial.png" alt="user model initial" /><p class="caption"><span>图 6.2：</span>代码 6.2 生成的用户数据模型</p>
</div>
<p>我们可以使用如下的 <code>rake</code> 命令（参见<a href="chapter2.html#aside-2-1">旁注 2.1</a>）来执行这个迁移（也叫“向上迁移”）：</p>

<div class="codeblock"><div class="highlight type-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake db:migrate
</pre></div>
</div>
<p>（你可能还记得，我们在 <a href="chapter2.html#section-2-2">2.2 节</a>中使用过这个命令。）第一次运行 <code>db:migrate</code> 命令时会新建 <code>db/development.sqlite3</code>，这是 SQLite<sup class="footnote" id="fnref-6-5"><a href="#fn-6-5" rel="footnote">5</a></sup>数据库文件。若要查看数据库结构，可以使用 SQLite 数据库浏览器打开 <code>db/development.sqlite3</code> 文件（如图 6.3 所示）。和图 6.2 中的模型对比之后，你会发现 <code>id</code> 列在迁移文件中没有定义。在 <a href="chapter2.html#section-2-2">2.2 节</a> 中介绍过，Rails 把这个列作为行的唯一标识符。</p>

<div class="figure" id="figure-6-3">
  <img src="figures/sqlite_database_browser.png" alt="sqlite database browser" /><p class="caption"><span>图 6.3：</span>用 SQLite 数据库浏览器查看刚创建的 users 表</p>
</div>
<p>大多数迁移，包括本教程中的所有迁移，都是可逆的，也就是说可以通过一个简单的 Rake 命令“向下迁移”，撤销之前的迁移操作，这个命令是 <code>db:rollback</code>：</p>

<div class="codeblock"><div class="highlight type-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake db:rollback
</pre></div>
</div>
<p>（另外还有一个撤销迁移的方法请查看<a href="chapter3.html#aside-3-2">旁注 3.2</a>。）这个命令会调用 <code>drop_table</code> 方法把 users 表从数据库中删除。我们之所以可以这么做，是因为 <code>change</code> 方法知道 <code>create_table</code> 的反操作是 <code>drop_table</code>，所以回滚时就会直接调用 <code>drop_table</code> 方法。对于一些无法自动逆转的操作，例如删除列，就不能依赖 <code>change</code> 方法了，我们要分别定义 <code>up</code> 和 <code>down</code> 方法。关于迁移的更多内容请查看 Rails 指南。</p>

<p>如果你执行了上面的回滚操作，在继续阅读之前请再迁移回来：</p>

<div class="codeblock"><div class="highlight type-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake db:migrate
</pre></div>
</div>
<h3 id='section-6-1-2'><span>6.1.2</span> 模型文件</h3>


<p>我们介绍了怎样使用代码 6.1 生成的迁移文件（参见代码 6.2）创建用户模型，在图 6.3 中看到了执行迁移操作后的结果，即修改了 <code>db/development.sqlite3</code>，新建 <code>users</code> 表，并创建了 <code>id</code>、<code>name</code>、<code>email</code>、<code>created_at</code> 和 <code>updated_at</code> 这几个列。代码 6.1 同时也生成了模型文件，本节的目的就是来理解一下这个模型文件。</p>

<p>我们先从 User 模型的代码说起。模型文件存放在 <code>app/models</code> 目录下，名为 <code>user.rb</code>。这个文件的内容很简单（参见代码 6.3）。</p>

<div class="codeblock has-caption" id="codeblock-6-3"><p class="caption"><span>代码 6.3：</span>刚创建的 User 模型文件</p><p class="file"><code>app/models/user.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Base</span>
<span class="k">end</span>
</pre></div>
</div>
<p>在 <a href="chapter4.html#section-4-4-2">4.4.2 节</a>中介绍过，<code>class User &lt; ActiveRecord::Base</code> 的意思是 <code>User</code> 类继承自 <code>ActiveRecord::Base</code> 类，所以 User 模型就自动获得了 <code>ActiveRecord::Base</code> 提供的功能。当然了，只知道这种继承关系没什么用，我们并不知道 <code>ActiveRecord::Base</code> 做了什么。稍后我们会介绍一下这个类。在继续阅读之前，还有两件事要做。</p>

<h3 id='section-6-1-3'><span>6.1.3</span> 创建用户对象</h3>


<p>和 <a href="chapter4.html">第 4 章</a>一样，探索数据模型我们使用的工具是 Rails 控制台。因为我们还不想改动数据库，所以我们要在沙盒模式（sandbox）中启动控制台：</p>

<div class="codeblock"><div class="highlight type-sh"><pre><span class="nv">$ </span>rails console --sandbox
Loading development environment in sandbox
Any modifications you make will be rolled back on <span class="nb">exit</span>
&gt;&gt;
</pre></div>
</div>
<p>如提示信息所说，“Any modifications you make will be rolled back on exit”，在沙盒模式下使用控制台，退出当前会话后，对数据库做的所有改动都会回归到原来的状态。</p>

<p><a href="chapter4.html#section-4-4-5">4.4.5 节</a>中的控制台会话，需要手动加载自己编写的 <code>User</code> 类才能使用 <code>User.new</code> 创建用户对象。创建模型后，情况就不一样了。<a href="chapter4.html#section-4-4-4">4.4.4 节</a>中介绍过，Rails 控制台会自动加载 Rails 环境，当然也会自动加载模型。也就是说，现在无需加载额外的代码就可以直接创建用户对象了：</p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; User.new
<span class="o">=</span>&gt; <span class="c">#&lt;User id: nil, name: nil, email: nil, created_at: nil, updated_at: nil&gt;</span>
</pre></div>
</div>
<p>上述的的控制台显示了一个用户对象的默认值。</p>

<p>如果不为 <code>User.new</code> 指定参数，对象的所有属性值都是 <code>nil</code>。在 <a href="chapter4.html#section-4-4-5">4.4.5 节</a>中，自己编写的 <code>User</code> 类可以接受一个 Hash 参数用来初始化对象的属性，这种方式是受 Active Record 启发的，在 Active Record 中也可以使用相同的方式指定初始值：</p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; <span class="nv">user</span> <span class="o">=</span> User.new<span class="o">(</span>name: <span class="s2">"Michael Hartl"</span>, email: <span class="s2">"mhartl@example.com"</span><span class="o">)</span>
<span class="o">=</span>&gt; <span class="c">#&lt;User id: nil, name: "Michael Hartl", email: "mhartl@example.com", created_at: nil, updated_at: nil&gt;</span>
</pre></div>
</div>
<p>我们看到 <code>name</code> 和 <code>email</code> 属性的值都已经设定了。</p>

<p>如果查看开发日志的话，会发现没有什么新内容。这是因为 <code>User.new</code> 方法并没有改动数据库，只是在内存中创建了一个用户对象。如果要把用户对象保存到数据库中，要在 <code>user</code> 对象上调用 <code>save</code> 方法：</p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; user.save
<span class="o">=</span>&gt; <span class="nb">true</span>
</pre></div>
</div>
<p>如果保存成功，<code>save</code> 方法会返回 <code>true</code>；否则返回 <code>false</code>。（现在所有的保存操作都会成功<sup class="footnote" id="fnref-6-t1"><a href="#fn-6-t1" rel="footnote">6</a></sup>，<a href="chapter6.html#section-6-2">6.2 节</a>会看到保存失败的例子。）保存成功后，日志文件中就会出现一行 SQL 语句：<code>INSERT INTO "users"</code>。Active Record 提供了很多方法用来和数据库交互，所以你根本不需要直接使用SQL 语句，今后我也不会介绍 SQL 相关的知识。如果你想学习 SQL，可以查看日志文件。</p>

<p>你可能注意到了，刚创建时用户对象的 <code>id</code>、<code>created_at</code> 和 <code>updated_at</code> 属性值都是 <code>nil</code>，下面看一下保存之后有什么变化：</p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; <span class="nv">user</span>
<span class="o">=</span>&gt; <span class="c">#&lt;User id: 1, name: "Michael Hartl", email: "mhartl@example.com",</span>
created_at: <span class="s2">"2013-03-11 00:57:46"</span>, updated_at: <span class="s2">"2013-03-11 00:57:46"</span>&gt;00:57:46<span class="s2">", updated_at: "</span>2011-12-05 00:57:46<span class="err">"</span>&gt;
</pre></div>
</div>
<p>如上述代码所示，<code>id</code> 的值变成 <code>1</code> 了，那两个自动创建的时间戳属性也变成了当前的时间。<sup class="footnote" id="fnref-6-6"><a href="#fn-6-6" rel="footnote">7</a></sup>现在这两个时间戳是一样的，<a href="chapter6.html#section-6-1-5">6.1.5 节</a>会看到二者不同的情况。</p>

<p>和 <a href="chapter4.html#section-4-4-5">4.4.5 节</a>中的 <code>User</code> 类一样，User 模型的实例也可以使用点号获取属性：<sup class="footnote" id="fnref-6-7"><a href="#fn-6-7" rel="footnote">8</a></sup></p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; user.name
<span class="o">=</span>&gt; <span class="s2">"Michael Hartl"</span>
&gt;&gt; user.email
<span class="o">=</span>&gt; <span class="s2">"mhartl@example.com"</span>
&gt;&gt; user.updated_at
<span class="o">=</span>&gt; Mon, 11 Mar 2013 00:57:46 UTC +00:00
</pre></div>
</div>
<p>在<a href="chapter7.html">第 7 章</a>中会介绍，虽然一般习惯把创建和保存分成如上所示的两步分别操作，不过 Active Record 也允许我们使用 <code>User.create</code> 方法把这两步合成一步：</p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; User.create<span class="o">(</span>name: <span class="s2">"A Nother"</span>, email: <span class="s2">"another@example.org"</span><span class="o">)</span>
<span class="c">#&lt;User id: 2, name: "A Nother", email: "another@example.org", created_at:</span>
<span class="s2">"2013-03-11 01:05:24"</span>, updated_at: <span class="s2">"2013-03-11 01:05:24"</span>&gt;
&gt;&gt; <span class="nv">foo</span> <span class="o">=</span> User.create<span class="o">(</span>name: <span class="s2">"Foo"</span>, email: <span class="s2">"foo@bar.com"</span><span class="o">)</span>
<span class="c">#&lt;User id: 3, name: "Foo", email: "foo@bar.com", created_at: "2013-03-11</span>
01:05:42<span class="s2">", updated_at: "</span>2013-03-11 01:05:42<span class="err">"</span>&gt;
</pre></div>
</div>
<p>注意，<code>User.create</code> 的返回值不是 <code>true</code> 或 <code>false</code>，而是返回创建的用户对象，可直接赋值给变量（例如上面第二个命令中的 <code>foo</code> 变量）.</p>

<p><code>create</code> 的反操作是 <code>destroy</code>：</p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; foo.destroy
<span class="o">=</span>&gt; <span class="c">#&lt;User id: 3, name: "Foo", email: "foo@bar.com", created_at: "2013-03-11</span>
01:05:42<span class="s2">", updated_at: "</span>2013-03-11 01:05:42<span class="err">"</span>&gt;
</pre></div>
</div>
<p>奇怪的是，<code>destroy</code> 和 <code>create</code> 一样，返回值是销毁的对象。我不觉得什么地方会用到 <code>destroy</code> 的返回值。更奇怪的事情是，销毁的对象还在内存中：</p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; <span class="nv">foo</span>
<span class="o">=</span>&gt; <span class="c">#&lt;User id: 3, name: "Foo", email: "foo@bar.com", created_at: "2013-03-11</span>
01:05:42<span class="s2">", updated_at: "</span>2013-03-11 01:05:42<span class="err">"</span>&gt;
</pre></div>
</div>
<p>那么我们怎么知道对象是否真的被销毁了呢？对于已经保存而没有销毁的对象，怎样从数据库中获取呢？要回答这些问题，我们要先学习如何使用 Active Record 查找用户对象。</p>

<h3 id='section-6-1-4'><span>6.1.4</span> 查找用户对象</h3>


<p>Active Record 为查找对象提供了好几种方法。我们要使用这些方法来查找刚创建的第一个用户，同时也验证一下第三个用户（<code>foo</code>）是否被销毁了。先看一下还存在的用户：</p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; User.find<span class="o">(</span>1<span class="o">)</span>
<span class="o">=</span>&gt; <span class="c">#&lt;User id: 1, name: "Michael Hartl", email: "mhartl@example.com",</span>
created_at: <span class="s2">"2013-03-11 00:57:46"</span>, updated_at: <span class="s2">"2013-03-11 00:57:46"</span>&gt;
</pre></div>
</div>
<p>我们把用户的 id 传递给 <code>User.find</code> 方法，Active Record 会返回 id 为1 的用户对象。</p>

<p>下面来看一下 id 为 3 的用户是否还在数据库中：</p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; User.find<span class="o">(</span>3<span class="o">)</span>
<span class="o">=</span>&gt; <span class="c">#ActiveRecord::RecordNotFound: Couldn't find User with ID=3</span>
</pre></div>
</div>
<p>因为在 <a href="chapter6.html#section-6-1-3">6.1.3 节</a>中销毁了第三个用户，所以 Active Record 无法在数据库中找到，抛出了一个异常，说明在查找过程中出现了问题。因为 id 不存在，所以 <code>find</code> 方法才会抛出 <code>ActiveRecord::RecordNotFound</code> 异常。<sup class="footnote" id="fnref-6-8"><a href="#fn-6-8" rel="footnote">9</a></sup></p>

<p>除了 <code>find</code> 方法之外，Active Record 还支持指定属性来查找用户：</p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; User.find_by_email<span class="o">(</span><span class="s2">"mhartl@example.com"</span><span class="o">)</span>
<span class="o">=</span>&gt; <span class="c">#&lt;User id: 1, name: "Michael Hartl", email: "mhartl@example.com",</span>
created_at: <span class="s2">"2013-03-11 00:57:46"</span>, updated_at: <span class="s2">"2013-03-11 00:57:46"</span>&gt;
</pre></div>
</div>
<p><code>find_by_email</code> 方法是 Active Record 根据 <code>users</code> 表中的 <code>email</code> 列自动定义的（你可能猜到了，Active Record 还定义了 <code>find_by_name</code> 方法）。从 Rails 4.0 开始，通过属性查找记录推荐的做法是使用 <code>find_by</code> 方法，属性值以 Hash 形式传入：</p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; User.find_by<span class="o">(</span>email: <span class="s2">"mhartl@example.com"</span><span class="o">)</span>
<span class="o">=</span>&gt; <span class="c">#&lt;User id: 1, name: "Michael Hartl", email: "mhartl@example.com",</span>
created_at: <span class="s2">"2013-03-11 00:57:46"</span>, updated_at: <span class="s2">"2013-03-11 00:57:46"</span>&gt;
</pre></div>
</div>
<p>因为我们会把 Email 地址当成用户名使用，所以在实现用户登录功能时，这种查找用户的方式会很有用（参见<a href="chapter7.html">第 7 章</a>）。你也许会担心如果用户数量过多，使用 <code>find_by</code> 的效率不高。事实的确如此，我们会在 <a href="chapter6.html#section-6-2-5">6.2.5 节</a>介绍这个问题，以及解决方法，即使用数据库索引。</p>

<p>最后我们还要介绍几个常用的用户查找方法。首先是 <code>first</code> 方法：</p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; User.first
<span class="o">=</span>&gt; <span class="c">#&lt;User id: 1, name: "Michael Hartl", email: "mhartl@example.com",</span>
created_at: <span class="s2">"2013-03-11 00:57:46"</span>, updated_at: <span class="s2">"2013-03-11 00:57:46"</span>&gt;
</pre></div>
</div>
<p>很明显，<code>first</code> 会返回数据库中的第一个用户。还有 <code>all</code> 方法：</p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; User.all
<span class="o">=</span>&gt; <span class="o">[</span><span class="c">#&lt;User id: 1, name: "Michael Hartl", email: "mhartl@example.com",</span>
created_at: <span class="s2">"2013-03-11 00:57:46"</span>, updated_at: <span class="s2">"2013-03-11 00:57:46"</span>&gt;,
<span class="c">#&lt;User id: 2, name: "A Nother", email: "another@example.org", created_at:</span>
<span class="s2">"2013-03-11 01:05:24"</span>, updated_at: <span class="s2">"2013-03-11 01:05:24"</span>&gt;<span class="o">]</span>
</pre></div>
</div>
<p><code>all</code> 方法会返回一个数组，包含数据库中的所有用户。</p>

<h3 id='section-6-1-5'><span>6.1.5</span> 更新用户对象</h3>


<p>创建对象后，一般都会进行更新操作。更新有两种基本的方式，其一，我们可以分别为各属性赋值，在 <a href="chapter4.html#section-4-4-5">4.4.5 节</a>中就是这么做的：</p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; user           <span class="c"># Just a reminder about our user's attributes</span>
<span class="o">=</span>&gt; <span class="c">#&lt;User id: 1, name: "Michael Hartl", email: "mhartl@example.com",</span>
created_at: <span class="s2">"2013-03-11 00:57:46"</span>, updated_at: <span class="s2">"2013-03-11 00:57:46"</span>&gt;
&gt;&gt; user.email <span class="o">=</span> <span class="s2">"mhartl@example.net"</span>
<span class="o">=</span>&gt; <span class="s2">"mhartl@example.net"</span>
&gt;&gt; user.save
<span class="o">=</span>&gt; <span class="nb">true</span>
</pre></div>
</div>
<p>注意，最后一个命令是必须的，我们要把改动写入数据库。我们可以执行 <code>reload</code> 命令来看一下没保存的话是什么情况。<code>reload</code> 命令会使用数据库中的数据重新加载对象：</p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; user.email
<span class="o">=</span>&gt; <span class="s2">"mhartl@example.net"</span>
&gt;&gt; user.email <span class="o">=</span> <span class="s2">"foo@bar.com"</span>
<span class="o">=</span>&gt; <span class="s2">"foo@bar.com"</span>
&gt;&gt; user.reload.email
<span class="o">=</span>&gt; <span class="s2">"mhartl@example.net"</span>
</pre></div>
</div>
<p>现在我们已经更新了用户数据，如在 <a href="chapter6.html#section-6-1-3">6.1.3 节</a>中所说，自动创建的那两个时间戳属性就不一样了：</p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; user.created_at
<span class="o">=</span>&gt; <span class="s2">"2013-03-11 00:57:46"</span>
&gt;&gt; user.updated_at
<span class="o">=</span>&gt; <span class="s2">"2013-03-11 01:37:32"</span>
</pre></div>
</div>
<p>更新数据的第二种常用方式是使用 <code>update_attributes</code> 方法：</p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; user.update_attributes<span class="o">(</span>name: <span class="s2">"The Dude"</span>, email: <span class="s2">"dude@abides.org"</span><span class="o">)</span>
<span class="o">=</span>&gt; <span class="nb">true</span>
&gt;&gt; user.name
<span class="o">=</span>&gt; <span class="s2">"The Dude"</span>
&gt;&gt; user.email
<span class="o">=</span>&gt; <span class="s2">"dude@abides.org"</span>
</pre></div>
</div>
<p><code>update_attributes</code> 方法可接受一个指定对象属性的 Hash 作为参数，如果操作成功，会执行更新和保存两个命令（保存成功时返回值为 <code>true</code>）。注意，如果任何一个数据验证失败了，例如存储记录时需要密码（会在 <a href="chapter6.html#section-6-3">6.3 节</a>实现），<code>update_attributes</code> 操作就会失败。如果要更新单个属性，请使用 <code>update_attribute</code>，这样就能跳过验证限制了：</p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; user.update_attribute<span class="o">(</span>:name, <span class="s2">"The Dude"</span><span class="o">)</span>
<span class="o">=</span>&gt; <span class="nb">true</span>
&gt;&gt; user.name
<span class="o">=</span>&gt; <span class="s2">"The Dude"</span>
</pre></div>
</div>
<h2 id='section-6-2'><span>6.2</span> 用户数据验证</h2>


<p><a href="chapter6.html#section-6-1">6.1 节</a>创建的 User 模型现在已经有了可以使用的 <code>name</code> 和 <code>email</code> 属性，不过功能还很简单：任何字符串（包括空字符串）都可以使用。名字和 Email 地址的格式显然要复杂一些。例如，<code>name</code> 不应该是空白的，<code>email</code> 应该符合 Email 地址的特定格式。而且，我们要把 Email 地址当成用户名用来登录，那么某个 Email 地址在数据库中就应该是唯一的。</p>

<p>总之，<code>name</code> 和 <code>email</code> 不是什么字符串都可以接受的，我们要对二者可接受的值做个限制。Active Record 是通过数据验证机制（validation）实现这种限制的。本节，我们会介绍几种常用的数据验证：存在性、长度、格式和唯一性。在 <a href="chapter6.html#section-6-3-4">6.3.4 节</a>还会介绍另一种常用的数据验证：二次确认。<a href="chapter7.html#section-7-3">7.3 节</a>会看到，如果提交了不合要求的数据，数据验证机制会显示一些很有用的错误提示信息。</p>

<h3 id='section-6-2-1'><span>6.2.1</span> 用户模型测试</h3>


<p>和开发示例程序的其他功能一样，我们会使用 TDD 方式添加 User 模型的数据验证功能。因为生成 User 模型时没有指定 <code>--no-test-framework</code> 旗标（和代码 5.29 不同），代码 6.1 中的命令会自动为 User 模型生成一个初始的测试文件，不过文件中没有什么内容（参见代码 6.4）。</p>

<div class="codeblock has-caption" id="codeblock-6-4"><p class="caption"><span>代码 6.4：</span>几乎没什么内容的 User 模型测试文件</p><p class="file"><code>spec/models/user_spec.rb</code></p><div class="highlight type-ruby"><pre><span class="nb">require</span> <span class="s1">'spec_helper'</span>
<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>
  <span class="n">pending</span> <span class="s2">"add some examples to (or delete) </span><span class="si">#{</span><span class="bp">__FILE__</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</pre></div>
</div>
<p>上述代码使用了 <code>pending</code> 方法，提示我们应该编写一些真正有用的测试。我们可以准备一个空“测试数据库”然后运行 User 模型的测试看一下现在的情况：</p>

<div class="codeblock"><div class="highlight type-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake db:migrate
<span class="nv">$ </span>bundle <span class="nb">exec </span>rake <span class="nb">test</span>:prepare
<span class="nv">$ </span>bundle <span class="nb">exec </span>rspec spec/models/user_spec.rb
*


Finished in 0.01999 seconds
1 example, 0 failures, 1 pending

Pending:
  User add some examples to <span class="o">(</span>or delete<span class="o">)</span>
  /Users/mhartl/rails_projects/sample_app/spec/models/user_spec.rb
  <span class="o">(</span>Not Yet Implemented<span class="o">)</span>
</pre></div>
</div>
<p>在大多数系统中，有待实现的测试都会显示为黄色，介于通过（绿色）和失败（红色）之间。</p>

<p>这是我们第一次看到创建“测试数据库”的正确命令：</p>

<div class="codeblock"><div class="highlight type-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake <span class="nb">test</span>:prepare
</pre></div>
</div>
<p>这个命令会把“开发数据库” <code>db/development.sqlite3</code> 中的数据模型复制到“测试数据库” <code>db/test.sqlite3</code> 中。（执行迁移后很多人经常都会忘记执行这个 Rake 任务。而且，“测试数据库”经常会损坏，需要还原。如果测试出现了莫名其妙的问题，可以执行 <code>rake test:prepare</code> 看能否解决。）</p>

<p>我们会按照提示的建议，编写一些 RSpec 测试用例，如代码 6.5 所示。</p>

<div class="codeblock has-caption" id="codeblock-6-5"><p class="caption"><span>代码 6.5：</span>针对 <code>:name</code> 和 <code>:email</code> 属性的测试</p><p class="file"><code>spec/models/user_spec.rb</code></p><div class="highlight type-ruby"><pre><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">"Example User"</span><span class="p">,</span> <span class="ss">email</span><span class="p">:</span> <span class="s2">"user@example.com"</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">subject</span> <span class="p">{</span> <span class="vi">@user</span> <span class="p">}</span>

  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:email</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div>
<p><code>before</code> 块，在代码 5.28 中用过，会在各测试用例之前执行块中的代码，本例中这个块的作用是为 <code>User.new</code> 传入一个合法的初始 Hash 参数，创建 <code>@user</code> 实例变量。接下来的</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">subject</span> <span class="p">{</span> <span class="vi">@user</span> <span class="p">}</span>
</pre></div>
</div>
<p>把 <code>@user</code> 设为这些测试用例默认的测试对象。在 <a href="chapter5.html#section-5-3-4">5.3.4 节</a>中设定的测试对象是 <code>page</code> 变量。</p>

<p>代码 6.5 中的两个测试用例对 <code>name</code> 和 <code>email</code> 属性的存在性进行了测试：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span> <span class="p">}</span>
<span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:email</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>其实，这两个测试用例使用的是 Ruby 的 <code>respond_to?</code> 方法，这个方法可以接受一个 Symbol 参数，如果对象可以响应指定的方法或属性就返回 <code>true</code>，否则返回 <code>false</code>：</p>

<div class="codeblock"><div class="highlight type-sh"><pre><span class="nv">$ </span>rails console --sandbox
&gt;&gt; <span class="nv">user</span> <span class="o">=</span> User.new
&gt;&gt; user.respond_to?<span class="o">(</span>:name<span class="o">)</span>
<span class="o">=</span>&gt; <span class="nb">true</span>
&gt;&gt; user.respond_to?<span class="o">(</span>:foobar<span class="o">)</span>
<span class="o">=</span>&gt; <span class="nb">false</span>
</pre></div>
</div>
<p>（在 <a href="chapter4.html#section-4-2-3">4.2.3 节</a>中介绍过，Ruby 使用问号标明返回值是布尔值的方法。）这些测试使用了 RSpec 关于布尔值的约定，所以如下的代码</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="vi">@user</span><span class="o">.</span><span class="n">respond_to?</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span>
</pre></div>
</div>
<p>在 RSpec 中可以写成</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">it</span> <span class="s2">"should respond to 'name'"</span> <span class="k">do</span>
  <span class="n">expect</span><span class="p">(</span><span class="vi">@user</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>因为指定了 <code>subject { @user }</code>，我们还可以写成在 <a href="chapter5.html#section-5-3-4">5.3.4 节</a>中用过的单行形式：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>为 User 模型添加新方法或新属性时可以采用这种测试方式，而且使用这种方式还能清晰的列出 <code>User</code> 实例对象可以响应的所有方法。</p>

<p>因为我们前面已经执行 <code>rake test:prepare</code> 命令准备好了“测试数据库”，所以测试应该是通过的：</p>

<div class="codeblock"><div class="highlight type-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rspec spec/
</pre></div>
</div>
<h3 id='section-6-2-2'><span>6.2.2</span> 验证存在性</h3>


<p>存在性验证算是最基本的验证了，它只是检查给定的属性是否存在。本节我们就会确保在用户存入数据库之前，名字和 Email 地址字段都是存在的。<a href="chapter7.html#section-7-3-3">7.3.3 节</a>会介绍如何把这个限制应用在创建用户的注册表单中。</p>

<p>我们先来编写检查 <code>name</code> 属性是否存在的测试。虽然 TDD 的第一步是写一个失败测试（参见 <a href="chapter3.html#section-3-2-1">3.2.1 节</a>），不过此时我们还没有完全理解数据验证是怎么实现的，无法编写合适的测试，所以我们暂时先把数据验证加进来，在控制台中实操一下，理解一下验证机制。然后我们会把验证代码注释掉，编写失败测试，再把注释去掉，看一下测试是否还是可以通过的。这么做对这样简单的测试来说可能有点小题大做，不过我见过很多“简单”的测试并没有检查真正要测试的内容。要保证测试检测真正需要检测的内容，最好谨慎一点。（这种加注释的方法在为没有测试的应用程序编写测试时也经常用到。）</p>

<p>验证 <code>name</code> 属性是否存在的方法是使用 <code>validates</code> 方法，传入 <code>presence: true</code> 参数，如代码 6.6 所示。参数 <code>presence: true</code> 是只有一个元素的可选 Hash 参数。我们在 <a href="chapter4.html#section-4-3-4">4.3.4 节</a>中介绍过，如果方法的最后一个参数是 Hash 的话，可以省略 Hash 的花括号。（如 <a href="chapter5.html#section-5-1-1">5.1.1 节</a>中提到的，这样的可选 Hash 在 Rails 中很普遍。）</p>

<div class="codeblock has-caption" id="codeblock-6-6"><p class="caption"><span>代码 6.6：</span>验证 <code>name</code> 属性的存在性</p><p class="file"><code>app/models/user.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Base</span>
  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span>
<span class="k">end</span>
</pre></div>
</div>
<p>代码 6.6 看起来很神奇，其实 <code>validates</code> 只不过是一个方法而已。加上括号后等效的代码如下：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Base</span>
  <span class="n">validates</span><span class="p">(</span><span class="ss">:name</span><span class="p">,</span> <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>下面在控制台中看一下，为 User 模型添加这个验证之后的效果：<sup class="footnote" id="fnref-6-9"><a href="#fn-6-9" rel="footnote">10</a></sup></p>

<div class="codeblock"><div class="highlight type-sh"><pre><span class="nv">$ </span>rails console --sandbox
&gt;&gt; <span class="nv">user</span> <span class="o">=</span> User.new<span class="o">(</span>name: <span class="s2">""</span>, email: <span class="s2">"mhartl@example.com"</span><span class="o">)</span>
&gt;&gt; user.save
<span class="o">=</span>&gt; <span class="nb">false</span>
&gt;&gt; user.valid?
<span class="o">=</span>&gt; <span class="nb">false</span>
</pre></div>
</div>
<p><code>user.save</code> 的返回值是 <code>false</code>，说明存储失败了。最后一个命令使用了 <code>valid?</code> 方法，如果对象没有通过任意一个验证就会返回 <code>false</code>，如果全部验证都通过了则返回 <code>true</code>。这个例子只有一个验证，所以我们知道是哪个验证失败了，不过看一下失败的提示信息还是会有点收获的：</p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; user.errors.full_messages
<span class="o">=</span>&gt; <span class="o">[</span><span class="s2">"Name can't be blank"</span><span class="o">]</span>
</pre></div>
</div>
<p>（错误提示信息暗示了 Rails 中属性存在性验证使用的是 <code>blank?</code> 方法，在 <a href="chapter4.html#section-4-4-3">4.4.3 节</a>的末尾用过这个方法。）</p>

<p>现在来编写测试用例。为了保证测试是失败的，我们要把验证用到的代码注释掉，如代码 6.7 所示。</p>

<div class="codeblock has-caption" id="codeblock-6-7"><p class="caption"><span>代码 6.7：</span>注释掉验证代码，保证测试是失败的</p><p class="file"><code>app/models/user.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Base</span>
  <span class="c1"># validates :name, presence: true</span>
<span class="k">end</span>
</pre></div>
</div>
<p>对存在性验证的测试用例如代码 6.8 所示。</p>

<div class="codeblock has-caption" id="codeblock-6-8"><p class="caption"><span>代码 6.8：</span>验证 <code>name</code> 属性的失败测试</p><p class="file"><code>spec/models/user_spec.rb</code></p><div class="highlight type-ruby"><pre><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span> <span class="k">do</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">"Example User"</span><span class="p">,</span> <span class="ss">email</span><span class="p">:</span> <span class="s2">"user@example.com"</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">subject</span> <span class="p">{</span> <span class="vi">@user</span> <span class="p">}</span>

  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:email</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">be_valid</span> <span class="p">}</span>

  <span class="n">describe</span> <span class="s2">"when name is not present"</span> <span class="k">do</span>
    <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">" "</span> <span class="p">}</span>
    <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_valid</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>如下这个新加入的测试是为了保证测试的全面，确保 <code>@user</code> 对象开始时是合法的：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">be_valid</span> <span class="p">}</span>
</pre></div>
</div>
<p>这是 <a href="chapter6.html#section-6-2-1">6.2.1 节</a>中介绍的 RSpec 对布尔值约定的又一个实例：只要对象可以响应返回值为布尔值的方法 <code>foo?</code>，就有一个对应的 <code>be_foo</code> 可以在测试中使用。所以在本例中，我们可以把如下的测试</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="vi">@user</span><span class="o">.</span><span class="n">valid?</span>
</pre></div>
</div>
<p>写成</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">it</span> <span class="s2">"should be valid"</span> <span class="k">do</span>
  <span class="n">expect</span><span class="p">(</span><span class="vi">@user</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">be_valid</span>
<span class="k">end</span>
</pre></div>
</div>
<p>和之前一样，因为指定了 <code>subject { @user }</code>，所以就可以使用单行形式了：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">be_valid</span> <span class="p">}</span>
</pre></div>
</div>
<p>第二个测试用例先把用户的名字设为不合法的值（空格），然后测试 <code>@user</code> 对象是否是不合法的：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">describe</span> <span class="s2">"when name is not present"</span> <span class="k">do</span>
  <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">" "</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_valid</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div>
<p>这段代码使用 <code>before</code> 块把用户的名字设为一个不合法的值（空格），然后检查用户对象是否为不合法的。</p>

<p>现在你可以看一下测试是否是失败的：</p>

<div class="codeblock"><div class="highlight type-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rspec spec/models/user_spec.rb
...F
4 examples, 1 failure
</pre></div>
</div>
<p>现在去掉验证代码前的注释（把代码 6.7 变回代码 6.6），测试就可以通过了：</p>

<div class="codeblock"><div class="highlight type-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rspec spec/models/user_spec.rb
...
4 examples, 0 failures
</pre></div>
</div>
<p>接着，我们还要验证 Email 地址的存在性，测试代码和对 <code>name</code> 属性的测试类似，参见代码 6.9。</p>

<div class="codeblock has-caption" id="codeblock-6-9"><p class="caption"><span>代码 6.9：</span>对 <code>email</code> 属性存在性的测试</p><p class="file"><code>spec/models/user_spec.rb</code></p><div class="highlight type-ruby"><pre><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span> <span class="k">do</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">"Example User"</span><span class="p">,</span> <span class="ss">email</span><span class="p">:</span> <span class="s2">"user@example.com"</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">describe</span> <span class="s2">"when email is not present"</span> <span class="k">do</span>
    <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="s2">" "</span> <span class="p">}</span>
    <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_valid</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>验证的实现几乎也一样，如代码 6.10 所示。</p>

<div class="codeblock has-caption" id="codeblock-6-10"><p class="caption"><span>代码 6.10：</span>验证 <code>name</code> 和 <code>email</code> 属性的存在性</p><p class="file"><code>app/models/user.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Base</span>
  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span>  <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span>
<span class="k">end</span>
</pre></div>
</div>
<p>现在所有的测试应该都可以通过了，我们也就完成了存在性验证。</p>

<h3 id='section-6-2-3'><span>6.2.3</span> 长度验证</h3>


<p>我们已经对 User 模型可接受的数据做了一些限制，现在必须为用户提供一个名字，不过我们应该做的更进一步。用户的名字会在示例程序中显示，所以最好限制一下它的字符长度。有了 <a href="chapter6.html#section-6-2-2">6.2.2 节</a>的基础，这一步就简单了。</p>

<p>我们先来编写测试。最大长度并没有比较科学的方法来选定，我们就使用 50 作为长度的上限吧，那么我们就要确保 51 个字符超长了（参见代码 6.11）。</p>

<div class="codeblock has-caption" id="codeblock-6-11"><p class="caption"><span>代码 6.11：</span>对名字长度的测试</p><p class="file"><code>spec/models/user_spec.rb</code></p><div class="highlight type-ruby"><pre><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>
  <span class="n">before</span> <span class="k">do</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">"Example User"</span><span class="p">,</span> <span class="ss">email</span><span class="p">:</span> <span class="s2">"user@example.com"</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">describe</span> <span class="s2">"when name is too long"</span> <span class="k">do</span>
    <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">"a"</span> <span class="o">*</span> <span class="mi">51</span> <span class="p">}</span>
    <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_valid</span> <span class="p">}</span>
  <span class="k">end</span>
</pre></div>
</div>
<p>为了方便，在代码 6.11 中我们使用字符串连乘生成了一个有 51 个字符的字符串。在控制台中可以看到连乘是什么：</p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; <span class="s2">"a"</span> * <span class="nv">51</span>
<span class="o">=</span>&gt; <span class="s2">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</span>
&gt;&gt; <span class="o">(</span><span class="s2">"a"</span> * 51<span class="o">)</span>.length
<span class="o">=</span>&gt; 51
</pre></div>
</div>
<p>代码 6.11 中的测试应该会失败。为了让测试通过，我们要知道怎么使用限制长度的参数 <code>:length</code>，以及限制上限的 <code>:maximum</code> 参数。验证相关的代码如代码 6.12 所示。</p>

<div class="codeblock has-caption" id="codeblock-6-12"><p class="caption"><span>代码 6.12：</span>为 <code>name</code> 属性添加长度验证</p><p class="file"><code>app/models/user.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Base</span>
  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span>  <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">length</span><span class="p">:</span> <span class="p">{</span> <span class="ss">maximum</span><span class="p">:</span> <span class="mi">50</span> <span class="p">}</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span>
<span class="k">end</span>
</pre></div>
</div>
<p>现在测试应该可以通过了。既然测试又通过了，我们要实现另一个更具挑战性的验证了，即对 Email 格式的验证。</p>

<h3 id='section-6-2-4'><span>6.2.4</span> 格式验证</h3>


<p>对 <code>name</code> 属性的验证只需做一些简单的限制就好，任何非空、长度小于 51 个字符的字符串就可以。不过 <code>email</code> 属性则需要更复杂的限制。目前我们只是拒绝空的 Email 地址，本节我们要限制 Email 地址符合常用的形式，类似 <code>user@example.com</code> 这种。</p>

<p>这里我们用到的测试和验证不是十全十美的，只是刚刚好可以接受大多数的合法 Email 地址，并拒绝大多数不合法的 Email 地址。我们会先对一些合法的 Email 集合和不合法的 Email 集合进行测试。我们使用 <code>%w[]</code> 来创建集合，集合中的元素都是字符串形式，如下面的控制台会话所示：</p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; %w<span class="o">[</span>foo bar baz<span class="o">]</span>
<span class="o">=</span>&gt; <span class="o">[</span><span class="s2">"foo"</span>, <span class="s2">"bar"</span>, <span class="s2">"baz"</span><span class="o">]</span>
&gt;&gt; <span class="nv">addresses</span> <span class="o">=</span> %w<span class="o">[</span>user@foo.COM THE_US-ER@foo.bar.org first.last@foo.jp<span class="o">]</span>
<span class="o">=</span>&gt; <span class="o">[</span><span class="s2">"user@foo.COM"</span>, <span class="s2">"THE_US-ER@foo.bar.org"</span>, <span class="s2">"first.last@foo.jp"</span><span class="o">]</span>
&gt;&gt; addresses.each <span class="k">do</span> |address|
?&gt; puts address
&gt;&gt; end
user@foo.COM
THE_US-ER@foo.bar.org
first.last@foo.jp
</pre></div>
</div>
<p>在上面这个控制台会话中，我们使用 <code>each</code> 方法（参见 <a href="chapter4.html#section-4-3-2">4.3.2 节</a>）遍历 <code>address</code> 数组中的元素。使用 <code>each</code> 方法可以编写一些简单的 Email 格式验证测试用例（参见代码 6.13）。</p>

<div class="codeblock has-caption" id="codeblock-6-13"><p class="caption"><span>代码 6.13：</span>对 Email 格式验证的测试</p><p class="file"><code>spec/models/user_spec.rb</code></p><div class="highlight type-ruby"><pre><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span> <span class="k">do</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">"Example User"</span><span class="p">,</span> <span class="ss">email</span><span class="p">:</span> <span class="s2">"user@example.com"</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">describe</span> <span class="s2">"when email format is invalid"</span> <span class="k">do</span>
    <span class="n">it</span> <span class="s2">"should be invalid"</span> <span class="k">do</span>
      <span class="n">addresses</span> <span class="o">=</span> <span class="sx">%w[user@foo,com user_at_foo.org example.user@foo.</span>
<span class="sx">                     foo@bar_baz.com foo@bar+baz.com]</span>
      <span class="n">addresses</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">invalid_address</span><span class="o">|</span>
        <span class="vi">@user</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="n">invalid_address</span>
        <span class="n">expect</span><span class="p">(</span><span class="vi">@user</span><span class="p">)</span><span class="o">.</span><span class="n">not_to</span> <span class="n">be_valid</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">describe</span> <span class="s2">"when email format is valid"</span> <span class="k">do</span>
    <span class="n">it</span> <span class="s2">"should be valid"</span> <span class="k">do</span>
      <span class="n">addresses</span> <span class="o">=</span> <span class="sx">%w[user@foo.COM A_US-ER@f.b.org frst.lst@foo.jp a+b@baz.cn]</span>
      <span class="n">addresses</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">valid_address</span><span class="o">|</span>
        <span class="vi">@user</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="n">valid_address</span>
        <span class="n">expect</span><span class="p">(</span><span class="vi">@user</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">be_valid</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>如前所说，这些测试并不完美，不过我们测试了一些常用的合法的 Email 格式，例如 <code>user@foo.COM</code>、<code>THE_US-ER@foo.bar.org</code>（包含大写字母、下划线，以及子域名）和 <code>first.last@foo.jp</code>（用户名是合成的 <code>first.last</code>，顶级域名是两个字母形式的 <code>jp</code>（代表日本）），也测试了一些不合法的 Email 格式。</p>

<p>在应用程序中，我们会使用正则表达式定义要验证的 Email 格式，然后通过 <code>validates</code> 方法的 <code>:format</code> 参数指定合法的格式（参见代码 6.14）。</p>

<div class="codeblock has-caption" id="codeblock-6-14"><p class="caption"><span>代码 6.14：</span>使用正则表达式验证 Email 格式</p><p class="file"><code>app/models/user.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Base</span>
  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span>  <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">length</span><span class="p">:</span> <span class="p">{</span> <span class="ss">maximum</span><span class="p">:</span> <span class="mi">50</span> <span class="p">}</span>
  <span class="no">VALID_EMAIL_REGEX</span> <span class="o">=</span> <span class="sr">/\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="nb">format</span><span class="p">:</span> <span class="p">{</span> <span class="ss">with</span><span class="p">:</span> <span class="no">VALID_EMAIL_REGEX</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div>
<p>我们把这个正则表达式定义为常量 <code>VALID_EMAIL_REGEX</code>，Ruby 中的常量都是以大写字母开头的。</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="no">VALID_EMAIL_REGEX</span> <span class="o">=</span> <span class="sr">/\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i</span>
<span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="nb">format</span><span class="p">:</span> <span class="p">{</span> <span class="ss">with</span><span class="p">:</span> <span class="no">VALID_EMAIL_REGEX</span> <span class="p">}</span>
</pre></div>
</div>
<p>使用上面的代码可以确保只有匹配这个正则表达式的 Email 地址才是合法的。（因为 <code>VALID_EMAIL_REGEX</code> 以大写字母开头，是个常量，所以其值是不能改变的。）</p>

<p>那么，这个正则表达式是怎么编写出来的呢？正则表达式中的文本匹配模式是由简练的语言编写的（很多人会觉得很难读懂），学习如何编写正则表达式是一门艺术，为了便于理解，我会把 <code>VALID_EMAIL_REGEX</code> 拆分成几块来讲解（如<a href="chapter6.html#table-6-1">表格 6.1</a>所示）。<sup class="footnote" id="fnref-6-10"><a href="#fn-6-10" rel="footnote">11</a></sup>要想认真学习正则表达式，我推荐使用 Rubular 正则表达式编辑器（如图 6.4），这个工具在学习的过程中是必备的。<sup class="footnote" id="fnref-6-11"><a href="#fn-6-11" rel="footnote">12</a></sup>Rubular 网站的界面很友好，便于编写所需的正则表达式，网站中还有一个便捷的快速语法参考。我建议你使用 Rubular 来理解<a href="chapter6.html#table-6-1">表格 6.1</a>中的正则表达式片段。读的再多也不比不上在 Rubular 中实操几次。（注意：如果你在 Rubular 中输入代码 6.14 中用到的正则表达式，要把 <code>\A</code> 和 <code>\z</code> 去掉。）</p>

<div class="table has-caption" id="table-6-1">
  <p class="caption"><span>表格 6.1：</span>拆分代码 6.14 中匹配 Email 地址的正则表达式</p>
  <table><thead><tr><th>表达式</th>
      <th>含义</th>
    </tr></thead><tbody><tr><td><code>/\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i</code></td>
      <td>完整的正则表达式</td>
    </tr><tr><td><code>/</code></td>
      <td>正则表达式开始</td>
    </tr><tr><td><code>\A</code></td>
      <td>匹配字符串的开头</td>
    </tr><tr><td><code>[\w+\-.]+</code></td>
      <td>一个或多个字母、加号、连字符、或点号</td>
    </tr><tr><td><code>@</code></td>
      <td>匹配 @ 符号</td>
    </tr><tr><td><code>[a-z\d\-.]+</code></td>
      <td>一个或多个小写字母、数字、连字符或点号</td>
    </tr><tr><td><code>\.</code></td>
      <td>匹配点号</td>
    </tr><tr><td><code>[a-z]+</code></td>
      <td>一个或多个小写字母</td>
    </tr><tr><td><code>\z</code></td>
      <td>匹配字符串结尾</td>
    </tr><tr><td><code>/</code></td>
      <td>结束正则表达式</td>
    </tr><tr><td><code>i</code></td>
      <td>不区分大小写</td>
    </tr></tbody></table></div>
<div class="figure" id="figure-6-4">
  <img src="figures/rubular.png" alt="rubular" /><p class="caption"><span>图 6.4：</span>强大的 Rubular 正则表达式编辑器</p>
</div>
<p>顺便说一下，在官方标准中确实有一个正则表达式可以匹配所有的合法 Email 地址，但没必要使用这么复杂的正则表达式，代码 6.14 中使用的正则表达式就很好，甚至可能比官方的更好。<sup class="footnote" id="fnref-6-12"><a href="#fn-6-12" rel="footnote">13</a></sup>不过，上面的正则表达式有一个缺陷，能匹配 <code>foo@bar..com</code> 这种有连续点号的地址。修正这个瑕疵的方法会留作练习，参见 <a href="chapter6.html#section-6-5">6.5 节</a>。</p>

<p>现在，测试应该都可以通过了。（其实，对合法 Email 地址的测试一直都是可以通过的，因为正则表达式很容易出错，进行合法 Email 格式测试只是为了检测 <code>VALID_EMAIL_REGEX</code> 是否可用。）那么就只剩一个限制要实现了：确保 Email 地址的唯一性。</p>

<h3 id='section-6-2-5'><span>6.2.5</span> 唯一性验证</h3>


<p>确保 Email 地址的唯一性（这样才能作为用户名），要使用 <code>validates</code> 方法的 <code>unique</code> 参数。提前说明，实现的过程中存在一个很大的陷阱，所以不要轻易的跳过本小节，要认真的阅读。</p>

<p>和之前一样，先来编写测试。之前的模型测试，只是使用 <code>User.new</code> 在内存中创建一个对象，而做唯一性测试则要把数据存入数据库中。<sup class="footnote" id="fnref-6-13"><a href="#fn-6-13" rel="footnote">14</a></sup>对相同 Email 地址的（第一个）测试如代码 6.15 所示。</p>

<div class="codeblock has-caption" id="codeblock-6-15"><p class="caption"><span>代码 6.15：</span>拒绝相同 Email 地址的测试</p><p class="file"><code>spec/models/user_spec.rb</code></p><div class="highlight type-ruby"><pre><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span> <span class="k">do</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">"Example User"</span><span class="p">,</span> <span class="ss">email</span><span class="p">:</span> <span class="s2">"user@example.com"</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">describe</span> <span class="s2">"when email address is already taken"</span> <span class="k">do</span>
    <span class="n">before</span> <span class="k">do</span>
      <span class="n">user_with_same_email</span> <span class="o">=</span> <span class="vi">@user</span><span class="o">.</span><span class="n">dup</span>
      <span class="n">user_with_same_email</span><span class="o">.</span><span class="n">save</span>
    <span class="k">end</span>

    <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_valid</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>我们使用 <code>@user.dup</code> 方法创建一个和 <code>@user</code> Email 地址一样的用户对象，然后存储这个用户，因为数据库中的 <code>@user</code> 已经占用了这个 Email 地址，所以不能成功存入，无法得到一个合法的用户记录。</p>

<p>代码 6.16 中的代码可以让代码 6.15 中的测试通过。</p>

<div class="codeblock has-caption" id="codeblock-6-16"><p class="caption"><span>代码 6.16：</span>验证 Email 地址的唯一性</p><p class="file"><code>app/models/user.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Base</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="nb">format</span><span class="p">:</span> <span class="p">{</span> <span class="ss">with</span><span class="p">:</span> <span class="no">VALID_EMAIL_REGEX</span> <span class="p">},</span> <span class="ss">uniqueness</span><span class="p">:</span> <span class="kp">true</span>
<span class="k">end</span>
</pre></div>
</div>
<p>这还不行，一般来说 Email 地址是按照不区分大小写来处理的，也就说 <code>foo@bar.com</code> 和 <code>FOO@BAR.COM</code> 或 <code>FoO@BAr.coM</code> 是等效的，所以验证时也要考虑这种情况。<sup class="footnote" id="fnref-6-14"><a href="#fn-6-14" rel="footnote">15</a></sup>代码 6.17 是针对这种问题的测试代码。</p>

<div class="codeblock has-caption" id="codeblock-6-17"><p class="caption"><span>代码 6.17：</span>拒绝相同 Email 地址的测试，不区分大小写</p><p class="file"><code>spec/models/user_spec.rb</code></p><div class="highlight type-ruby"><pre><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span> <span class="k">do</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">"Example User"</span><span class="p">,</span> <span class="ss">email</span><span class="p">:</span> <span class="s2">"user@example.com"</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">describe</span> <span class="s2">"when email address is already taken"</span> <span class="k">do</span>
    <span class="n">before</span> <span class="k">do</span>
      <span class="n">user_with_same_email</span> <span class="o">=</span> <span class="vi">@user</span><span class="o">.</span><span class="n">dup</span>
      <span class="n">user_with_same_email</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="vi">@user</span><span class="o">.</span><span class="n">email</span><span class="o">.</span><span class="n">upcase</span>
      <span class="n">user_with_same_email</span><span class="o">.</span><span class="n">save</span>
    <span class="k">end</span>

    <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_valid</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>上面的代码，在字符串上调用了 <code>upcase</code> 方法（参照 <a href="chapter4.html#section-4-3-2">4.3.2 节</a>）。这个测试和前面对相同 Email 地址的测试类似，只是把 Email 地址转换成全部大写字母的形式。如果觉得太抽象，那就在控制台中实操一下吧：</p>

<div class="codeblock"><div class="highlight type-sh"><pre><span class="nv">$ </span>rails console --sandbox
&gt;&gt; <span class="nv">user</span> <span class="o">=</span> User.create<span class="o">(</span>name: <span class="s2">"Example User"</span>, email: <span class="s2">"user@example.com"</span><span class="o">)</span>
&gt;&gt; user.email.upcase
<span class="o">=</span>&gt; <span class="s2">"USER@EXAMPLE.COM"</span>
&gt;&gt; <span class="nv">user_with_same_email</span> <span class="o">=</span> user.dup
&gt;&gt; user_with_same_email.email <span class="o">=</span> user.email.upcase
&gt;&gt; user_with_same_email.valid?
<span class="o">=</span>&gt; <span class="nb">true</span>
</pre></div>
</div>
<p>现在 <code>user_with_same_email.valid?</code> 的返回值是 <code>true</code>，因为唯一性验证还是区分大小写的。我们希望得到的结果是 <code>false</code>。幸好 <code>uniqueness</code> 可以指定 <code>:case_sensitive</code> 选项，正好可以解决这个问题，如代码 6.18 所示。</p>

<div class="codeblock has-caption" id="codeblock-6-18"><p class="caption"><span>代码 6.18：</span>验证 Email 地址的唯一性，不区分大小写</p><p class="file"><code>app/models/user.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Base</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span>
                    <span class="nb">format</span><span class="p">:</span> <span class="p">{</span> <span class="ss">with</span><span class="p">:</span> <span class="no">VALID_EMAIL_REGEX</span> <span class="p">},</span>
                    <span class="ss">uniqueness</span><span class="p">:</span> <span class="p">{</span> <span class="n">case_sensitive</span><span class="p">:</span> <span class="kp">false</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div>
<p>注意，我们直接把 <code>true</code> 换成了 <code>case_sensitive: false</code>，Rails 会自动指定 <code>:uniqueness</code> 的值为 <code>true</code>。至此，应用程序虽还有不足，但基本可以保证 Email 地址的唯一性了，所有的测试都可以通过了。</p>

<h4 id='section-6-2-5-1'><span></span>唯一性验证的不足</h4>


<p>现在还有一个小问题，在此衷心的提醒你：<strong>唯一性验证无法真正保证唯一性。</strong></p>

<p>不会吧，哪里出了问题呢？下面我来解释一下。</p>

<ol><li>Alice 用 alice@wonderland.com 注册；</li>
  <li>Alice 不小心按了两次提交按钮，连续发送了两次请求；</li>
  <li>然后就会发生下面的事情：请求 1 在内存中新建了一个用户对象，通过验证；请求 2 也一样。请求 1 创建的用户存入了数据库，请求 2 创建的用户也存入了数据库。</li>
  <li>结果是，尽管有唯一性验证，数据库中还是有两条用户记录的 Email 地址是一样的。</li>
</ol><p>相信我，上面这种难以置信的过程是可能会发生的，只要有一定的访问量，在任何 Rails 网站中都可能发生。幸好解决的办法很容易实现，只需在数据库层也加上唯一性限制。我们要做的是在数据库中为 <code>email</code> 列建立索引，然后为索引加上唯一性限制。</p>

<p>为 <code>email</code> 列建立索引就要改变数据库模型，在 Rails 中可以通过迁移实现（参见 <a href="chapter6.html#section-6-1-1">6.1.1 节</a>）。在 <a href="chapter6.html#section-6-1-1">6.1.1 节</a> 中我们看到，生成 User 模型时会自动创建一个迁移文件（参见代码 6.2），现在我们是要改变已经存在的模型结构，那么使用 <code>migration</code> 命令直接创建迁移文件就可以了：</p>

<div class="codeblock"><div class="highlight type-sh"><pre><span class="nv">$ </span>rails generate migration add_index_to_users_email
</pre></div>
</div>
<p>和 User 模型的迁移不一样，实现 Email 唯一性的迁移操作没有事先定义的模板可用，所以我们要手动把代码 6.19 中的内容写入迁移文件。<sup class="footnote" id="fnref-6-15"><a href="#fn-6-15" rel="footnote">16</a></sup></p>

<div class="codeblock has-caption" id="codeblock-6-19"><p class="caption"><span>代码 6.19：</span>确保 Email 唯一性的迁移文件</p><p class="file"><code>db/migrate/[timestamp]_add_index_to_users_email.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">AddIndexToUsersEmail</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">add_index</span> <span class="ss">:users</span><span class="p">,</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">unique</span><span class="p">:</span> <span class="kp">true</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>上述代码调用了 Rails 中的 <code>add_index</code> 方法，为 <code>users</code> 表的 <code>email</code> 列建立索引。索引本身并不能保证唯一性，所以还要指定 <code>unique: true</code>。</p>

<p>然后执行数据库迁移操作：</p>

<div class="codeblock"><div class="highlight type-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake db:migrate
</pre></div>
</div>
<p>（如果失败的话，就退出所有打开的控制台沙盒会话，这些会话可能会锁定数据库，拒绝进行迁移操作。）如果你想看一下操作执行后的效果，请打开 <code>db/schema.rb</code> 文件，会发现多了一行：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">add_index</span> <span class="s2">"users"</span><span class="p">,</span> <span class="o">[</span><span class="s2">"email"</span><span class="o">]</span><span class="p">,</span> <span class="nb">name</span><span class="p">:</span> <span class="s2">"index_users_on_email"</span><span class="p">,</span> <span class="ss">unique</span><span class="p">:</span> <span class="kp">true</span>
</pre></div>
</div>
<p>为了保证 Email 地址的唯一性，还要做些修改：存入数据库之前把 Email 地址转换成全小写字母的形式，因为不是所有数据库适配器的索引都是区分大小写的。<sup class="footnote" id="fnref-6-16"><a href="#fn-6-16" rel="footnote">17</a></sup> 为此，我们要使用回调函数（callback），在 Active Record 对象生命周期的特定时刻调用（参阅 Rails API 中关于回调函数的文档）。本例中，我们要使用的回调函数是 <code>before_save</code>，在用户存入数据库之前强行把 Email 地址转换成全小写字母形式，如代码 6.20 所示。</p>

<div class="codeblock has-caption" id="codeblock-6-20"><p class="caption"><span>代码 6.20：</span>把 Email 地址转换成全小写形式，确保唯一性</p><p class="file"><code>app/models/user.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Base</span>
  <span class="n">before_save</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="n">email</span><span class="o">.</span><span class="n">downcase</span> <span class="p">}</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div>
<p>在代码 6.20 中，<code>before_save</code> 后跟有一个块，块中的代码调用了字符串的 <code>downcase</code> 方法，把用户的 Email 地址转换成小写字母形式。这些代码有些深度，此时你只需相信这些代码可以达到目的就行了。如果你有所怀疑，可以把代码 6.16 中的唯一性验证代码注释掉，创建几个 Email 地址一样的用户，看一下存储时得到的错误信息。（<a href="chapter8.html#section-8-2-1">8.2.1 节</a> 还会用到这个技巧，到时会使用推荐的“方法引用”约定。）编写针对代码 6.20 的测试会留作练习，参见 <a href="chapter6.html#section-6-5">6.5 节</a>。</p>

<p>至此，上面 Alice 遇到的问题就解决了，数据库会存储请求 1 创建的用户，不会存储请求 2 创建的用户，因为它违反了唯一性限制。（在 Rails 的日志中会显示一个错误，不过无大碍。其实我们可以捕获抛出的 <code>ActiveRecord::StatementInvalid</code> 异常，不过本教程不会涉及异常处理。）为 <code>email</code> 列建立索引同时也解决了 <a href="chapter6.html#section-6-1-4">6.1.4 节</a>中提到的 <code>find_by_email</code> 的效率问题（参阅<a href="chapter6.html#aside-6-2">旁注 6.2</a>）。</p>

          <div class="aside box" id="aside-6-2">
  <h4><span>旁注 6.2：</span>数据库索引</h4>

  <p>创建数据库列时，要考虑是否会用这个列进行查询。例如，代码 6.2 中的迁移，创建了 <code>email</code> 列，<a href="chapter7.html">第 7 章</a>中实现的用户登录功能，会通过提交的 Email 地址查询对应的用户记录。按照现有的数据模型，使用 Email 地址查找用户的唯一方式是遍历数据库中所有的用户记录，对比提交的 Email 地址和记录中的 <code>email</code> 列，看看是否一致。在数据库的术语中，这叫做“全表扫描（full-table scan）”，对一个有上千用户的网站而言，这可不是一件轻松的事。</p>

  <p>为 <code>email</code> 列建立索引则可以解决这个问题。我们可以将数据库索引比拟成书籍的索引。如果要在一本书中找出某个字符串（例如 <code>"foobar"</code>）出现的所有位置，我们需要翻看书中的每一页。但是如果有索引的话，只需在索引中找到 <code>"foobar"</code> 条目，就能看到所有包含 <code>"foobar"</code> 的页码。数据库索引基本上也是这种原理。</p>
</div>


<h2 id='section-6-3'><span>6.3</span> 加上安全密码</h2>


<p>本节我们要加入用户所需的最后一个常规属性：安全密码，用来验证用户的身份。实现的方式是，用户记着自己的密码，而在数据库中存储着加密后的密码。稍后我们还会加入基于密码的用户身份验证机制，<a href="chapter8.html">第 8 章</a>会利用这个机制实现用户登录功能。</p>

<p>验证用户身份的方法是，获取用户提交的密码，进行加密，再和数据库中存储的加密密码对比，如果二者一致，用户提交的就是正确的密码，用户的身份也就验证了。我们要对比的是加密后的密码，而不是原始的密码文本，所以验证用户身份时不用在数据库中存储用户的密码，这样可以规避一个很大的安全隐患。</p>

<p>安全密码机制基本上是由 Rails 中一个单独的方法 <code>has_secure_password</code> 实现的（自 Rails 3.1 开始使用）。因为后续的内容都是基于这个方法的，所以很难循序渐进的讲解。从 <a href="chapter6.html#section-6-3-2">6.3.2 节</a>开始，我建议尽早的加入 <code>has_secure_password</code> 方法，然后每编写一个测试就注释掉这个方法，这样才能正确的使用 TDD。（视频往往能更好的表现一个循序渐进的开发过程，所以为了能更好的理解这一块，有兴趣的读者可以考虑观看<a href="http://railstutorial.org/screencasts">本教程的配套视频</a>。）</p>

<h3 id='section-6-3-1'><span>6.3.1</span> 加密密码</h3>


<p>我们先要对 User 数据结构做些改动，向 <code>users</code> 表中加入 <code>password_digest</code> 列（如图 6.5 所示）。digest 这个词是加密哈希函数中的一个术语。之所以要使用 <code>password_digest</code> 命名这个列，是因为 <a href="chapter6.html#section-6-3-4">6.3.4 节</a>实现的功能会用到这个列。适当的加密后，即便攻击者设法获取了数据库拷贝也无法黑掉网站。</p>

<div class="figure" id="figure-6-5">
  <img src="figures/user_model_password_digest.png" alt="user model password digest" /><p class="caption"><span>图 6.5：</span>加入 <code>password_digest</code> 属性后的 User 模型</p>
</div>
<p>我们要使用目前最先进的哈希函数 bcrypt 对密码进行不可逆的加密，得到密码的哈希值。如果要在程序中使用 bcrypt，需要把 <code>bcrypt-ruby</code> 这个 gem 加入 <code>Gemfile</code>，如代码 6.21 所示。</p>

<div class="codeblock has-caption" id="codeblock-6-21"><p class="caption"><span>代码 6.21：</span>把 bcrypt-ruby 加入 <code>Gemfile</code></p><div class="highlight type-ruby"><pre><span class="n">source</span> <span class="s1">'https://rubygems.org'</span>
<span class="n">ruby</span> <span class="s1">'2.0.0'</span>

<span class="n">gem</span> <span class="s1">'rails'</span><span class="p">,</span> <span class="s1">'4.0.0'</span>
<span class="n">gem</span> <span class="s1">'bootstrap-sass'</span><span class="p">,</span> <span class="s1">'2.3.2.0'</span>
<span class="n">gem</span> <span class="s1">'bcrypt-ruby'</span><span class="p">,</span> <span class="s1">'3.0.1'</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="o">.</span>
</pre></div>
</div>
<p>然后运行 <code>bundle install</code> 安装：</p>

<div class="codeblock"><div class="highlight type-sh"><pre><span class="nv">$ </span>bundle install
</pre></div>
</div>
<p>既然我们规划的 <code>users</code> 表中有一列是 <code>password_digest</code>，那么用户对象就应该可以响应 <code>password_digest</code> 方法，按照这个思路我们就可以编写出如代码 6.22 所示的测试。</p>

<div class="codeblock has-caption" id="codeblock-6-22"><p class="caption"><span>代码 6.22：</span>确保 <code>users</code> 表中有 <code>password_digest</code> 列</p><p class="file"><code>spec/models/user_spec.rb</code></p><div class="highlight type-ruby"><pre><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span> <span class="k">do</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">"Example User"</span><span class="p">,</span> <span class="ss">email</span><span class="p">:</span> <span class="s2">"user@example.com"</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">subject</span> <span class="p">{</span> <span class="vi">@user</span> <span class="p">}</span>

  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:email</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:password_digest</span><span class="p">)</span> <span class="p">}</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div>
<p>为了让测试通过，首先要生成一个合适的迁移文件，添加 <code>password_digest</code> 列：</p>

<div class="codeblock"><div class="highlight type-sh"><pre><span class="nv">$ </span>rails generate migration add_password_digest_to_users password_digest:string
</pre></div>
</div>
<p>上述命令的第一个参数是迁移的名字，第二个参数指明要添加列的名字和数据类型。（可以和代码 6.1 中生成 <code>users</code> 表的代码对比一下。）迁移的名字可以随便起，但一般会以 <code>_to_users</code> 结尾，Rails 会自动生成一个向 <code>users</code> 表中增加列的迁移。我们还提供了第二个参数，Rails 就得到了足够的信息，会为我们生成整个迁移文件，如代码 6.23 所示。</p>

<div class="codeblock has-caption" id="codeblock-6-23"><p class="caption"><span>代码 6.23：</span>向 <code>users</code> 表中添加 <code>password_digest</code> 列的迁移</p><p class="file"><code>db/migrate/[ts]_add_password_digest_to_users.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">AddPasswordDigestToUsers</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">add_column</span> <span class="ss">:users</span><span class="p">,</span> <span class="ss">:password_digest</span><span class="p">,</span> <span class="ss">:string</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>上述代码中调用 <code>add_column</code> 方法向 <code>users</code> 表添加 <code>password_digest</code> 列。</p>

<p>在开发数据库中执行迁移操作，再准备好测试数据库，代码 6.22 中的测试就可以通过了：</p>

<div class="codeblock"><div class="highlight type-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake db:migrate
<span class="nv">$ </span>bundle <span class="nb">exec </span>rake <span class="nb">test</span>:prepare
<span class="nv">$ </span>bundle <span class="nb">exec </span>rspec spec/
</pre></div>
</div>
<h3 id='section-6-3-2'><span>6.3.2</span> 密码和密码确认</h3>


<p>如图 6.1 中的构思图所示，我们希望用户进行密码确认，这在网络中是很普遍的做法，可以减小误输入带来的风险。虽然在控制器层可以实现这个想法，不过在模型层实现更好，Active Record 可以确保密码确认万无一失。为此，我们要把 <code>password</code> 和 <code>password_confirmation</code> 两列加入 User 模型，在记录存入数据库之前比较这两列的值是否一样。和之前见过的属性不一样，<code>password</code> 是虚拟的属性，只是临时存在于内存中，而不会存入数据库中。</p>

<p>我们先编写检查是否可以响应 <code>password</code> 和 <code>password_confirmation</code> 方法的测试，如代码 6.24 所示。</p>

<div class="codeblock has-caption" id="codeblock-6-24"><p class="caption"><span>代码 6.24：</span>测试 <code>password</code> 和 <code>password_confirmation</code> 属性</p><p class="file"><code>spec/models/user_spec.rb</code></p><div class="highlight type-ruby"><pre><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span> <span class="k">do</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">"Example User"</span><span class="p">,</span>
                     <span class="ss">email</span><span class="p">:</span> <span class="s2">"user@example.com"</span><span class="p">,</span>
                     <span class="ss">password</span><span class="p">:</span> <span class="s2">"foobar"</span><span class="p">,</span>
                     <span class="n">password_confirmation</span><span class="p">:</span> <span class="s2">"foobar"</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">subject</span> <span class="p">{</span> <span class="vi">@user</span> <span class="p">}</span>

  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:email</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:password_digest</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:password</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:password_confirmation</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">be_valid</span> <span class="p">}</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div>
<p>注意，我们在 <code>User.new</code> 的初始化参数 Hash 中加入了 <code>password</code> 和 <code>password_confirmation</code>：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">before</span> <span class="k">do</span>
  <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">"Example User"</span><span class="p">,</span>
                   <span class="ss">email</span><span class="p">:</span> <span class="s2">"user@example.com"</span><span class="p">,</span>
                   <span class="ss">password</span><span class="p">:</span> <span class="s2">"foobar"</span><span class="p">,</span>
                   <span class="n">password_confirmation</span><span class="p">:</span> <span class="s2">"foobar"</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>我们当然不想让用户输入空白的密码，那么再编写一个验证密码存在性的测试：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">describe</span> <span class="s2">"when password is not present"</span> <span class="k">do</span>
  <span class="n">before</span> <span class="k">do</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">"Example User"</span><span class="p">,</span> <span class="ss">email</span><span class="p">:</span> <span class="s2">"user@example.com"</span><span class="p">,</span>
                     <span class="ss">password</span><span class="p">:</span> <span class="s2">" "</span><span class="p">,</span> <span class="n">password_confirmation</span><span class="p">:</span> <span class="s2">" "</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_valid</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div>
<p>因为稍后会测试密码不一致的情形，所以存在性验证就把密码和密码确认两项都设为了空格字符串。</p>

<p>我们还要确保密码和密码确认的值是相同的，这种情况 <code>it { should be_valid }</code> 已经覆盖了。那么再编写针对二者不同时的测试就可以了：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">describe</span> <span class="s2">"when password doesn't match confirmation"</span> <span class="k">do</span>
  <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">password_confirmation</span> <span class="o">=</span> <span class="s2">"mismatch"</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_valid</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div>
<p>把上述代码放在一起，就是代码 6.25 中的（失败）测试了。</p>

<div class="codeblock has-caption" id="codeblock-6-25"><p class="caption"><span>代码 6.25：</span>对 <code>password</code> 和 <code>password_confirmation</code> 的测试</p><p class="file"><code>spec/models/user_spec.rb</code></p><div class="highlight type-ruby"><pre><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span> <span class="k">do</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">"Example User"</span><span class="p">,</span> <span class="ss">email</span><span class="p">:</span> <span class="s2">"user@example.com"</span><span class="p">,</span>
                     <span class="ss">password</span><span class="p">:</span> <span class="s2">"foobar"</span><span class="p">,</span> <span class="n">password_confirmation</span><span class="p">:</span> <span class="s2">"foobar"</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">subject</span> <span class="p">{</span> <span class="vi">@user</span> <span class="p">}</span>

  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:email</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:password_digest</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:password</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:password_confirmation</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">be_valid</span> <span class="p">}</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">describe</span> <span class="s2">"when password is not present"</span> <span class="k">do</span>
    <span class="n">before</span> <span class="k">do</span>
      <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">"Example User"</span><span class="p">,</span> <span class="ss">email</span><span class="p">:</span> <span class="s2">"user@example.com"</span><span class="p">,</span>
                       <span class="ss">password</span><span class="p">:</span> <span class="s2">" "</span><span class="p">,</span> <span class="n">password_confirmation</span><span class="p">:</span> <span class="s2">" "</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_valid</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="n">describe</span> <span class="s2">"when password doesn't match confirmation"</span> <span class="k">do</span>
    <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">password_confirmation</span> <span class="o">=</span> <span class="s2">"mismatch"</span> <span class="p">}</span>
    <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_valid</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>我们只需添加一行代码就可以让代码 6.25 中的测试通过，如代码 6.26 所示。</p>

<div class="codeblock has-caption" id="codeblock-6-26"><p class="caption"><span>代码 6.26：</span>让密码测试通过</p><p class="file"><code>app/models/user.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Base</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">has_secure_password</span>
<span class="k">end</span>
</pre></div>
</div>
<p><code>has_secure_password</code> 这一行代码是很强大的，可以让所有针对密码的测试都通过，而且作用还不知如此。但是，这行代码的作用太过强大，甚至后面的测试未遇红就变绿了，所以在继续之前，我建议把这行注释掉（如代码 6.27 所示）。</p>

<div class="codeblock has-caption" id="codeblock-6-27"><p class="caption"><span>代码 6.27：</span>为了践行 TDD，注释掉 <code>has_secure_password</code></p><p class="file"><code>app/models/user.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Base</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="c1"># has_secure_password</span>
<span class="k">end</span>
</pre></div>
</div>
<h3 id='section-6-3-3'><span>6.3.3</span> 用户身份验证</h3>


<p>实现密码机制的最后一步，是找到一种方法，使用 Email 地址和密码取回用户对象。这个方法很自然的可以分成两步，首先，通过 Email 地址找到用户记录；然后再用密码进行身份验证。除了最后一个测试，本节所有测试都是通过 <code>has_secure_password</code> 实现的，所以为了让测试通过必须解除代码 6.27 中的注释行。</p>

<p>第一步很简单，如 <a href="chapter6.html#section-6-1-4">6.1.4 节</a>中介绍过的，我们可以调用 <code>find_by</code> 方法，通过 Email 地址查找用户记录：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="ss">email</span><span class="p">:</span> <span class="n">email</span><span class="p">)</span>
</pre></div>
</div>
<p>接下来的第二步，可以使用 <code>authenticate</code> 方法验证用户的密码。在<a href="chapter8.html">第 8 章</a>中会使用类似下面的代码获取当前登录的用户：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">current_user</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="n">password</span><span class="p">)</span>
</pre></div>
</div>
<p>如果提交的密码和用户的密码一致，上述代码就会返回一个用户对象，否则返回 <code>false</code>。</p>

<p>和之前一样，我们可以使用 RSpec 测试必须要定义有 authenticate 方法。这个测试比前面见过的要难一些，我们分段来看。如果你刚接触 RSpec，可能要多读几遍本节的内容。首先，用户对象应该能够响应 <code>authenticate</code> 方法：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:authenticate</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>然后测试密码是否正确：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">describe</span> <span class="s2">"return value of authenticate method"</span> <span class="k">do</span>
  <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">save</span> <span class="p">}</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:found_user</span><span class="p">)</span> <span class="p">{</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="ss">email</span><span class="p">:</span> <span class="vi">@user</span><span class="o">.</span><span class="n">email</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">describe</span> <span class="s2">"with valid password"</span> <span class="k">do</span>
    <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">eq</span> <span class="n">found_user</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="vi">@user</span><span class="o">.</span><span class="n">password</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="n">describe</span> <span class="s2">"with invalid password"</span> <span class="k">do</span>
    <span class="n">let</span><span class="p">(</span><span class="ss">:user_for_invalid_password</span><span class="p">)</span> <span class="p">{</span> <span class="n">found_user</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="s2">"invalid"</span><span class="p">)</span> <span class="p">}</span>

    <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">eq</span> <span class="n">user_for_invalid_password</span> <span class="p">}</span>
    <span class="n">specify</span> <span class="p">{</span> <span class="n">expect</span><span class="p">(</span><span class="n">user_for_invalid_password</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">be_false</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p><code>before</code> 块中的代码先把用户存入数据库，然后在 <code>let</code> 块中调用 <code>find_by</code> 方法取出用户：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">let</span><span class="p">(</span><span class="ss">:found_user</span><span class="p">)</span> <span class="p">{</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="ss">email</span><span class="p">:</span> <span class="vi">@user</span><span class="o">.</span><span class="n">email</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>在前几章的练习题中用过很多次 <code>let</code> 了，但这是第一次在正文中出现。<a href="chapter6.html#aside-6-3">旁注 6.3</a>较为深入的介绍了 <code>let</code> 方法。接下来的两个 <code>describe</code> 块测试了 <code>@user</code> 和 <code>found_user</code> 是否为同一个用户。测试代码中使用 <code>eq</code> 测试对象是否相同（会调用 <code>==</code> 测试是否相同，参见 <a href="chapter4.html#section-4-3-1">4.3.1 节</a>）。注意，下面的测试中</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">describe</span> <span class="s2">"with invalid password"</span> <span class="k">do</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:user_for_invalid_password</span><span class="p">)</span> <span class="p">{</span> <span class="n">found_user</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="s2">"invalid"</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">eq</span> <span class="n">user_for_invalid_password</span> <span class="p">}</span>
  <span class="n">specify</span> <span class="p">{</span> <span class="n">expect</span><span class="p">(</span><span class="n">user_for_invalid_password</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">be_false</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div>
<p>再次用到了 <code>let</code> 方法，还用到了 <code>specify</code> 方法。<code>specify</code> 是 <code>it</code> 方法的别名，如果你觉得某个地方用 <code>it</code> 读起来怪怪的，就可以换用 <code>specify</code>。本例中，“it should not equal wrong user”读起来很顺，不过“user: user with invalid password should be false”有点累赘，换用“specify: user with invalid password should be false”感觉就好些。</p>

          <div class="aside box" id="aside-6-3">
  <h4><span>旁注 6.3：</span><code>let</code> 方法</h4>

  <p>我们可以使用 RSpec 提供的 <code>let</code> 方法便捷的在测试中定义局部变量。<code>let</code> 方法的句法看起来有点怪，不过和变量赋值语句的作用是一样的。<code>let</code> 方法的参数是一个 Symbol，后面可以跟着一个块，块中代码的返回值会赋给名为 Symbol 代表的局部变量。也就是说：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">let</span><span class="p">(</span><span class="ss">:found_user</span><span class="p">)</span> <span class="p">{</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="ss">email</span><span class="p">:</span> <span class="vi">@user</span><span class="o">.</span><span class="n">email</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
  <p>定义了一个名为 <code>found_user</code> 的变量，其值等于 <code>find_by</code> 的返回值。在这个测试用例的任何一个 <code>before</code> 或 <code>it</code> 块中都可以使用这个变量。使用 <code>let</code> 方法定义变量的一个好处是，它可以记住（memoize）变量的值。（memoize 是个行业术语，不是“memorize”的误拼写。）对上面的代码而言，因为 <code>let</code> 的备忘功能，<code>found_user</code> 的值会被记住，因此不管调用多少次 User 模型测试，<code>find_by</code> 方法只会运行一次。</p>
</div>


<p>最后，安全起见，我们还要编写一个密码长度测试，大于 6 个字符才能通过：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">describe</span> <span class="s2">"with a password that's too short"</span> <span class="k">do</span>
  <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">password</span> <span class="o">=</span> <span class="vi">@user</span><span class="o">.</span><span class="n">password_confirmation</span> <span class="o">=</span> <span class="s2">"a"</span> <span class="o">*</span> <span class="mi">5</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">be_invalid</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div>
<p>把上面的代码放在一起后，如代码 6.28 所示。</p>

<div class="codeblock has-caption" id="codeblock-6-28"><p class="caption"><span>代码 6.28：</span>对 <code>authenticate</code> 方法的测试</p><p class="file"><code>spec/models/user_spec.rb</code></p><div class="highlight type-ruby"><pre><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span> <span class="k">do</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">"Example User"</span><span class="p">,</span> <span class="ss">email</span><span class="p">:</span> <span class="s2">"user@example.com"</span><span class="p">,</span>
                     <span class="ss">password</span><span class="p">:</span> <span class="s2">"foobar"</span><span class="p">,</span> <span class="n">password_confirmation</span><span class="p">:</span> <span class="s2">"foobar"</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">subject</span> <span class="p">{</span> <span class="vi">@user</span> <span class="p">}</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:authenticate</span><span class="p">)</span> <span class="p">}</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">describe</span> <span class="s2">"with a password that's too short"</span> <span class="k">do</span>
    <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">password</span> <span class="o">=</span> <span class="vi">@user</span><span class="o">.</span><span class="n">password_confirmation</span> <span class="o">=</span> <span class="s2">"a"</span> <span class="o">*</span> <span class="mi">5</span> <span class="p">}</span>
    <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">be_invalid</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="n">describe</span> <span class="s2">"return value of authenticate method"</span> <span class="k">do</span>
    <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">save</span> <span class="p">}</span>
    <span class="n">let</span><span class="p">(</span><span class="ss">:found_user</span><span class="p">)</span> <span class="p">{</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="ss">email</span><span class="p">:</span> <span class="vi">@user</span><span class="o">.</span><span class="n">email</span><span class="p">)</span> <span class="p">}</span>

    <span class="n">describe</span> <span class="s2">"with valid password"</span> <span class="k">do</span>
      <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">eq</span> <span class="n">found_user</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="vi">@user</span><span class="o">.</span><span class="n">password</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">end</span>

    <span class="n">describe</span> <span class="s2">"with invalid password"</span> <span class="k">do</span>
      <span class="n">let</span><span class="p">(</span><span class="ss">:user_for_invalid_password</span><span class="p">)</span> <span class="p">{</span> <span class="n">found_user</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="s2">"invalid"</span><span class="p">)</span> <span class="p">}</span>

      <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">eq</span> <span class="n">user_for_invalid_password</span> <span class="p">}</span>
      <span class="n">specify</span> <span class="p">{</span> <span class="n">expect</span><span class="p">(</span><span class="n">user_for_invalid_password</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">be_false</span> <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>如<a href="chapter6.html#aside-6-3">旁注 6.3</a>中介绍的，<code>let</code> 方法会记住变量的值，所以嵌套中的第一个 <code>describe</code> 块通过 <code>let</code> 方法把 <code>find_by</code> 的结果赋值给 <code>found_user</code> 之后，在后续的 <code>describe</code> 块中就无需再次查询数据库了。</p>

<h3 id='section-6-3-4'><span>6.3.4</span> 用户的安全密码</h3>


<p>在较旧版本的 Rails 中，添加一个安全的密码是很麻烦也很费时的事，本书的第一版（针对 Rails 3.0）中就从零起开发了一个用户身份验证系统。熟知用户身份验证系统的开发者完全没必要在此浪费时间，所以在 Rails 的最新版中已经集成了用户身份验证功能。因此，我们只需要几行代码就可以为用户添加一个安全的密码，还可以让前几小节的测试通过。</p>

<p>首先，我们要为密码添加一个长度验证，使用和代码 6.12 中用过的 <code>:maximum</code> 类似的 <code>:minimum</code>：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">validates</span> <span class="ss">:password</span><span class="p">,</span> <span class="ss">length</span><span class="p">:</span> <span class="p">{</span> <span class="ss">minimum</span><span class="p">:</span> <span class="mi">6</span> <span class="p">}</span>
</pre></div>
</div>
<p>（密码和密码确认的存在性验证都在 <code>has_secure_password</code> 方法中实现了。）</p>

<p>然后，我们要添加 <code>password</code> 和 <code>password_confirmation</code> 属性，二者都要填写一些内容（非空格），而且要相等；还要定义 <code>authenticate</code> 方法，对比加密后的密码和 <code>password_digest</code> 是否一致，验证用户的身份。这些步骤本来很麻烦，不过在最新版的 Rails 中已经集成好了，只需调用一个方法就可以了，这个方法是 <code>has_secure_password</code>：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">has_secure_password</span>
</pre></div>
</div>
<p>只要数据库中有 <code>password_digest</code> 列，在模型文件中加入 <code>has_secure_password</code> 方法后就能验证用户身份了。</p>

<p>（如果你觉得 <code>has_secure_password</code> 方法太过神奇，不妨阅读一下 <code>secure_password.rb</code> 文件中的代码，里面有很多注释，代码本身也不难理解。这段代码中有这么几行：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">validates_confirmation_of</span> <span class="ss">:password</span><span class="p">,</span>
                          <span class="k">if</span><span class="p">:</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">password</span><span class="o">.</span><span class="n">present?</span> <span class="p">}</span>
</pre></div>
</div>
<p>这行代码会自动创建 <code>password_confirmation</code> 属性（<a href="http://api.rubyonrails.org/v4.0.0/classes/ActiveModel/Validations/HelperMethods.html#method-i-validates_confirmation_of">Rails API</a> 中有说明）。这段代码还有针对 <code>password_digest</code> 属性的数据验证。）</p>

<p>把以上的代码放在一起就得到了如代码 6.29 所示的 User 模型，同时也实现了安全的密码机制。</p>

<div class="codeblock has-caption" id="codeblock-6-29"><p class="caption"><span>代码 6.29：</span>最终实现的安全的密码机制</p><p class="file"><code>app/models/user.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Base</span>
  <span class="n">before_save</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="n">email</span><span class="o">.</span><span class="n">downcase</span> <span class="p">}</span>
  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">length</span><span class="p">:</span> <span class="p">{</span> <span class="ss">maximum</span><span class="p">:</span> <span class="mi">50</span> <span class="p">}</span>
  <span class="no">VALID_EMAIL_REGEX</span> <span class="o">=</span> <span class="sr">/\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">presence</span><span class="p">:</span>   <span class="kp">true</span><span class="p">,</span>
                    <span class="nb">format</span><span class="p">:</span>     <span class="p">{</span> <span class="ss">with</span><span class="p">:</span> <span class="no">VALID_EMAIL_REGEX</span> <span class="p">},</span>
                    <span class="ss">uniqueness</span><span class="p">:</span> <span class="p">{</span> <span class="n">case_sensitive</span><span class="p">:</span> <span class="kp">false</span> <span class="p">}</span>
  <span class="n">has_secure_password</span>
  <span class="n">validates</span> <span class="ss">:password</span><span class="p">,</span> <span class="ss">length</span><span class="p">:</span> <span class="p">{</span> <span class="ss">minimum</span><span class="p">:</span> <span class="mi">6</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div>
<p>现在你可以看一下测试是否可以通过了：</p>

<div class="codeblock"><div class="highlight type-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rspec spec/
</pre></div>
</div>
<h3 id='section-6-3-5'><span>6.3.5</span> 创建用户</h3>


<p>至此，基本的 User 模型已经架构好了，接下来我们要在数据库中存入一个用户记录，为 <a href="chapter7.html#section-7-1">7.1 节</a>开发的用户资料显示页面做准备，同时也可以看一下前几节所做工作的实际效果。测试通过并不意味着工作做完了，如果开发数据库中有一条用户记录的话，或许能给我们带来一点成就感。</p>

<p>因为现在还不能在网页中注册（<a href="chapter7.html">第 7 章</a>会实现），我们要在控制台中手动创建新用户。和 <a href="chapter6.html#section-6-1-3">6.1.3 节</a>不一样，本节使用的不是沙盒模式下的控制台，因为我们真的要在数据库中保存一条记录：</p>

<div class="codeblock"><div class="highlight type-sh"><pre><span class="nv">$ </span>rails console
&gt;&gt; User.create<span class="o">(</span>name: <span class="s2">"Michael Hartl"</span>, email: <span class="s2">"mhartl@example.com"</span>,
?&gt;             password: <span class="s2">"foobar"</span>, password_confirmation: <span class="s2">"foobar"</span><span class="o">)</span>
<span class="o">=</span>&gt; <span class="c">#&lt;User id: 1, name: "Michael Hartl", email: "mhartl@example.com", created_at: "2013-03-11 20:45:19", updated_at: "2013-03-11 20:45:19", password_digest: "$2a$10$kn4cQDJTzV76ZgDxOWk6Je9A0Ttn5sKNaGTEmT0jU7.n..."&gt;</span>
</pre></div>
</div>
<p>在 SQLite 数据库浏览器中打开开发数据库（<code>db/development.sqlite3</code>），会发现上述命令执行后存入的记录（如图 6.6），各列对应了图 6.5 中数据模型相应的属性。</p>

<div class="figure" id="figure-6-6">
  <img src="figures/sqlite_user_row_with_password_4_0.png" alt="sqlite user row with password 40" /><p class="caption"><span>图 6.6：</span>SQLite 数据库（<code>db/development.sqlite3</code>）中的一条记录</p>
</div>
<p>再回到控制台中，读取 <code>password_digest</code> 属性的值，看一下代码 6.29 中 <code>has_secure_password</code> 方法的作用：</p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; <span class="nv">user</span> <span class="o">=</span> User.find_by<span class="o">(</span>email: <span class="s2">"mhartl@example.com"</span><span class="o">)</span>
&gt;&gt; user.password_digest
<span class="o">=</span>&gt; <span class="s2">"$2a$10$kn4cQDJTzV76ZgDxOWk6Je9A0Ttn5sKNaGTEmT0jU7.ncBJ/60gHq"</span>
</pre></div>
</div>
<p>这是初始化用户时提供的原始密码（<code>"foobar"</code>）对应的加密形式。下面再来验证一下 <code>authenticate</code> 方法是否可以正常使用，先提供不正确的密码，再提供正确的密码，结果如下：</p>

<div class="codeblock"><div class="highlight type-sh"><pre>&gt;&gt; user.authenticate<span class="o">(</span><span class="s2">"invalid"</span><span class="o">)</span>
<span class="o">=</span>&gt; <span class="nb">false</span>
&gt;&gt; user.authenticate<span class="o">(</span><span class="s2">"foobar"</span><span class="o">)</span>
<span class="o">=</span>&gt; <span class="c">#&lt;User id: 1, name: "Michael Hartl", email: "mhartl@example.com", created_at: "2013-03-11 20:45:19", updated_at: "2013-03-11 20:45:19", password_digest: "$2a$10$kn4cQDJTzV76ZgDxOWk6Je9A0Ttn5sKNaGTEmT0jU7.n..."&gt;</span>
</pre></div>
</div>
<p>如代码 6.28 中的测试需求，如果密码不正确，<code>authenticate</code> 方法会返回 <code>false</code>；如果密码正确，则会返回对应的用户对象。</p>

<h2 id='section-6-4'><span>6.4</span> 小结</h2>


<p>本章从零开始，建立了一个运作良好的 User 模型，包含 <code>name</code>、<code>email</code> 以及几个密码相关的属性，通过数据验证对属性的取值做了限定。而且，已经可以使用密码对用户进行身份验证了。在较旧版本的 Rails 中，实现这些功能需要编写大量的代码，不过在最新版中，使用强大的 <code>validates</code> 和 <code>has_secure_password</code> 方法，只需几行代码就可以构建完整的 User 模型了。</p>

<p>在接下来的<a href="chapter7.html">第 7 章</a>中，我们会创建一个注册表单用来新建用户，还会创建一个页面用来显示用户的信息。<a href="chapter8.html">第 8 章</a>则会使用 <a href="chapter6.html#section-6-3">6.3 节</a>实现的身份验证机制让用户可以登录网站。</p>

<p>如果你使用 Git，而且一直都没做提交的话，现在最好提交一下本章所做的改动：</p>

<div class="codeblock"><div class="highlight type-sh"><pre><span class="nv">$ </span>git add .
<span class="nv">$ </span>git commit -m <span class="s2">"Make a basic User model (including secure passwords)"</span>
</pre></div>
</div>
<p>然后合并到主分支中：</p>

<div class="codeblock"><div class="highlight type-sh"><pre><span class="nv">$ </span>git checkout master
<span class="nv">$ </span>git merge modeling-users
</pre></div>
</div>
<h2 id='section-6-5'><span>6.5</span> 练习</h2>


<ol><li>
    <p>为代码 6.20 中把 Email 地址转换成小写字母形式的功能编写一个测试，测试代码可以参考代码 6.30。这段测试使用 <code>reload</code> 方法从数据库中重新加载数据；使用 <code>eq</code> 方法测试相等。把代码 6.20 中的 <code>before_save</code> 一行注释掉，看一下代码 6.30 的测试是否可以通过。</p>
  </li>
  <li>
    <p>把代码 6.20 中 <code>before_save</code> 一行改成代码 6.31 的形式，运行测试看一下这样改写是否可行。</p>
  </li>
  <li>
    <p>我们在 <a href="chapter6.html#section-6-2-4">6.2.4 节</a>中说过，代码 6.14 中的 Email 正则表达式能匹配出现连续点号的不合法 Email 地址，例如“foo@bar..com”。把这个地址添加到代码 6.13 中的不合法地址列表中让测试失败，然后使用代码 6.32 中较复杂的正则表达式让测试通过。</p>
  </li>
  <li>
    <p>通读 Rails API 中关于 <code>ActiveRecord::Base</code> 的内容，了解一下这个类的作用。</p>
  </li>
  <li>
    <p>细读 Rails API 中关于 <code>validates</code> 方法的内容，学习这个方法其他的用法和参数。</p>
  </li>
  <li>
    <p>花点时间熟悉一下 <a href="http://www.rubular.com/">Rubular</a>。</p>
  </li>
</ol><div class="codeblock has-caption" id="codeblock-6-30"><p class="caption"><span>代码 6.30：</span>对代码 6.20 中 Email 变小写的测试</p><p class="file"><code>spec/models/user_spec.rb</code></p><div class="highlight type-ruby"><pre><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">describe</span> <span class="s2">"email address with mixed case"</span> <span class="k">do</span>
    <span class="n">let</span><span class="p">(</span><span class="ss">:mixed_case_email</span><span class="p">)</span> <span class="p">{</span> <span class="s2">"Foo@ExAMPle.CoM"</span> <span class="p">}</span>

    <span class="n">it</span> <span class="s2">"should be saved as all lower-case"</span> <span class="k">do</span>
      <span class="vi">@user</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="n">mixed_case_email</span>
      <span class="vi">@user</span><span class="o">.</span><span class="n">save</span>
      <span class="n">expect</span><span class="p">(</span><span class="vi">@user</span><span class="o">.</span><span class="n">reload</span><span class="o">.</span><span class="n">email</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">eq</span> <span class="n">mixed_case_email</span><span class="o">.</span><span class="n">downcase</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div>
<div class="codeblock has-caption" id="codeblock-6-31"><p class="caption"><span>代码 6.31：</span><code>before_save</code> 回调函数的另一种写法</p><p class="file"><code>app/models/user.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Base</span>
  <span class="n">has_secure_password</span>
  <span class="n">before_save</span> <span class="p">{</span> <span class="n">email</span><span class="o">.</span><span class="n">downcase!</span> <span class="p">}</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div>
<div class="codeblock has-caption" id="codeblock-6-32"><p class="caption"><span>代码 6.32：</span>不允许 Email 地址中出现连续点号的正则表达式</p><p class="file"><code>app/models/user.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Base</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="no">VALID_EMAIL_REGEX</span> <span class="o">=</span> <span class="sr">/\A[\w+\-.]+@[a-z\d\-]+(\.[a-z]+)*\.[a-z]+\z/i</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="nb">format</span><span class="p">:</span> <span class="p">{</span> <span class="ss">with</span><span class="p">:</span> <span class="no">VALID_EMAIL_REGEX</span> <span class="p">},</span>
                    <span class="ss">uniqueness</span><span class="p">:</span> <span class="p">{</span> <span class="n">case_sensitive</span><span class="p">:</span> <span class="kp">false</span> <span class="p">}</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div>
<div class="footnotes">
  <ol><li id="fn-6-1">
      <p>Active Record 这个名字来自“Active Record 模式”，出自 Martin Fowler 的《<a href="http://book.douban.com/subject/4826290/">企业应用架构模式</a>》一书。<a href="#fnref-6-1" rel="reference">↩</a></p>
    </li>
    <li id="fn-6-2">
      <p>SQL 读作 ess-cue-ell，不过也经常读作 sequel。<a href="#fnref-6-2" rel="reference">↩</a></p>
    </li>
    <li id="fn-6-3">
      <p>把 Email 作为用户名，以后如果需要和用户联系就方便了。<a href="#fnref-6-3" rel="reference">↩</a></p>
    </li>
    <li id="fn-6-4">
      <p>不要管 <code>t</code> 对象是怎么实现的，作为抽象层的东西，我们无需过多关心它的具体实现。你只要相信它可以完成指定的工作就行了。<a href="#fnref-6-4" rel="reference">↩</a></p>
    </li>
    <li id="fn-6-5">
      <p>SQLite 读作 ess-cue-ell-ite，不过倒是经常使用错误的读音 sequel-ite。<a href="#fnref-6-5" rel="reference">↩</a></p>
    </li>
    <li id="fn-6-t1">
      <p>译者注：因为还没加入数据验证<a href="#fnref-6-t1" rel="reference">↩</a></p>
    </li>
    <li id="fn-6-6">
      <p>你可能对 <code>"2013-03-11 00:57:46"</code> 这个时间感到好奇，为什么作者半夜还在写书呢？其实不然，这个时间戳是<a href="http://zh.wikipedia.org/wiki/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6">标准协时</a>（Coordinated Universal Time, UTC），类似于<a href="http://zh.wikipedia.org/wiki/%E6%A0%BC%E6%9E%97%E5%B0%BC%E6%B2%BB%E5%B9%B3%E6%97%B6">格林尼治平时</a>（Greenwich Mean Time, GMT）。以下摘自<a href="http://www.nist.gov/pml/div688/utcnist.cfm#cut">美国国家标准技术研究所时间和频率司的 FQA 网页</a>。问：为什么标准协时的缩写是 UTC 而不是 CUT？答：标准协时是在 1970 年由国际电信联盟（ITU）的专家顾问团设计的，ITU 觉得应该使用一个通用的缩写形式避免混淆，因为各方无法达成共识，最终 ITU 没有采用英文缩写 CUT 或法文缩写 TUC ，而是折中选择了 UTC。<a href="#fnref-6-6" rel="reference">↩</a></p>
    </li>
    <li id="fn-6-7">
      <p>注意 <code>user.updated_at</code> 的值，上面说过了，这是 UTC 时间。<a href="#fnref-6-7" rel="reference">↩</a></p>
    </li>
    <li id="fn-6-8">
      <p>异常和异常处理是 Ruby 语言的高级功能，本书基本不会涉及这二者。不过异常是 Ruby 语言中很重要的一部分，建议你通过 <a href="chapter1.html#section-1-1">1.1.1 节</a>中推荐的书籍学习。<a href="#fnref-6-8" rel="reference">↩</a></p>
    </li>
    <li id="fn-6-9">
      <p>如果控制台中命令的输出没什么实际意义，我就会省略掉。例如 <code>User.new</code> 的输出。<a href="#fnref-6-9" rel="reference">↩</a></p>
    </li>
    <li id="fn-6-10">
      <p>注意，在<a href="chapter6.html#table-6-1">表格 6.1</a> 中，当我说到“字母”时，我的实际意思是指“小写字母”，因为后面的 <code>i</code> 已经指定了不区分大小写的模式，所以也没必要分的这么细了。<a href="#fnref-6-10" rel="reference">↩</a></p>
    </li>
    <li id="fn-6-11">
      <p>如果你和我一样觉得 Rubular 很有用，我建议你向作者 <a href="http://lovitt.net/">Michael Lovitt</a> 适当的<a href="http://dwz.cn/donate-to-rubular">捐献一些钱</a>，以感谢他的辛勤劳动。<a href="#fnref-6-11" rel="reference">↩</a></p>
    </li>
    <li id="fn-6-12">
      <p>你知道吗，根据 Email 标准，<code>"Michael Hartl"@example.com</code> 虽有引号和空格，但也是合法的 Email 地址，很不可思议吧。<a href="#fnref-6-12" rel="reference">↩</a></p>
    </li>
    <li id="fn-6-13">
      <p>如本节介绍中所说的，这里就要用到测试数据库 <code>db/test.sqlite3</code> 了。<a href="#fnref-6-13" rel="reference">↩</a></p>
    </li>
    <li id="fn-6-14">
      <p>严格的说，Email 地址只有域名部分是不区分大小写的，<code>foo@bar.com</code> 和 <code>Foo@bar.com</code> 其实是不同的地址。但在实际使用中，千万别依赖这个规则，<a href="http://email.about.com/od/emailbehindthescenes/f/email_case_sens.htm">about.com</a> 中相关的文章说道，“区分大小写的 Email 地址会带来很多麻烦，不易互换使用，也不利传播，所以要求输入正确地大小写是很愚蠢的。几乎没有 Email 服务提供商或 ISP 强制要求使用区分大小写的 Email 地址，也不会提示收件人的大小写错了（例如，要全部大写）。”感谢读者 Riley Moses 指正这个问题。<a href="#fnref-6-14" rel="reference">↩</a></p>
    </li>
    <li id="fn-6-15">
      <p>当然，我们可以直接编辑代码 6.2，不过，需要先回滚再迁移回来。这不是 Rails 的风格，正确的做法是每次修改数据库结构都要使用迁移。<a href="#fnref-6-15" rel="reference">↩</a></p>
    </li>
    <li id="fn-6-16">
      <p>我在本地的 SQLite 以及 Heroku 的 PostgreSQL 中做过实验，证明这么做其实是必须的。<a href="#fnref-6-16" rel="reference">↩</a></p>
    </li>
  </ol></div>
  	</div>
</div>

			
				
				<div class="navigation">
					
						<a class="prev_page" href="/chapter5.html">&laquo; 第 5 章完善布局</a>
					
					
						<a class="next_page" href="/chapter7.html">第 7 章用户注册 &raquo;</a>
					
				</div>
				
			
		</div>
		<div class="footer">
        	<p>&copy;2013 <a href="http://about.ac" title="Andor Chen 的个人网站">Andor Chen</a> 保留部分权力。在线阅读版本基于<a href="http://creativecommons.org/licenses/by-sa/3.0/" title="Creative Commons Attribution-ShareAlike 3.0 Unported License" target="_blank">“CC 3.0 BY-SA 协议”</a>发布</p>
		</div>
	</div>
</body>
</html>
