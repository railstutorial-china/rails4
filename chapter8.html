<!doctype html>
<html lang="zh_CN">
<head>
	<meta charset="utf-8" />
	<title>第 8 章 登录和退出</title>
    <meta name="author" content="Andor Chen" />
    <link rel="stylesheet" href="/assets/styles/style.css" />
    <script type="text/javascript" src="http://cdn.staticfile.org/jquery/1.8.2/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/global.js"></script>
</head>

<body>
	<div class="wrapper">
		<div class="header">
            <h1 class="logo"><a class="ir" href="http://railstutorial-china.org">Ruby on Rails 教程</a></h1>
            <p class="subtitle">Ruby on Rails Tutorial 原书第 2 版（涵盖 Rails 4）</p>
        </div>
        <div class="content">
			
<div class="item chapter">
	<h1 id="chapter-8"><span>第 8 章</span> 登录和退出</h1>
	<ol class="toc">          <li class="level-2">
            <a href="#section-8-1">8.1 session 和登录失败</a>
          </li>
          <li class="level-3">
            <a href="#section-8-1-1">8.1.1 Sessions 控制器</a>
          </li>
          <li class="level-3">
            <a href="#section-8-1-2">8.1.2 测试登录功能</a>
          </li>
          <li class="level-3">
            <a href="#section-8-1-3">8.1.3 登录表单</a>
          </li>
          <li class="level-3">
            <a href="#section-8-1-4">8.1.4 分析表单提交</a>
          </li>
          <li class="level-3">
            <a href="#section-8-1-5">8.1.5 显示 Flash 消息</a>
          </li>
          <li class="level-2">
            <a href="#section-8-2">8.2 登录成功</a>
          </li>
          <li class="level-3">
            <a href="#section-8-2-1">8.2.1 “记住我”</a>
          </li>
          <li class="level-3">
            <a href="#section-8-2-2">8.2.2 定义 sign_in 方法</a>
          </li>
          <li class="level-3">
            <a href="#section-8-2-3">8.2.3 获取当前用户</a>
          </li>
          <li class="level-3">
            <a href="#section-8-2-4">8.2.4 改变导航链接</a>
          </li>
          <li class="level-3">
            <a href="#section-8-2-5">8.2.5 注册后直接登录</a>
          </li>
          <li class="level-3">
            <a href="#section-8-2-6">8.2.6 退出</a>
          </li>
          <li class="level-2">
            <a href="#section-8-3">8.3 Cucumber 简介（选读）</a>
          </li>
          <li class="level-3">
            <a href="#section-8-3-1">8.3.1 安装和设置</a>
          </li>
          <li class="level-3">
            <a href="#section-8-3-2">8.3.2 功能和步骤定义</a>
          </li>
          <li class="level-3">
            <a href="#section-8-3-3">8.3.3 小技巧：自定义 RSpec 匹配器</a>
          </li>
          <li class="level-2">
            <a href="#section-8-4">8.4 小结</a>
          </li>
          <li class="level-2">
            <a href="#section-8-5">8.5 练习</a>
          </li>
</ol>
  	<div class="main">
  		<p><a href="chapter7.html">第 7 章</a>已经实现了注册新用户的功能，本章我们要为已注册的用户提供登录和退出功能。实现登录功能之后，就可以根据登录状态和当前用户的身份定制网站的内容了。例如，本章我们会更新网站的头部，显示“登录”或“退出”链接，以及到个人资料页面的链接；在第 10 章中，会根据当前登录用户的 id 创建关联到这个用户的微博；在第 11 章，我们会实现当前登录用户关注其他用户的功能，实现之后，在首页就可以显示被关注用户发表的微博了。</p>

<p>实现登录功能之后，还可以实现一种安全机制，即根据用户的身份限制可以访问的页面，例如，在<a href="chapter9.html">第 9 章</a>中会介绍如何实现只有登入的用户才能访问编辑用户资料的页面。登录系统还可以赋予管理员级别的用户特别的权限，例如删除用户（也会在<a href="chapter9.html">第 9 章</a>中实现）等。</p>

<p>实现验证系统的核心功能之后，我们会简要的介绍一下 Cucumber 这个流行的行为驱动开发（Behavior-driven Development, BDD）系统，使用 Cucumber 重新实现之前的一些 RSpec 集成测试，看一下这两种方式有何不同。</p>

<p>和之前的章节一样，我们会在一个新的从分支中工作，本章结束后再将其合并到主分支中：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>git checkout -b sign-in-out
</pre></div>
</div>
<h2 id='section-8-1'><span>8.1</span> session 和登录失败</h2>


<p><a href="http://en.wikipedia.org/wiki/Session_(computer_science\)">session</a> 是两台电脑（例如运行有网页浏览器的客户端电脑和运行 Rails 的服务器）之间的半永久性连接，我们就是利用它来实现“登录”这一功能的。网络中常见的 session 处理方式有好几种：可以在用户关闭浏览器后清除 session；也可以提供一个“记住我”单选框让用户选择永远保存，直到用户退出后 session 才会失效。<sup class="footnote" id="fnref-8-1"><a href="#fn-8-1" rel="footnote">1</a></sup> 在示例程序中我们选择使用第二种处理方式，即用户登录后，会永久的记住登录状态，直到用户点击“退出”链接之后才清除 session。（在 <a href="chapter8.html#section-8-2-1">8.2.1 节</a>中会介绍“永久”到底有多久。）</p>

<p>很显然，我们可以把 session 视作一个符合 REST 架构的资源，在登录页面中准备一个新的 session，登录后创建这个 session，退出则会销毁 session。不过 session 和 Users 资源有所不同，Users 资源使用数据库（通过 User 模型）持久的存储数据，而 Sessions 资源是利用 <a href="http://en.wikipedia.org/wiki/HTTP_cookie">cookie</a> 来存储数据的。cookie 是存储在浏览器中的简单文本。实现登录功能基本上就是在实现基于 cookie 的验证机制。在本节及接下来的一节中，我们会构建 Sessions 控制器，创建登录表单，还会实现控制器中相关的动作。在 <a href="chapter8.html#section-8-2">8.2 节</a>中会加入处理 cookie 所需的代码。</p>

<h3 id='section-8-1-1'><span>8.1.1</span> Sessions 控制器</h3>


<p>登录和退出功能其实是由 Sessions 控制器中相应的动作处理的，登录表单在 <code>new</code> 动作中处理（本节的内容），登录的过程就是向 <code>create</code> 动作发送 <code>POST</code> 请求（<a href="chapter8.html#section-8-1">8.1 节</a>和 <a href="chapter8.html#section-8-2">8.2 节</a>），退出则是向 <code>destroy</code> 动作发送 <code>DELETE</code> 请求（<a href="chapter8.html#section-8-2-6">8.2.6 节</a>）。（HTTP 请求和 REST 动作之间的对应关系可以查看<a href="chapter7.html#table-7-1">表格 7.1</a>。）首先，我们要生成 Sessions 控制器，以及验证系统所需的集成测试：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>rails generate controller Sessions --no-test-framework
<span class="gp">$ </span>rails generate integration_test authentication_pages
</pre></div>
</div>
<p>参照 <a href="chapter7.html#section-7-2">7.2 节</a>中的“注册”页面，我们要创建一个登录表单，用来生成新的 session。注册表单的构思图如图 8.1 所示。</p>

<p>“登录”页面的地址由 <code>signin_path</code>（稍后定义）获取，和之前一样，我们要先编写相应的测试，如代码 8.1 所示。（可以和代码 7.6 中对“注册”页面的测试比较一下。）</p>

<div class="figure" id="figure-8-1">
  <img src="figures/signin_mockup_bootstrap.png" alt="signin mockup bootstrap" />
  <p class="caption"><span>图 8.1：</span>注册表单的构思图</p>
</div>
<div class="codeblock has-caption" id="codeblock-8-1"><p class="caption"><span>代码 8.1：</span>对 <code>new</code> 动作和对应视图的测试</p><p class="file"><code>spec/requests/authentication_pages_spec.rb</code></p><div class="highlight type-ruby"><pre><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="s2">"Authentication"</span> <span class="k">do</span>

  <span class="n">subject</span> <span class="p">{</span> <span class="n">page</span> <span class="p">}</span>

  <span class="n">describe</span> <span class="s2">"signin page"</span> <span class="k">do</span>
    <span class="n">before</span> <span class="p">{</span> <span class="n">visit</span> <span class="n">signin_path</span> <span class="p">}</span>

    <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">have_content</span><span class="p">(</span><span class="s1">'Sign in'</span><span class="p">)</span> <span class="p">}</span>
    <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">have_title</span><span class="p">(</span><span class="s1">'Sign in'</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>现在测试是失败的：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>bundle <span class="nb">exec </span>rspec spec/
</pre></div>
</div>
<p>要让代码 8.1 中的测试通过，首先，我们要为 Sessions 资源设置路由，还要修改“登录”页面具名路由的名称，将其映射到 Sessions 控制器的 <code>new</code> 动作上。和 Users 资源一样，我们可以使用 <code>resources</code> 方法设置标准的 REST 动作：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">resources</span> <span class="p">:</span><span class="n">sessions</span><span class="p">,</span> <span class="ss">only: </span><span class="p">[</span><span class="ss">:new</span><span class="p">,</span> <span class="ss">:create</span><span class="p">,</span> <span class="ss">:destroy</span><span class="p">]</span>
</pre></div>
</div>
<p>因为我们没必要显示或编辑 session，所以我们对动作的种类做了限制，为 <code>resources</code> 方法指定了 <code>:only</code> 选项，只创建 <code>new</code>、<code>create</code> 和 <code>destroy</code> 动作。最终的结果，包括登录和退出具名路由的设置，如代码 8.2 所示。</p>

<div class="codeblock has-caption" id="codeblock-8-2"><p class="caption"><span>代码 8.2：</span>设置 session 相关的路由</p><p class="file"><code>config/routes.rb</code></p><div class="highlight type-ruby"><pre><span class="no">SampleApp</span><span class="o">::</span><span class="no">Application</span><span class="p">.</span><span class="nf">routes</span><span class="p">.</span><span class="nf">draw</span> <span class="k">do</span>
  <span class="n">resources</span> <span class="p">:</span><span class="n">users</span>
  <span class="n">resources</span> <span class="p">:</span><span class="n">sessions</span><span class="p">,</span> <span class="ss">only: </span><span class="p">[</span><span class="ss">:new</span><span class="p">,</span> <span class="ss">:create</span><span class="p">,</span> <span class="ss">:destroy</span><span class="p">]</span>
  <span class="n">root</span> <span class="ss">to: </span><span class="s1">'static_pages#home'</span>
  <span class="n">match</span> <span class="s1">'/signup'</span><span class="p">,</span>  <span class="ss">to: </span><span class="s1">'users#new'</span><span class="p">,</span>            <span class="ss">via: </span><span class="s1">'get'</span>
  <span class="n">match</span> <span class="s1">'/signin'</span><span class="p">,</span>  <span class="ss">to: </span><span class="s1">'sessions#new'</span><span class="p">,</span>         <span class="ss">via: </span><span class="s1">'get'</span>
  <span class="n">match</span> <span class="s1">'/signout'</span><span class="p">,</span> <span class="ss">to: </span><span class="s1">'sessions#destroy'</span><span class="p">,</span>     <span class="ss">via: </span><span class="s1">'delete'</span>
  <span class="p">.</span>
  <span class="nf">.</span>
  <span class="p">.</span>
<span class="nf">end</span>
</pre></div>
</div>
<p>注意，设置退出路由那行使用了 <code>via: 'delete'</code>，这个参数指明 <code>destroy</code> 动作要使用 <code>DELETE</code> 请求。</p>

<p>代码 8.2 中的路由设置会生成类似<a href="chapter7.html#table-7-1">表格 7.1</a> 所示的URI 地址和动作的对应关系，如<a href="chapter8.html#table-8-1">表格 8.1</a> 所示。注意，我们修改了登录和退出具名路由，而创建 session 的路由还是使用默认值。</p>

<p>为了让代码 8.1 中的测试通过，我们还要在 Sessions 控制器中加入 <code>new</code> 动作，相应的代码如代码 8.3 所示（同时也定义了 <code>create</code> 和 <code>destroy</code> 动作）。</p>

<div class="codeblock has-caption" id="codeblock-8-3"><p class="caption"><span>代码 8.3：</span>没什么内容的 Sessions 控制器</p><p class="file"><code>app/controllers/sessions_controller.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">SessionsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">new</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">create</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">destroy</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<div class="table has-caption" id="table-8-1"><p class="caption"><span>表格 8.1：</span>代码 8.2 中的设置生成的符合 REST 架构的路由关系</p><table>
  <thead>
    <tr>
      <th>HTTP 请求</th>
      <th>URL 地址</th>
      <th>具名路由</th>
      <th>动作</th>
      <th>目的</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>GET</code></td>
      <td>/signin</td>
      <td><code>signin_path</code></td>
      <td><code>new</code></td>
      <td>创建新 session 的页面（登录）</td>
    </tr>
    <tr>
      <td><code>POST</code></td>
      <td>/sessions</td>
      <td><code>sessions_path</code></td>
      <td><code>create</code></td>
      <td>创建 session</td>
    </tr>
    <tr>
      <td><code>DELETE</code></td>
      <td>/signout</td>
      <td><code>signout_path</code></td>
      <td><code>destroy</code></td>
      <td>删除 session（退出）</td>
    </tr>
  </tbody>
</table>
</div>
<p>接下来还要创建“登录”页面的视图，因为“登录”页面的目的是创建新 session，所以创建的视图位于 <code>app/views/sessions/new.html.erb</code>。在视图中我们要显示网页的标题和一个一级标头，如代码 8.4 所示。</p>

<div class="codeblock has-caption" id="codeblock-8-4"><p class="caption"><span>代码 8.4：</span>“登录”页面的视图</p><p class="file"><code>app/views/sessions/new.html.erb</code></p><div class="highlight type-erb"><pre><span class="cp">&lt;%</span> <span class="n">provide</span><span class="p">(</span><span class="ss">:title</span><span class="p">,</span> <span class="s2">"Sign in"</span><span class="p">)</span> <span class="cp">%&gt;</span>
<span class="nt">&lt;h1&gt;</span>Sign in<span class="nt">&lt;/h1&gt;</span>
</pre></div>
</div>
<p>现在代码 8.1 中的测试应该可以通过了，接下来我们要编写登录表单。</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>bundle <span class="nb">exec </span>rspec spec/
</pre></div>
</div>
<h3 id='section-8-1-2'><span>8.1.2</span> 测试登录功能</h3>


<p>对比图 8.1 和图 7.11 之后，我们发现登录表单和注册表单外观上差不多，只是少了两个字段，只有 Email 地址和密码字段。和注册表单一样，我们可以使用 Capybara 填写表单，再点击按钮进行测试。</p>

<p>在测试的过程中，我们不得不向程序中加入相应的功能，这也正是 TDD 带来的好处之一。我们先来测试填写不合法数据的登录过程，构思图如图 8.2 所示。</p>

<p>从图 8.2 我们可以看出，如果提交的数据不正确，我们会重新渲染“注册”页面，还会显示一个错误提示消息。这个错误提示是 Flash 消息，我们可以通过下面的测试验证：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">have_selector</span><span class="p">(</span><span class="s1">'div.alert.alert-error'</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>这行代码使用了代码 7.32（在第 7 章的练习中）中用过的 <code>have_selector</code> 方法。<code>have_selector</code> 会检查页面中是否出现了指定的元素（例如，一个 HTML 标签，不过在 Capybara 2.0 中只会检查<strong>可见</strong>的元素）
本例我们要查找的元素是：</p>

<div class="codeblock"><div class="highlight type-plaintext"><pre>div.alert.alert-error
</pre></div>
</div>
<p>上面这行代码会寻找一个 <code>div</code> 标签。前面介绍过，这里的点号代表 CSS 中的 class（参见 <a href="chapter5.html#section-5-1-2">5.1.2 节</a>），你也许猜到了，这里我们要查找的是同时具有 <code>alert</code> 和 <code>alert-error</code> class 的 <code>div</code> 元素，如下：</p>

<div class="codeblock"><div class="highlight type-html"><pre><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"alert alert-error"</span><span class="nt">&gt;</span>Invalid...<span class="nt">&lt;/div&gt;</span>
</pre></div>
</div>
<div class="figure" id="figure-8-2">
  <img src="figures/signin_failure_mockup_bootstrap.png" alt="signin failure mockup bootstrap" />
  <p class="caption"><span>图 8.2：</span>注册失败页面的构思图</p>
</div>
<p>代码 8.5 是针对标题和 Flash 消息的测试。我们可以看出，这些代码缺少了一个很重要的部分，会在 <a href="chapter8.html#section-8-1-5">8.1.5 节</a>中说明。</p>

<div class="codeblock has-caption" id="codeblock-8-5"><p class="caption"><span>代码 8.5：</span>登录失败时的测试</p><p class="file"><code>spec/requests/authentication_pages_spec.rb</code></p><div class="highlight type-ruby"><pre><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="s2">"Authentication"</span> <span class="k">do</span>
  <span class="p">.</span>
  <span class="nf">.</span>
  <span class="p">.</span>
  <span class="nf">describe</span> <span class="s2">"signin"</span> <span class="k">do</span>
    <span class="n">before</span> <span class="p">{</span> <span class="n">visit</span> <span class="n">signin_path</span> <span class="p">}</span>

    <span class="n">describe</span> <span class="s2">"with invalid information"</span> <span class="k">do</span>
      <span class="n">before</span> <span class="p">{</span> <span class="n">click_button</span> <span class="s2">"Sign in"</span> <span class="p">}</span>

      <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">have_title</span><span class="p">(</span><span class="s1">'Sign in'</span><span class="p">)</span> <span class="p">}</span>
      <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">have_selector</span><span class="p">(</span><span class="s1">'div.alert.alert-error'</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>测试了登录失败的情况，下面我们要测试登录成功的情况了。我们要测试登录成功后是否转向了用户资料页面（从页面的标题判断，标题中应该包含用户的名字），还要测试网站的导航中是否有以下三个变化：</p>

<ol>
  <li>出现了指向用户资料页面的链接</li>
  <li>出现了“退出”链接</li>
  <li>“登录”链接消失了</li>
</ol>

<p>（对“设置（Settings）”链接的测试会在 <a href="chapter9.html#section-9-1">9.1 节</a>中实现，对“所有用户（Users）”链接的测试会在 <a href="chapter9.html#section-9-3">9.3 节</a>中实现。）如上变化的构思图如图 8.3 所示。<sup class="footnote" id="fnref-8-2"><a href="#fn-8-2" rel="footnote">2</a></sup>注意，“退出”和“个人资料”链接位于“账户（Account）”下拉菜单中。在 <a href="chapter8.html#section-8-2-4">8.2.4 节</a>中会介绍如何通过 Bootstrap 实现这种下拉菜单。</p>

<p>对登录成功时的测试如代码 8.6 所示。</p>

<div class="codeblock has-caption" id="codeblock-8-6"><p class="caption"><span>代码 8.6：</span>登录成功时的测试</p><p class="file"><code>spec/requests/authentication_pages_spec.rb</code></p><div class="highlight type-ruby"><pre><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="s2">"Authentication"</span> <span class="k">do</span>
  <span class="p">.</span>
  <span class="nf">.</span>
  <span class="p">.</span>
  <span class="nf">describe</span> <span class="s2">"signin"</span> <span class="k">do</span>
    <span class="n">before</span> <span class="p">{</span> <span class="n">visit</span> <span class="n">signin_path</span> <span class="p">}</span>
    <span class="p">.</span>
    <span class="nf">.</span>
    <span class="p">.</span>
    <span class="nf">describe</span> <span class="s2">"with valid information"</span> <span class="k">do</span>
      <span class="n">let</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span> <span class="p">{</span> <span class="no">FactoryGirl</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span> <span class="p">}</span>
      <span class="n">before</span> <span class="k">do</span>
        <span class="n">fill_in</span> <span class="s2">"Email"</span><span class="p">,</span>    <span class="ss">with: </span><span class="n">user</span><span class="p">.</span><span class="nf">email</span><span class="p">.</span><span class="nf">upcase</span>
        <span class="n">fill_in</span> <span class="s2">"Password"</span><span class="p">,</span> <span class="ss">with: </span><span class="n">user</span><span class="p">.</span><span class="nf">password</span>
        <span class="n">click_button</span> <span class="s2">"Sign in"</span>
      <span class="k">end</span>

      <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">have_title</span><span class="p">(</span><span class="n">user</span><span class="p">.</span><span class="nf">name</span><span class="p">)</span> <span class="p">}</span>
      <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">have_link</span><span class="p">(</span><span class="s1">'Profile'</span><span class="p">,</span>     <span class="ss">href: </span><span class="n">user_path</span><span class="p">(</span><span class="n">user</span><span class="p">))</span> <span class="p">}</span>
      <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">have_link</span><span class="p">(</span><span class="s1">'Sign out'</span><span class="p">,</span>    <span class="ss">href: </span><span class="n">signout_path</span><span class="p">)</span> <span class="p">}</span>
      <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">have_link</span><span class="p">(</span><span class="s1">'Sign in'</span><span class="p">,</span> <span class="ss">href: </span><span class="n">signin_path</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<div class="figure" id="figure-8-3">
  <img src="figures/signin_success_mockup_bootstrap.png" alt="signin success mockup bootstrap" />
  <p class="caption"><span>图 8.3：</span>登录成功后显示的用户资料页面构思图</p>
</div>
<p>在代码 8.6 中用到了 Capybara 提供的 <code>have_link</code> 方法，它的第一参数是链接文本，第二个参数是可选的 <code>:href</code>，指定链接的地址，因此如下的代码</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">have_link</span><span class="p">(</span><span class="s1">'Profile'</span><span class="p">,</span> <span class="ss">href: </span><span class="n">user_path</span><span class="p">(</span><span class="n">user</span><span class="p">))</span> <span class="p">}</span>
</pre></div>
</div>
<p>确保了页面中有一个 <code>a</code> 元素，链接到指定的 URL 地址。这里我们要检测的是一个指向用户资料页面的链接。注意，我们调用 <code>upcase</code> 方法把用户的 Email 地址转换成了大写形式，确保在数据库中查询用户时不用担心大小写问题。</p>

<h3 id='section-8-1-3'><span>8.1.3</span> 登录表单</h3>


<p>写完测试之后，我们就可以创建登录表单了。在代码 7.17 中，注册表单使用了 <code>form_for</code> 帮助函数，并指定其参数为 <code>@user</code> 变量：</p>

<div class="codeblock"><div class="highlight type-erb"><pre><span class="cp">&lt;%=</span> <span class="n">form_for</span><span class="p">(</span><span class="vi">@user</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span> <span class="cp">%&gt;</span>
.
.
.
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</pre></div>
</div>
<p>注册表单和登录表单的区别在于，程序中没有 Session 模型，因此也就没有类似 <code>@user</code> 的变量。也就是说，在构建登录表单时，我们要给 <code>form_for</code> 提供更多的信息。一般来说，如下的代码</p>

<div class="codeblock"><div class="highlight type-erb"><pre>form_for(@user)
</pre></div>
</div>
<p>Rails 会自动向 /users 地址发送 <code>POST</code> 请求。对于登录表单，我们则要明确的指定资源的名称以及相应的 URL 地址：</p>

<div class="codeblock"><div class="highlight type-erb"><pre>form_for(:session, url: sessions_path)
</pre></div>
</div>
<p>（创建表单还有另一种方法，不用 <code>form_for</code>，而用 <code>form_tag</code>。<code>form_tag</code> 也是 Rails 程序常用的方法，不过换用 <code>form_tag</code> 之后就和注册表单有很多不同之处了，我现在是想使用相似的代码构建登录表单。使用 <code>form_tag</code> 构建登录表单会留作练习（参见 <a href="chapter8.html#section-8-5">8.5 节</a>）。）</p>

<p>使用上述这种 <code>form_for</code> 形式，参照代码 7.17 中的注册表单，很容易的就能编写一个符合图 8.1 的登录表单，如代码 8.7 所示。</p>

<div class="codeblock has-caption" id="codeblock-8-7"><p class="caption"><span>代码 8.7：</span>注册表单的代码</p><p class="file"><code>app/views/sessions/new.html.erb</code></p><div class="highlight type-erb"><pre><span class="cp">&lt;%</span> <span class="n">provide</span><span class="p">(</span><span class="ss">:title</span><span class="p">,</span> <span class="s2">"Sign in"</span><span class="p">)</span> <span class="cp">%&gt;</span>
<span class="nt">&lt;h1&gt;</span>Sign in<span class="nt">&lt;/h1&gt;</span>

<span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"row"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"span6 offset3"</span><span class="nt">&gt;</span>
    <span class="cp">&lt;%=</span> <span class="n">form_for</span><span class="p">(</span><span class="ss">:session</span><span class="p">,</span> <span class="ss">url: </span><span class="n">sessions_path</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span> <span class="cp">%&gt;</span>

      <span class="cp">&lt;%=</span> <span class="n">f</span><span class="p">.</span><span class="nf">label</span> <span class="ss">:email</span> <span class="cp">%&gt;</span>
      <span class="cp">&lt;%=</span> <span class="n">f</span><span class="p">.</span><span class="nf">text_field</span> <span class="ss">:email</span> <span class="cp">%&gt;</span>

      <span class="cp">&lt;%=</span> <span class="n">f</span><span class="p">.</span><span class="nf">label</span> <span class="ss">:password</span> <span class="cp">%&gt;</span>
      <span class="cp">&lt;%=</span> <span class="n">f</span><span class="p">.</span><span class="nf">password_field</span> <span class="ss">:password</span> <span class="cp">%&gt;</span>

      <span class="cp">&lt;%=</span> <span class="n">f</span><span class="p">.</span><span class="nf">submit</span> <span class="s2">"Sign in"</span><span class="p">,</span> <span class="ss">class: </span><span class="s2">"btn btn-large btn-primary"</span> <span class="cp">%&gt;</span>
    <span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>

    <span class="nt">&lt;p&gt;</span>New user? <span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Sign up now!"</span><span class="p">,</span> <span class="n">signup_path</span> <span class="cp">%&gt;</span><span class="nt">&lt;/p&gt;</span>
  <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</pre></div>
</div>
<p>注意，为了访客的便利，我们还加入了到“注册”页面的链接。代码 8.7 中的登录表单效果如图 8.4 所示。</p>

<div class="figure" id="figure-8-4">
  <img src="figures/signin_form_bootstrap.png" alt="signin form bootstrap" />
  <p class="caption"><span>图 8.4：</span>登录表单（<a href="http://localhost:3000/signin">/signup</a>）</p>
</div>
<p>用的多了你就不会老是查看 Rails 生成的 HTML（你会完全信任所用的帮助函数可以正确的完成任务），不过现在还是来看一下登录表单的 HTML 吧（如代码 8.8 所示）。</p>

<div class="codeblock has-caption" id="codeblock-8-8"><p class="caption"><span>代码 8.8：</span>代码 8.7 中登录表单生成的 HTML</p><div class="highlight type-html"><pre><span class="nt">&lt;form</span> <span class="na">accept-charset=</span><span class="s">"UTF-8"</span> <span class="na">action=</span><span class="s">"/sessions"</span> <span class="na">method=</span><span class="s">"post"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;div&gt;</span>
    <span class="nt">&lt;label</span> <span class="na">for=</span><span class="s">"session_email"</span><span class="nt">&gt;</span>Email<span class="nt">&lt;/label&gt;</span>
    <span class="nt">&lt;input</span> <span class="na">id=</span><span class="s">"session_email"</span> <span class="na">name=</span><span class="s">"session[email]"</span> <span class="na">type=</span><span class="s">"text"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/div&gt;</span>
  <span class="nt">&lt;div&gt;</span>
    <span class="nt">&lt;label</span> <span class="na">for=</span><span class="s">"session_password"</span><span class="nt">&gt;</span>Password<span class="nt">&lt;/label&gt;</span>
    <span class="nt">&lt;input</span> <span class="na">id=</span><span class="s">"session_password"</span> <span class="na">name=</span><span class="s">"session[password]"</span>
           <span class="na">type=</span><span class="s">"password"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/div&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">class=</span><span class="s">"btn btn-large btn-primary"</span> <span class="na">name=</span><span class="s">"commit"</span> <span class="na">type=</span><span class="s">"submit"</span>
       <span class="na">value=</span><span class="s">"Sign in"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/form&gt;</span>
</pre></div>
</div>
<p>你可以对比一下代码 8.8 和代码 7.20。你可能已经猜到了，提交登录表单后会生成一个 <code>params</code> Hash，其中 <code>params[:session][:email]</code> 和 <code>params[:session][:password]</code> 分别对应了 Email 和密码字段。</p>

<h3 id='section-8-1-4'><span>8.1.4</span> 分析表单提交</h3>


<p>和创建用户类似，创建 session 时先要处理提交不合法数据的情况。我们已经编写了对提交不合法数据的测试（参见代码 8.5），也添加了有几处难理解但还算简单的代码让测试通过了。下面我们就来分析一下表单提交的过程，然后为登录失败添加失败提示信息（如图 8.2）。最后，以此为基础，验证提交的 Email 和密码，处理登录成功的情况（参见 <a href="chapter8.html#section-8-2">8.2 节</a>）。</p>

<p>首先，我们来编写 Sessions 控制器的 <code>create</code> 动作，如代码 8.9 所示，现在只是直接渲染登录页面。在浏览器中访问 /sessions/new，然后提交空表单，显示的页面如图 8.5 所示。</p>

<div class="codeblock has-caption" id="codeblock-8-9"><p class="caption"><span>代码 8.9：</span>Sessions 控制器中 <code>create</code> 动作的初始版本</p><p class="file"><code>app/controllers/sessions_controller.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">SessionsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="p">.</span>
  <span class="nf">.</span>
  <span class="p">.</span>
  <span class="nf">def</span> <span class="n">create</span>
    <span class="n">render</span> <span class="s1">'new'</span>
  <span class="k">end</span>
  <span class="p">.</span>
  <span class="nf">.</span>
  <span class="p">.</span>
<span class="nf">end</span>
</pre></div>
</div>
<div class="figure" id="figure-8-5">
  <img src="figures/initial_failed_signin_rails_3_bootstrap.png" alt="initial failed signin rails3 bootstrap" />
  <p class="caption"><span>图 8.5：</span>代码 8.9 中的 <code>create</code> 动作显示的登录失败后的页面</p>
</div>
<p>仔细看一下图 8.5 中显示的调试信息，你会发现，如在 <a href="chapter8.html#section-8-1-3">8.1.3 节</a>末尾说过的，表单提交后会生成 <code>params</code> Hash，Email 和密码都在 <code>:session</code> 键中：</p>

<div class="codeblock"><div class="highlight type-yaml"><pre><span class="nn">---</span>
<span class="s">session</span><span class="pi">:</span>
  <span class="s">email</span><span class="pi">:</span> <span class="s1">'</span><span class="s">'</span>
  <span class="s">password</span><span class="pi">:</span> <span class="s1">'</span><span class="s">'</span>
<span class="s">commit</span><span class="pi">:</span> <span class="s">Sign in</span>
<span class="s">action</span><span class="pi">:</span> <span class="s">create</span>
<span class="s">controller</span><span class="pi">:</span> <span class="s">sessions</span>
</pre></div>
</div>
<p>和注册表单类似，这些参数是一个嵌套的 Hash，在代码 4.6 中见过。<code>params</code> 包含了如下的嵌套 Hash：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="p">{</span> <span class="ss">session: </span><span class="p">{</span> <span class="ss">password: </span><span class="s2">""</span><span class="p">,</span> <span class="ss">email: </span><span class="s2">""</span> <span class="p">}</span> <span class="p">}</span>
</pre></div>
</div>
<p>也就是说</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">params</span><span class="p">[</span><span class="ss">:session</span><span class="p">]</span>
</pre></div>
</div>
<p>本身就是一个 Hash：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="p">{</span> <span class="ss">password: </span><span class="s2">""</span><span class="p">,</span> <span class="ss">email: </span><span class="s2">""</span> <span class="p">}</span>
</pre></div>
</div>
<p>所以，</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">params</span><span class="p">[</span><span class="ss">:session</span><span class="p">][</span><span class="ss">:email</span><span class="p">]</span>
</pre></div>
</div>
<p>就是提交的 Email 地址，而</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">params</span><span class="p">[</span><span class="ss">:session</span><span class="p">][</span><span class="ss">:password</span><span class="p">]</span>
</pre></div>
</div>
<p>就是提交的密码。</p>

<p>也就是说，在 <code>create</code> 动作中，<code>params</code> 包含了使用 Email 和密码验证用户身份所需的全部数据。幸运的是，我们已经定义了身份验证过程中所需的两个方法，即由 Active Record 提供的 <code>User.find_by_email</code>（参见 <a href="chapter6.html#section-6-1-4">6.1.4 节</a>），以及由 <code>has_secure_password</code> 提供的 <code>authenticate</code> 方法（参见 <a href="chapter6.html#section-6-3-3">6.3.3 节</a>）。我们之前介绍过，如果提交的数据不合法，<code>authenticate</code> 方法会返回 <code>false</code>。基于以上的分析，我们计划按照如下的方式实现用户登录功能：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="k">def</span> <span class="nf">create</span>
  <span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find_by</span><span class="p">(</span><span class="ss">email: </span><span class="n">params</span><span class="p">[</span><span class="ss">:session</span><span class="p">][</span><span class="ss">:email</span><span class="p">].</span><span class="nf">downcase</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="p">.</span><span class="nf">authenticate</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:session</span><span class="p">][</span><span class="ss">:password</span><span class="p">])</span>
    <span class="c1"># Sign the user in and redirect to the user's show page.</span>
  <span class="k">else</span>
    <span class="c1"># Create an error message and re-render the signin form.</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p><code>create</code> 动作的第一行，使用提交的 Email 地址从数据库中取出相应的用户。（我们在 <a href="chapter6.html#section-6-2-5">6.2.5 节</a>讲过，Email 地址都是以小写字母形式保存的，所以这里调用了 <code>downcase</code> 方法，确保提交合法 Email 地址后能查询到相应的记录。）第二行看起来很怪，但在 Ruby 中经常使用：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="p">.</span><span class="nf">authenticate</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:session</span><span class="p">][</span><span class="ss">:password</span><span class="p">])</span>
</pre></div>
</div>
<div class="table has-caption" id="table-8-2"><p class="caption"><span>表格 8.2：</span><code>user &amp;&amp; user.authenticate(...)</code> 可能出现的结果</p><table>
  <thead>
    <tr>
      <th>用户</th>
      <th>密码</th>
      <th>a &amp;&amp; b</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>不存在</td>
      <td>任意值</td>
      <td><code>nil &amp;&amp; [anything] == false</code></td>
    </tr>
    <tr>
      <td>存在</td>
      <td>错误的密码</td>
      <td><code>true &amp;&amp; false == false</code></td>
    </tr>
    <tr>
      <td>存在</td>
      <td>正确的密码</td>
      <td><code>true &amp;&amp; true == true</code></td>
    </tr>
  </tbody>
</table>
</div>
<p>我们使用 <code>&amp;&amp;</code>（逻辑与）检测获取的用户是否合法。因为除了 <code>nil</code> 和 <code>false</code> 之外的所有对象都被视作 <code>true</code>，上面这个语句可能出现的结果如<a href="chapter8.html#table-8-2">表格 8.2</a>所示。我们可以从表格 8.2 中看出，当且仅当数据库中存在提交的 Email 并提交了对应的密码时，这个语句才会返回 <code>true</code>。</p>

<h3 id='section-8-1-5'><span>8.1.5</span> 显示 Flash 消息</h3>


<p>在 <a href="chapter7.html#section-7-3-3">7.3.3 节</a>中，我们使用 User 模型的数据验证信息来显示注册失败时的提示信息。这些错误提示信息是关联在某个 Active Record 对象上的，不过这种方式不可以用在 session 上，因为 session 不是 Active Record 模型。我们要采取的方法是，在登录失败时，把错误提示信息赋值给 Flash 消息。代码 8.10 显示的是我们首次尝试实现这种方法所用的代码，其中有个小小的错误。</p>

<div class="figure" id="figure-8-6">
  <img src="figures/failed_signin_flash_bootstrap.png" alt="failed signin flash bootstrap" />
  <p class="caption"><span>图 8.6：</span>登录失败后显示的 Flash 消息</p>
</div>
<div class="codeblock has-caption" id="codeblock-8-10"><p class="caption"><span>代码 8.10：</span>尝试处理登录失败（有个小小的错误）</p><p class="file"><code>app/controllers/sessions_controller.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">SessionsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">new</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">create</span>
    <span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find_by</span><span class="p">(</span><span class="ss">email: </span><span class="n">params</span><span class="p">[</span><span class="ss">:session</span><span class="p">][</span><span class="ss">:email</span><span class="p">].</span><span class="nf">downcase</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="p">.</span><span class="nf">authenticate</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:session</span><span class="p">][</span><span class="ss">:password</span><span class="p">])</span>
      <span class="c1"># Sign the user in and redirect to the user's show page.</span>
    <span class="k">else</span>
      <span class="n">flash</span><span class="p">[</span><span class="ss">:error</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'Invalid email/password combination'</span> <span class="c1"># Not quite right!</span>
      <span class="n">render</span> <span class="s1">'new'</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">destroy</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>布局中已经加入了显示 Flash 消息的局部视图（代码 7.27），所以无需其他修改，上述 Flash 错误提示消息就会显示出来，而且因为使用了 Bootstrap，这个错误消息的样式也很美观（如图 8.6）。</p>

<p>不过，就像代码 8.10 中的注释所说，这些代码还有问题。显示的页面看起来很正常啊，那么，问题出现在哪儿呢？问题的关键在于，Flash 消息在一个请求的生命周期内是持续存在的，而重新渲染页面（使用 <code>render</code> 方法）和代码 7.28 中的转向不同，它不算新的请求，你会发现这个 Flash 消息存在的时间比设想的要长很多。例如，我们提交了不合法的登录信息，Flash 消息生成了，然后在登录页面中显示出来（如图 8.6），这时如果我们点击链接转到其他页面（例如“首页”），这只算是表单提交后的第一次请求，所以页面中还是会显示 Flash 消息（如图 8.7）。</p>

<div class="figure" id="figure-8-7">
  <img src="figures/flash_persistence_bootstrap.png" alt="flash persistence bootstrap" />
  <p class="caption"><span>图 8.7：</span>仍然显示有 Flash 消息的页面</p>
</div>
<p>Flash 消息没有按预期消失算是程序的一个 bug，在修正之前，我们最好编写一个测试来捕获这个错误。现在，登录失败时的测试是可以通过的：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>bundle <span class="nb">exec </span>rspec spec/requests/authentication_pages_spec.rb <span class="se">\</span>
<span class="gp">&gt; </span>-e <span class="s2">"signin with invalid information"</span>
</pre></div>
</div>
<p>不过程序中有错误，测试应该是失败的，所以我们要编写一个能够捕获这种错误的测试。幸好，捕获这种错误正是集成测试的拿手好戏，所用的代码如下：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">describe</span> <span class="s2">"after visiting another page"</span> <span class="k">do</span>
  <span class="n">before</span> <span class="p">{</span> <span class="n">click_link</span> <span class="s2">"Home"</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">have_selector</span><span class="p">(</span><span class="s1">'div.alert.alert-error'</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div>
<p>提交不合法的登录信息之后，这个测试用例会点击网站中的“首页”链接，期望显示的页面中没有 Flash 错误消息。添加上述测试用例的测试文件如代码 8.11 所示。</p>

<div class="codeblock has-caption" id="codeblock-8-11"><p class="caption"><span>代码 8.11：</span>登录失败时的合理测试</p><p class="file"><code>spec/requests/authentication_pages_spec.rb</code></p><div class="highlight type-ruby"><pre><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="s2">"Authentication"</span> <span class="k">do</span>
  <span class="p">.</span>
  <span class="nf">.</span>
  <span class="p">.</span>
  <span class="nf">describe</span> <span class="s2">"signin"</span> <span class="k">do</span>

    <span class="n">before</span> <span class="p">{</span> <span class="n">visit</span> <span class="n">signin_path</span> <span class="p">}</span>

    <span class="n">describe</span> <span class="s2">"with invalid information"</span> <span class="k">do</span>
      <span class="n">before</span> <span class="p">{</span> <span class="n">click_button</span> <span class="s2">"Sign in"</span> <span class="p">}</span>

      <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">have_title</span><span class="p">(</span><span class="s1">'Sign in'</span><span class="p">)</span> <span class="p">}</span>
      <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">have_selector</span><span class="p">(</span><span class="s1">'div.alert.alert-error'</span><span class="p">)</span> <span class="p">}</span>

      <span class="n">describe</span> <span class="s2">"after visiting another page"</span> <span class="k">do</span>
        <span class="n">before</span> <span class="p">{</span> <span class="n">click_link</span> <span class="s2">"Home"</span> <span class="p">}</span>
        <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">have_selector</span><span class="p">(</span><span class="s1">'div.alert.alert-error'</span><span class="p">)</span> <span class="p">}</span>
      <span class="k">end</span>
    <span class="k">end</span>
    <span class="p">.</span>
    <span class="nf">.</span>
    <span class="p">.</span>
  <span class="nf">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>新添加的测试和预期一致，是失败的：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>bundle <span class="nb">exec </span>rspec spec/requests/authentication_pages_spec.rb <span class="se">\</span>
<span class="gp">&gt; </span>-e <span class="s2">"signin with invalid information"</span>
</pre></div>
</div>
<p>要让这个测试通过，我们要用 <code>flash.now</code> 替换 <code>flash</code>。<code>flash.now</code> 就是专门用来在重新渲染的页面中显示 Flash 消息的，在发送新的请求之后，Flash 消息便会消失。正确的 <code>create</code> 动作代码如代码 8.12 所示。</p>

<div class="codeblock has-caption" id="codeblock-8-12"><p class="caption"><span>代码 8.12：</span>处理登录失败所需的正确代码</p><p class="file"><code>app/controllers/sessions_controller.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">SessionsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">new</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">create</span>
    <span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find_by</span><span class="p">(</span><span class="ss">email: </span><span class="n">params</span><span class="p">[</span><span class="ss">:session</span><span class="p">][</span><span class="ss">:email</span><span class="p">].</span><span class="nf">downcase</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="p">.</span><span class="nf">authenticate</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:session</span><span class="p">][</span><span class="ss">:password</span><span class="p">])</span>
      <span class="c1"># Sign the user in and redirect to the user's show page.</span>
    <span class="k">else</span>
      <span class="n">flash</span><span class="p">.</span><span class="nf">now</span><span class="p">[</span><span class="ss">:error</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'Invalid email/password combination'</span>
      <span class="n">render</span> <span class="s1">'new'</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">destroy</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>现在登录失败时的所有测试应该都可以通过了：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>bundle <span class="nb">exec </span>rspec spec/requests/authentication pages spec.rb <span class="se">\</span>
<span class="gp">&gt; </span>-e <span class="s2">"with invalid information"</span>
</pre></div>
</div>
<h2 id='section-8-2'><span>8.2</span> 登录成功</h2>


<p>上一节处理了登录失败的情况，这一节我们要处理登录成功的情况了。实现用户登录的过程是本书目前为止最考验 Ruby 编程能力的部分，你要坚持读完本节，做好心理准备，付出大量的脑力劳动。幸好，第一步还算是简单的，完成 Sessions 控制器的 <code>create</code> 动作没什么难的，不过还是需要一点小技巧。</p>

<p>我们需要把代码 8.12 中处理登录成功分支中的注释换成具体的代码，使用 <code>sign_in</code> 方法实现登录操作，然后转向用户的资料页面，如代码 8.13 所示。这就是我们使用的技巧，使用还没定义的方法 <code>sign_in</code>。本节后面的内容会定义这个方法。</p>

<div class="codeblock has-caption" id="codeblock-8-13"><p class="caption"><span>代码 8.13：</span>完整的 <code>create</code> 动作代码（还不能正常使用）</p><p class="file"><code>app/controllers/sessions_controller.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">SessionsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="p">.</span>
  <span class="nf">.</span>
  <span class="p">.</span>
  <span class="nf">def</span> <span class="n">create</span>
    <span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find_by</span><span class="p">(</span><span class="ss">email: </span><span class="n">params</span><span class="p">[</span><span class="ss">:session</span><span class="p">][</span><span class="ss">:email</span><span class="p">].</span><span class="nf">downcase</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="p">.</span><span class="nf">authenticate</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:session</span><span class="p">][</span><span class="ss">:password</span><span class="p">])</span>
      <span class="n">sign_in</span> <span class="n">user</span>
      <span class="n">redirect_to</span> <span class="n">user</span>
    <span class="k">else</span>
      <span class="n">flash</span><span class="p">.</span><span class="nf">now</span><span class="p">[</span><span class="ss">:error</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'Invalid email/password combination'</span>
      <span class="n">render</span> <span class="s1">'new'</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="p">.</span>
  <span class="nf">.</span>
  <span class="p">.</span>
<span class="nf">end</span>
</pre></div>
</div>
<h3 id='section-8-2-1'><span>8.2.1</span> “记住我”</h3>


<p>现在我们要开始实现登录功能了，第一步是实现“记住我”这个功能，即用户登录的状态会被“永远”记住，直到用户点击“退出”链接为止。实现登录功能用到的函数已经超越了传统的 MVC 架构，其中一些函数要同时在控制器和视图中使用。在<a href="chapter4.html#section-4-2-5">4.2.5 节</a>中介绍过，Ruby 支持模块（module）功能，打包一系列函数，在不同的地方引入。我们会利用模块来打包用户身份验证相关的函数。我们当然可以创建一个新的模块，不过 Sessions 控制器已经提供了一个名为 <code>SessionsHelper</code> 的模块，而且这个模块中的帮助方法会自动引入 Rails 程序的视图中。所以，我们就直接使用这个现成的模块，然后在 Application 控制器中引入，如代码 8.14 所示。</p>

<div class="codeblock has-caption" id="codeblock-8-14"><p class="caption"><span>代码 8.14：</span>在 Application 控制器中引入 Sessions 控制器的帮助方法模块</p><p class="file"><code>app/controllers/application_controller.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">ApplicationController</span> <span class="o">&lt;</span> <span class="no">ActionController</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">protect_from_forgery</span> <span class="ss">with: :exception</span>
  <span class="kp">include</span> <span class="no">SessionsHelper</span>
<span class="k">end</span>
</pre></div>
</div>
<p>默认情况下帮助函数只可以在视图中使用，不能在控制器中使用，而我们需要同时在控制器和视图中使用帮助函数，所以我们就手动引入帮助函数所在的模块。</p>

<p>因为 HTTP 是无状态的协议，所以如果应用程序需要实现登录功能的话，就要找到一种方法记住用户的状态。维持用户登录状态的方法之一，是使用常规的 Rails session（通过 <code>session</code> 函数），把用户的 id 保存在“记忆权标（remember token）”中：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">session</span><span class="p">[</span><span class="ss">:remember_token</span><span class="p">]</span> <span class="o">=</span> <span class="n">user</span><span class="p">.</span><span class="nf">id</span>
</pre></div>
</div>
<p><code>session</code> 对象把用户 id 保存在浏览器的 cookie 中，这样在网站的所有页面就都可以使用了。浏览器关闭后，cookie 也随之失效。在网站中的任何页面，只需调用 <code>User.find(session[:remember_token])</code> 就可以取回用户对象了。Rails 在处理 session 时，会确保安全性。倘若用户企图伪造用户 id，Rails 可以通过每个 session 的 session id 检测到。</p>

<p>根据示例程序的设计目标，我们计划要实现的是持久保存的 session，即使浏览器关闭了，登录状态依旧存在，所以，登入的用户要有一个持久保存的标识符才行。为此，我们要为每个用户生成一个唯一而安全的记忆权标，长期存储，不会随着浏览器的关闭而消失。</p>

<p>记忆权标要附属到特定的用户对象上，而且要保存起来以待后用，所以我们就可以把它设为 User 模型的属性（如图 8.8）。我们先来编写 User 模型的测试，如代码 8.15 所示。</p>

<div class="figure" id="figure-8-8">
  <img src="figures/user_model_remember_token_31.png" alt="user model remember token 31" />
  <p class="caption"><span>图 8.8：</span>User 模型，添加了 <code>remember_token</code> 属性</p>
</div>
<div class="codeblock has-caption" id="codeblock-8-15"><p class="caption"><span>代码 8.15：</span>记忆权标的第一个测试</p><p class="file"><code>spec/models/user_spec.rb</code></p><div class="highlight type-ruby"><pre><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>
  <span class="p">.</span>
  <span class="nf">.</span>
  <span class="p">.</span>
  <span class="nf">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:password_confirmation</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:remember_token</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:authenticate</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">.</span>
  <span class="nf">.</span>
  <span class="p">.</span>
<span class="nf">end</span>
</pre></div>
</div>
<p>要让这个测试通过，我们要生成记忆权标属性，执行如下命令：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>rails generate migration add_remember_token_to_users
</pre></div>
</div>
<p>然后按照代码 8.16 修改生成的迁移文件。注意，因为我们要使用记忆权标取回用户，所以我们为 <code>remember_token</code> 列加了索引（参见 <a href="chapter6.html#aside-6-2">旁注 6.2</a>）。</p>

<div class="codeblock has-caption" id="codeblock-8-16"><p class="caption"><span>代码 8.16：</span><code>users</code> 表添加 <code>remember_token</code> 列的迁移</p><p class="file"><code>db/migrate/[timestamp]_add_remember_token_to_users.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">AddRememberTokenToUsers</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">add_column</span> <span class="p">:</span><span class="n">users</span><span class="p">,</span> <span class="ss">:remember_token</span><span class="p">,</span> <span class="ss">:string</span>
    <span class="n">add_index</span> <span class="p">:</span><span class="n">users</span><span class="p">,</span> <span class="ss">:remember_token</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>然后，还要更新“开发数据库”和“测试数据库”：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>bundle <span class="nb">exec </span>rake db:migrate
<span class="gp">$ </span>bundle <span class="nb">exec </span>rake <span class="nb">test</span>:prepare
</pre></div>
</div>
<p>现在，User 模型的测试应该可以通过了：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>bundle <span class="nb">exec </span>rspec spec/models/user_spec.rb
</pre></div>
</div>
<p>接下来我们要考虑记忆权标要保存什么数据，这有很多种选择，其实任何足够长的随机字符串都是可以的，只要能保证唯一性。Ruby 标准库中 <code>SecureRandom</code> 模块提供的 <code>urlsafe_base64</code> 方法可以满足我们的要求。<sup class="footnote" id="fnref-8-3"><a href="#fn-8-3" rel="footnote">3</a></sup><code>SecureRandom.urlsafe_base64</code> 创建的字符串长度为 16，由 A-Z、a-z、0-9、下划线（_）和连字符（-）组成（每一位字符都有 64 种可能的情况，所以叫做“<a href="http://en.wikipedia.org/wiki/Base64">base64</a>”）.所以两个记忆权标相等的概率就是 1/64<sup>16</sup> = 2<sup>-96</sup> ≈ 10<sup>-29</sup>，完全可以忽略。</p>

<p>我们计划在浏览器中存储这个 base64 权标，在数据库中存储加密后的版本。如果要自动登入用户，就可以从 cookie 中取出记忆权标，加密后查询数据库。数据库之所以只保存加密后的权标是因为，即便整个数据库都泄露了，攻击者也无法使用记忆权标登入网站。为了让记忆权标更安全，我们计划每次会话都生成不一样的权标，这样即使会话被劫持了（攻击者偷取 cookie 伪装成某个用户登录），用户下次登录时前一个会话就会失效。（会话劫持可以通过 <a href="http://codebutler.com/firesheep/">Firesheep</a> 扩展检测，使用这个扩展可以看到很多著名的网站在连接到公共 WIFI 时，记忆权标都是可见的。为了避免这个问题可以全站使用 SSL，在 <a href="chapter7.html#section-7-4-4">7.4.4 节</a>有介绍。）</p>

<p>真实的应用程序都会自动登入刚注册的用户（这样做的一个副作用就是创建了一个新的记忆权标），但是我们不想这么做，我们要用一种更好的方式，确保从一开始用户就有可用的记忆权标。为此，我们要使用回调函数生成权标。在 <a href="chapter6.html#section-6-2-5">6.2.5 节</a>中确保 Email 唯一性时用过回调函数，调用的是 <code>before_save</code>。现在我们要调用 <code>before_create</code> 在创建用户时设置记忆权标。<sup class="footnote" id="fnref-8-4"><a href="#fn-8-4" rel="footnote">4</a></sup></p>

<p>要测试这个过程，我们可以先保存测试所需的用户对象，然后检查 <code>remember_token</code> 是否为非空值。这样做，如果以后需要改变记忆权标的生成方式，也无需修改测试。测试代码如代码 8.17 所示。</p>

<div class="codeblock has-caption" id="codeblock-8-17"><p class="caption"><span>代码 8.17：</span>测试合法的（非空）记忆权标值</p><p class="file"><code>spec/models/user_spec.rb</code></p><div class="highlight type-ruby"><pre><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span> <span class="k">do</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">name: </span><span class="s2">"Example User"</span><span class="p">,</span> <span class="ss">email: </span><span class="s2">"user@example.com"</span><span class="p">,</span>
                     <span class="ss">password: </span><span class="s2">"foobar"</span><span class="p">,</span> <span class="ss">password_confirmation: </span><span class="s2">"foobar"</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">subject</span> <span class="p">{</span> <span class="vi">@user</span> <span class="p">}</span>
  <span class="p">.</span>
  <span class="nf">.</span>
  <span class="p">.</span>
  <span class="nf">describe</span> <span class="s2">"remember token"</span> <span class="k">do</span>
    <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="p">.</span><span class="nf">save</span> <span class="p">}</span>
    <span class="n">its</span><span class="p">(</span><span class="ss">:remember_token</span><span class="p">)</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_blank</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>代码 8.17 中用到了 <code>its</code> 方法，它和 <code>it</code> 很像，不过测试对象是参数中指定的属性而不是整个测试的对象。也就是说，如下的代码：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">its</span><span class="p">(</span><span class="ss">:remember_token</span><span class="p">)</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_blank</span> <span class="p">}</span>
</pre></div>
</div>
<p>等同于</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">it</span> <span class="p">{</span> <span class="n">expect</span><span class="p">(</span><span class="vi">@user</span><span class="p">.</span><span class="nf">remember_token</span><span class="p">).</span><span class="nf">not_to</span> <span class="n">be_blank</span> <span class="p">}</span>
</pre></div>
</div>
<p>User 模型的代码会涉及到一些新的知识。其一，我们添加了一个回调函数，在用户存入数据库之前生成记忆权标：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">before_create</span> <span class="p">:</span><span class="n">create_remember_token</span>
</pre></div>
</div>
<p>上面这行代码叫做“方法引用”。当 Rails 执行到这行代码时，会寻找一个名为 <code>create_remember_token</code> 的方法，在创建用户之前执行。（在代码 6.20 中，我们直接给 <code>before_save</code> 指定了块参数，但更推荐使用这种“方法引用”方式。）而且，<code>create_remember_token</code> 只会在 User 模型内部使用，所以没必要把它开放给用户之外的对象。如 <a href="chapter7.html#section-7-3-2">7.3.2 节</a>中所讲，在 Ruby 中，我们可以使用 <code>private</code> 关键字<sup class="footnote" id="fnref-8-t4"><a href="#fn-8-t4" rel="footnote">5</a></sup>限制方法的可见性：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="kp">private</span>

  <span class="k">def</span> <span class="nf">create_remember_token</span>
    <span class="c1"># Create the token.</span>
  <span class="k">end</span>
</pre></div>
</div>
<p>在类中，<code>private</code> 之后定义的方法都会被设为私有方法，所以，如果执行下面的操作</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>rails console
<span class="gp">&gt;&gt; </span>User.first.create_remember_token
</pre></div>
</div>
<p>就会抛出 <code>NoMethodError</code> 异常。</p>

<p>在 <code>create_remember_token</code> 方法中，要给用户的属性赋值，需要在 <code>remember_token</code> 前加上 <code>self</code> 关键字：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre>  <span class="k">def</span> <span class="nc">User</span><span class="o">.</span><span class="nf">new_remember_token</span>
    <span class="no">SecureRandom</span><span class="p">.</span><span class="nf">urlsafe_base64</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">User</span><span class="o">.</span><span class="nf">hash</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
    <span class="no">Digest</span><span class="o">::</span><span class="no">SHA1</span><span class="p">.</span><span class="nf">hexdigest</span><span class="p">(</span><span class="n">token</span><span class="p">.</span><span class="nf">to_s</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="kp">private</span>

    <span class="k">def</span> <span class="nf">create_remember_token</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">remember_token</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">hash</span><span class="p">(</span><span class="no">User</span><span class="p">.</span><span class="nf">new_remember_token</span><span class="p">)</span>
    <span class="k">end</span>
</pre></div>
</div>
<p>Active Record 是把模型的属性和数据库表中的列对应的，如果不指定 <code>self</code> 的话，我们就只是创建了一个名为 <code>remember_token</code> 的局部变量而已，这可不是我们期望得到的结果。加上 <code>self</code> 之后，赋值操作就会把值赋值给用户的 <code>remember_token</code> 属性，保存用户时，随着其他的属性一起存入数据库。（现在你知道了为什么代码 6.20 中的 <code>before_save</code> 为什么要用 <code>self.name</code> 而不直接用 <code>email</code>。）</p>

<p>注意，我们使用 <a href="https://en.wikipedia.org/wiki/SHA-1">SHA1</a> 加密了记忆权标。这种哈希算法比 <a href="chapter6.html#section-6-3-1">6.3.1 节</a>中用来加密用户密码的 Bcrypt 速度快得多。之所以看中速度，是因为对登入的用户来说，每个页面都会加密记忆权标（参加<a href="chapter8.html#section-8-2-2">8.2.2 节</a>）。SHA1 的安全性不如 Bcrypt，但能满足现在的需求，加密后的记忆权标是 16 位随机字符，基本无法破解。（上述代码之所以调用 <code>to_s</code>，是为了处理输入为 <code>nil</code> 的情况，在浏览器中不会遇到，测试时偶尔会出现。）</p>

<p><code>hash</code> 和 <code>new_remember_token</code> 方法定义在 <code>User</code> 类中，因为二者无需用户实例就可使用<sup class="footnote" id="fnref-8-6"><a href="#fn-8-6" rel="footnote">6</a></sup>，而且还是公开方法（位于 <code>private</code> 上面）。在 <a href="chapter8.html#section-8-2-3">8.2.3 节</a>中会将这两个方法剥离出 User 模型。</p>

<p>把上述的分析结合起来，最终得到的 User 模型文件如代码 8.18 所示。</p>

<div class="codeblock has-caption" id="codeblock-8-18"><p class="caption"><span>代码 8.18：</span>生成记忆权标的 <code>before_create</code> 回调函数</p><p class="file"><code>app/models/user.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">before_save</span> <span class="p">{</span> <span class="nb">self</span><span class="p">.</span><span class="nf">email</span> <span class="o">=</span> <span class="n">email</span><span class="p">.</span><span class="nf">downcase</span> <span class="p">}</span>
  <span class="n">before_create</span> <span class="p">:</span><span class="n">create_remember_token</span>
  <span class="p">.</span>
  <span class="nf">.</span>
  <span class="p">.</span>
  <span class="nf">def</span> <span class="no">User</span><span class="p">.</span><span class="nf">new_remember_token</span>
    <span class="no">SecureRandom</span><span class="p">.</span><span class="nf">urlsafe_base64</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">User</span><span class="o">.</span><span class="nf">hash</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
    <span class="no">Digest</span><span class="o">::</span><span class="no">SHA1</span><span class="p">.</span><span class="nf">hexdigest</span><span class="p">(</span><span class="n">token</span><span class="p">.</span><span class="nf">to_s</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="kp">private</span>

    <span class="k">def</span> <span class="nf">create_remember_token</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">remember_token</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">hash</span><span class="p">(</span><span class="no">User</span><span class="p">.</span><span class="nf">new_remember_token</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>顺便说一下，我们为 <code>create_remember_token</code> 方法增加了一层缩进，这样可以更好的突出这些方法是在 <code>private</code> 之后定义的。（经验表明，这样做是明智地。）<sup class="footnote" id="fnref-8-t3"><a href="#fn-8-t3" rel="footnote">7</a></sup></p>

<p>因为加密后的 <code>SecureRandom.urlsafe_base64</code> 方法创建的字符串不可能为空值，所以对 User 模型的测试现在应该可以通过了：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>bundle <span class="nb">exec </span>rspec spec/models/user_spec.rb
</pre></div>
</div>
<h3 id='section-8-2-2'><span>8.2.2</span> 定义 sign_in 方法</h3>


<p>本小节我们要开始实现登录功能了，首先来定义 <code>sign_in</code> 方法。上一小节已经说明了，我们计划实现的身份验证方式是，在用户的浏览器中存储记忆权标，在网站的页面与页面之间通过这个记忆权标获取数据库中的用户记录（会在 <a href="chapter8.html#section-8-2-3">8.2.3 节</a>实现）。实现这一设想所需的代码如代码 8.19 所示，这段代码使用了 <code>current_user</code> 方法，会在 <a href="chapter8.html#section-8-2-3">8.2.3 节</a>中定义。</p>

<div class="codeblock has-caption" id="codeblock-8-19"><p class="caption"><span>代码 8.19：</span>完整但还不能正常使用的 <code>sign_in</code> 方法</p><p class="file"><code>app/helpers/sessions_helper.rb</code></p><div class="highlight type-ruby"><pre><span class="k">module</span> <span class="nn">SessionsHelper</span>

  <span class="k">def</span> <span class="nf">sign_in</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="n">remember_token</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">new_remember_token</span>
    <span class="n">cookies</span><span class="p">.</span><span class="nf">permanent</span><span class="p">[</span><span class="ss">:remember_token</span><span class="p">]</span> <span class="o">=</span> <span class="n">remember_token</span>
    <span class="n">user</span><span class="p">.</span><span class="nf">update_attribute</span><span class="p">(</span><span class="ss">:remember_token</span><span class="p">,</span> <span class="no">User</span><span class="p">.</span><span class="nf">hash</span><span class="p">(</span><span class="n">remember_token</span><span class="p">))</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">current_user</span> <span class="o">=</span> <span class="n">user</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>上述代码遵照了设定的步骤：首先，创建新权标；随后，把未加密的权标存入浏览器的 cookie；然后，把加密后的权标存入数据库；最后，把制定的用户设为当前登入的用户。我们会在 <a href="chapter8.html#section-8-2-3">8.2.3 节</a>中看到，现在并不一定要把 <code>user</code> 指定为当前用户，因为 <code>create</code> 动作完成后回立即转向（代码 8.13）。不过指定也好，防止无需转向的登录操作。</p>

<p>注意，保存记忆权标使用的是 <code>update_attribute</code> 方法，这样可以跳过数据验证更新单个属性。我们必须用这个方法，因为我们无法提供用户的密码及密码确认。代码 8.19 中用到的 <code>cookies</code> 方法是由 Rails 提供的，我们可以把它看成 Hash，其中每个元素又都是一个 Hash，包含两个元素，<code>value</code> 指定 cookie 的文本，<code>expires</code> 指定 cookie 的失效日期。例如，我们可以使用下述代码实现登录功能，把 cookie 的值设为用户的记忆权标，失效日期设为 20 年之后：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">cookies</span><span class="p">[</span><span class="ss">:remember_token</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">value:   </span><span class="n">remember_token</span><span class="p">,</span>
                             <span class="ss">expires: </span><span class="mi">20</span><span class="p">.</span><span class="nf">years</span><span class="p">.</span><span class="nf">from_now</span><span class="p">.</span><span class="nf">utc</span> <span class="p">}</span>
</pre></div>
</div>
<p>（这里使用了 Rails 提供的时间帮助方法，详情参见<a href="chapter8.html#aside-8-1">旁注 8.1</a>。）</p>

          <div class="aside box" id="aside-8-1">
  <h4><span>旁注 8.1：</span>cookie 在 20.years.from_now 之后失效</h4>

  <p>在 <a href="chapter4.html#section-4-4-2">4.4.2 节</a>中介绍过，你可以向任何的 Ruby 类，甚至是内置的类中添加自定义的方法，我们就向 <code>String</code> 类添加了 <code>palindrome?</code> 方法（而且还发现了 <code>"deified"</code> 是回文）。我们还介绍过，Rails 为 <code>Object</code> 类添加了 <code>blank?</code> 方法（所以，<code>"".blank?</code>、<code>" ".blank?</code> 和 <code>nil.blank?</code> 的返回值都是 <code>true</code>）。代码 8.19 中处理 cookie 的代码又是一例，使用了 Rails 提供的时间帮助方法，这些方法是添加到 <code>Fixnum</code> 类（数字的基类）中的。</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>rails console
<span class="gp">&gt;&gt; </span>1.year.from_now
<span class="gp">=&gt; </span>Sun, 13 Mar 2011 03:38:55 UTC +00:00
<span class="gp">&gt;&gt; </span>10.weeks.ago
<span class="gp">=&gt; </span>Sat, 02 Jan 2010 03:39:14 UTC +00:00
</pre></div>
</div>
  <p>Rails 还添加了其他的帮助函数，如：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>1.kilobyte
<span class="gp">=&gt; </span>1024
<span class="gp">&gt;&gt; </span>5.megabytes
<span class="gp">=&gt; </span>5242880
</pre></div>
</div>
  <p>这几个帮助函数可用于限制上传文件的大小，例如，图片最大不超过 <code>5.megabytes</code>。</p>

  <p>这种为内置类添加方法的特性很灵便，可以扩展 Ruby 的功能，不过使用时要小心一些。其实 Rails 的很多优雅之处正式基于 Ruby 语言的这一特性。</p>
</div>


<p>因为开发者经常要把 cookie 的失效日期设为 20 年后，所以 Rails 特别提供了 <code>permanent</code> 方法，前面处理 cookie 的代码可以改写成：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">cookies</span><span class="p">.</span><span class="nf">permanent</span><span class="p">[</span><span class="ss">:remember_token</span><span class="p">]</span> <span class="o">=</span> <span class="n">remember_token</span>
</pre></div>
</div>
<p>Rails 的 <code>permanent</code> 方法会自动把 cookie 的失效日期设为 20 年后。</p>

<p>设定了 cookie 之后，在网页中我们就可以使用下面的代码取回用户：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="no">User</span><span class="p">.</span><span class="nf">find_by</span><span class="p">(</span><span class="ss">remember_token: </span><span class="n">remember_token</span><span class="p">)</span>
</pre></div>
</div>
<p>其实浏览器中保存的 cookie 并不是 Hash，赋值给 <code>cookies</code> 只是把值以文本的形式保存在浏览器中。这正体现了 Rails 的智能，我们无需关心具体的处理细节，专注地实现应用程序的功能。</p>

<h3 id='section-8-2-3'><span>8.2.3</span> 获取当前用户</h3>


<p>上一小节已经介绍了如何在 cookie 中存储记忆权标以待后用，这一小节我们要看一下如何取回用户。我们先回顾一下 <code>sign_in</code> 方法：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="k">module</span> <span class="nn">SessionsHelper</span>

  <span class="k">def</span> <span class="nf">sign_in</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="n">remember_token</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">new_remember_token</span>
    <span class="n">cookies</span><span class="p">.</span><span class="nf">permanent</span><span class="p">[</span><span class="ss">:remember_token</span><span class="p">]</span> <span class="o">=</span> <span class="n">remember_token</span>
    <span class="n">user</span><span class="p">.</span><span class="nf">update_attribute</span><span class="p">(</span><span class="ss">:remember_token</span><span class="p">,</span> <span class="no">User</span><span class="p">.</span><span class="nf">hash</span><span class="p">(</span><span class="n">remember_token</span><span class="p">))</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">current_user</span> <span class="o">=</span> <span class="n">user</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>现在还无法使用的代码是：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="nb">self</span><span class="p">.</span><span class="nf">current_user</span> <span class="o">=</span> <span class="n">user</span>
</pre></div>
</div>
<p>我们在代码 8.19 后面说过，这行代码并不会真的在这个程序中使用，因为登录后会直接转向。如果 <code>sign_in</code> 方法只考虑转向一种情况也是很危险的。</p>

<p><code>current_user</code> 方法可以在控制器和视图中使用，所以你既可以这样用：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="o">&lt;</span><span class="sx">%= current_user.name %&gt;
</span></pre></div>
</div>
<p>也可以这样用：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">redirect_to</span> <span class="n">current_user</span>
</pre></div>
</div>
<p>这行代码中的 <code>self</code> 也是必须的，原因在分析代码 8.18 时已经说过，如果没有 <code>self</code>，Ruby 只是定义了一个名为 <code>current_user</code> 的局部变量。</p>

<p>在开始编写 <code>current_user</code> 方法的代码之前，请仔细看这行代码：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="nb">self</span><span class="p">.</span><span class="nf">current_user</span> <span class="o">=</span> <span class="n">user</span>
</pre></div>
</div>
<p>这是一个赋值操作，我们必须先定义相应的方法才能这么用。Ruby 为这种赋值操作提供了一种特别的定义方式，如代码 8.20 所示。</p>

<div class="codeblock has-caption" id="codeblock-8-20"><p class="caption"><span>代码 8.20：</span>实现 <code>current_user</code> 方法对应的赋值操作</p><p class="file"><code>app/helpers/sessions_helper.rb</code></p><div class="highlight type-ruby"><pre><span class="k">module</span> <span class="nn">SessionsHelper</span>

  <span class="k">def</span> <span class="nf">sign_in</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="p">.</span>
    <span class="nf">.</span>
    <span class="p">.</span>
  <span class="nf">end</span>

  <span class="k">def</span> <span class="nf">current_user</span><span class="o">=</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="vi">@current_user</span> <span class="o">=</span> <span class="n">user</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>这段代码看起来很奇怪，因为大多数的编程语言并不允许在方法名中使用等号。其实这段代码定义的 <code>current_user=</code> 方法是用来处理 <code>current_user</code> 赋值操作的。也就是说，如下的代码</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="nb">self</span><span class="p">.</span><span class="nf">current_user</span> <span class="o">=</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span>
</pre></div>
</div>
<p>会自动转换成下面这种形式</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">current_user</span><span class="o">=</span><span class="p">(.</span><span class="nf">.</span><span class="o">.</span><span class="p">)</span>
</pre></div>
</div>
<p>就是直接调用 <code>current_user=</code> 方法，接受的参数是赋值语句右侧的值，本例中是要登录的用户对象。<code>current_user=</code> 方法定义体内只有一行代码，即设定实例变量 <code>@current_user</code> 的值，以备后用。</p>

<p>在常见的 Ruby 代码中，我们还会定义 <code>current_user</code> 方法，用来读取 <code>@current_user</code> 的值，如代码 8.21 所示。</p>

<div class="codeblock has-caption" id="codeblock-8-21"><p class="caption"><span>代码 8.21：</span>尝试定义 <code>current_user</code> 方法，不过我们不会使用这种方式</p><div class="highlight type-ruby"><pre><span class="k">module</span> <span class="nn">SessionsHelper</span>

  <span class="k">def</span> <span class="nf">sign_in</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="p">.</span>
    <span class="nf">.</span>
    <span class="p">.</span>
  <span class="nf">end</span>

  <span class="k">def</span> <span class="nf">current_user</span><span class="o">=</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="vi">@current_user</span> <span class="o">=</span> <span class="n">user</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">current_user</span>
    <span class="vi">@current_user</span> <span class="c1"># Useless! Don't use this line.</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>上面的做法其实就是实现了 <code>attr_accessor</code> 方法的功能（<a href="chapter4.html#section-4-4-5">4.4.5 节</a>介绍过）。<sup class="footnote" id="fnref-8-5"><a href="#fn-8-5" rel="footnote">8</a></sup>如果按照代码 8.21 来定义 <code>current_user</code> 方法，会出现一个问题：程序不会记住用户的登录状态。一旦用户转到其他的页面，session 就失效了，会自动退出。若要避免这个问题，我们要使用代码 8.19 中生成的记忆权标查找用户，如代码 8.22 所示。注意，因为数据库中保存的记忆权标是加密的，所以在用来查找用户之前要加密从 cookie 中读取的权标。我们可以使用代码 8.18 中定义的 <code>User.hash</code> 方法加密。</p>

<div class="codeblock has-caption" id="codeblock-8-22"><p class="caption"><span>代码 8.22：</span>通过记忆权标查找当前用户</p><p class="file"><code>app/helpers/sessions_helper.rb</code></p><div class="highlight type-ruby"><pre><span class="k">module</span> <span class="nn">SessionsHelper</span>
  <span class="p">.</span>
  <span class="nf">.</span>
  <span class="p">.</span>
  <span class="nf">def</span> <span class="n">current_user</span><span class="o">=</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="vi">@current_user</span> <span class="o">=</span> <span class="n">user</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">current_user</span>
    <span class="n">remember_token</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">hash</span><span class="p">(</span><span class="n">cookies</span><span class="p">[</span><span class="ss">:remember_token</span><span class="p">])</span>
    <span class="vi">@current_user</span> <span class="o">||=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find_by</span><span class="p">(</span><span class="ss">remember_token: </span><span class="n">remember_token</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>代码 8.22 中使用了一个常见但不是很容易理解的 <code>||=</code>（“or equals”）操作符（<a href="chapter8.html#aside-8-2">旁注 8.2</a>中有详细介绍）。使用这个操作符之后，当且仅当 <code>@current_user</code> 未定义时才会把通过记忆权标获取的用户赋值给实例变量 <code>@current_user</code>。<sup class="footnote" id="fnref-8-8"><a href="#fn-8-8" rel="footnote">9</a></sup>也就是说，如下的代码</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="vi">@current_user</span> <span class="o">||=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find_by</span><span class="p">(</span><span class="ss">remember_token: </span><span class="n">remember_token</span><span class="p">)</span>
</pre></div>
</div>
<p>只在第一次调用 <code>current_user</code> 方法时调用 <code>find_by</code> 方法，如果后续再调用的话就直接返回 <code>@current_user</code> 的值，而不必再查询数据库。<sup class="footnote" id="fnref-8-7"><a href="#fn-8-7" rel="footnote">10</a></sup>这种方式的优点只有当在一个请求中多次调用 <code>current_user</code> 方法时才能显现。不管怎样，只要用户访问了相应的页面，<code>find_by</code> 方法都至少会执行一次。</p>

          <div class="aside box" id="aside-8-2">
  <h4><span>旁注 8.2：</span>||= 操作符简介</h4>

  <p><code>||=</code> 操作符非常能够体现 Ruby 的特性，如果你打算长期进行 Ruby 编程的话就要好好学习它的用法。初学时会觉得 <code>||=</code> 很神秘，不过通过和其他操作符类比之后，你会发现也不是很难理解。</p>

  <p>我们先来看一下改变已经定义的变量时经常使用的结构。在很多程序中都会把变量自增一，如下所示</p>

<div class="codeblock"><div class="highlight type-plaintext"><pre>x = x + 1
</pre></div>
</div>
  <p>大多数语言都为这种操作提供了简化的操作符，在 Ruby 中，可以按照下面的方式重写（C、C++、Perl、Python、Java 等也如此）：</p>

<div class="codeblock"><div class="highlight type-plaintext"><pre>x += 1
</pre></div>
</div>
  <p>其他操作符也有类似的简化形式：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>rails console
<span class="gp">&gt;&gt; </span>x <span class="o">=</span> 1
<span class="gp">=&gt; </span>1
<span class="gp">&gt;&gt; </span>x +<span class="o">=</span> 1
<span class="gp">=&gt; </span>2
<span class="gp">&gt;&gt; </span>x <span class="k">*</span><span class="o">=</span> 3
<span class="gp">=&gt; </span>6
<span class="gp">&gt;&gt; </span>x -<span class="o">=</span> 7
<span class="gp">=&gt; </span>-1
</pre></div>
</div>
  <p>上面的举例可以概括为，<code>x = x O y</code> 和 <code>x O=y</code> 是等效的，其中 <code>O</code> 表示操作符。</p>

  <p>在 Ruby 中还经常会遇到这种情况，如果变量的值为 <code>nil</code> 则赋予其他的值，否则就不改变这个变量的值。<a href="chapter4.html#section-4-2-3">4.2.3 节</a> 中介绍过 <code>||</code> 或操作符，所以这种情况可以用如下的代码表示：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>@user
<span class="gp">=&gt; </span>nil
<span class="gp">&gt;&gt; </span>@user <span class="o">=</span> @user <span class="o">||</span> <span class="s2">"the user"</span>
<span class="gp">=&gt; </span><span class="s2">"the user"</span>
<span class="gp">&gt;&gt; </span>@user <span class="o">=</span> @user <span class="o">||</span> <span class="s2">"another user"</span>
<span class="gp">=&gt; </span><span class="s2">"the user"</span>
</pre></div>
</div>
  <p>因为 <code>nil</code> 表示的布尔值是 <code>false</code>，所以第一个赋值操作等同于 <code>nil || "the user"</code>，这个语句的计算结果是 <code>"the user"</code>；类似的，第二个赋值操作等同于 <code>"the user" || "another user"</code>，这个语句的计算结果还是 <code>"the user"</code>，因为 <code>"the user"</code> 表示的布尔值是 <code>true</code>，这个或操作在执行了第一个表达式之后就终止了。（或操作的执行顺序是从左至右，只要出现真值就会终止语句的执行，这种方式称作“短路计算（short-circuit evaluation）”。）</p>

  <p>和上面的控制台会话对比之后，我们可以发现 <code>@user = @user || value</code> 符合 <code>x = x O y</code> 的形式，只需把 <code>O</code> 换成 <code>||</code>，所以就得到了下面这种简写形式：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>@user <span class="o">||=</span> <span class="s2">"the user"</span>
<span class="gp">=&gt; </span><span class="s2">"the user"</span>
</pre></div>
</div>  <p>不难理解吧！<sup class="footnote" id="fnref-8-t2"><a href="#fn-8-t2" rel="footnote">11</a></sup></p>

</div>


<h3 id='section-8-2-4'><span>8.2.4</span> 改变导航链接</h3>


<p>本小节我们要完成的是实现登录、退出功能的最后一步，根据登录状态改变布局中的导航链接。如图 8.3 所示，我们要在登录和退出后显示不同的导航，要添加指向列出所有用户页面的链接、到用户设置页面的链接（<a href="chapter9.html">第 9 章</a>加入），还有到当前登录用户资料页面的链接。加入这些链接之后，代码 8.6 中的测试就可以通过了，这是本章目前为止测试首次变绿通过。</p>

<p>在网站的布局中改变导航链接需要用到 ERb 的 if-else 分支结构：</p>

<div class="codeblock"><div class="highlight type-erb"><pre><span class="cp">&lt;%</span> <span class="k">if</span> <span class="n">signed_in?</span> <span class="cp">%&gt;</span>
# Links for signed-in users
<span class="cp">&lt;%</span> <span class="k">else</span> <span class="cp">%&gt;</span>
# Links for non-signed-in-users
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</pre></div>
</div>
<p>若要上述代码起作用，先要用 <code>signed_in?</code> 方法。我们现在就来定义。</p>

<p>如果 session 中存有当前用户的话，就可以说用户已经登录了。我们要判断 <code>current_user</code> 的值是不是 <code>nil</code>，这里需要用到取反操作符，用感叹号 ! 表示，一般读作“bang”。只要 <code>current_user</code> 的值不是 <code>nil</code>，就说明用户登录了，如代码 8.23 所示。</p>

<div class="codeblock has-caption" id="codeblock-8-23"><p class="caption"><span>代码 8.23：</span>定义 <code>signed_in?</code> 帮助方法</p><p class="file"><code>app/helpers/sessions_helper.rb</code></p><div class="highlight type-ruby"><pre><span class="k">module</span> <span class="nn">SessionsHelper</span>

  <span class="k">def</span> <span class="nf">sign_in</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="n">remember_token</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">new_remember_token</span>
    <span class="n">cookies</span><span class="p">.</span><span class="nf">permanent</span><span class="p">[</span><span class="ss">:remember_token</span><span class="p">]</span> <span class="o">=</span> <span class="n">remember_token</span>
    <span class="n">user</span><span class="p">.</span><span class="nf">update_attribute</span><span class="p">(</span><span class="ss">:remember_token</span><span class="p">,</span> <span class="no">User</span><span class="p">.</span><span class="nf">hash</span><span class="p">(</span><span class="n">remember_token</span><span class="p">))</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">current_user</span> <span class="o">=</span> <span class="n">user</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">signed_in?</span>
    <span class="o">!</span><span class="n">current_user</span><span class="p">.</span><span class="nf">nil?</span>
  <span class="k">end</span>
  <span class="p">.</span>
  <span class="nf">.</span>
  <span class="p">.</span>
<span class="nf">end</span>
</pre></div>
</div>
<p>定义了 <code>signed_in?</code> 方法后就可以着手修改布局中的导航了。我们要添加四个新链接，其中两个链接的地址先不填（<a href="chapter9.html">第 9 章</a>再填）：</p>

<div class="codeblock"><div class="highlight type-erb"><pre><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Users"</span><span class="p">,</span> <span class="s1">'#'</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Settings"</span><span class="p">,</span> <span class="s1">'#'</span> <span class="cp">%&gt;</span>
</pre></div>
</div>
<p>退出链接的地址使用代码 8.2 中定义的 <code>signout_path</code>：</p>

<div class="codeblock"><div class="highlight type-erb"><pre><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Sign out"</span><span class="p">,</span> <span class="n">signout_path</span><span class="p">,</span> <span class="ss">method: </span><span class="s2">"delete"</span> <span class="cp">%&gt;</span>
</pre></div>
</div>
<p>（注意，我们还为退出链接指定了类型为 Hash 的参数，指明点击链接后发送的是 HTTP <code>DELETE</code> 请求。<sup class="footnote" id="fnref-8-9"><a href="#fn-8-9" rel="footnote">12</a></sup>）最后，我们还要添加一个到资料页面的链接：</p>

<div class="codeblock"><div class="highlight type-erb"><pre><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Profile"</span><span class="p">,</span> <span class="n">current_user</span> <span class="cp">%&gt;</span>
</pre></div>
</div>
<p>这个链接我们本可以写成</p>

<div class="codeblock"><div class="highlight type-erb"><pre><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Profile"</span><span class="p">,</span> <span class="n">user_path</span><span class="p">(</span><span class="n">current_user</span><span class="p">)</span> <span class="cp">%&gt;</span>
</pre></div>
</div>
<p>不过我们可以直接把链接地址设为 <code>current_user</code>，Rails 会自动将其转换成 <code>user_path(current_user)</code>。</p>

<p>在添加导航链接的过程中，我们还要使用 Bootstrap 实现下拉菜单的效果，具体的实现方式可以参阅 Bootstrap 的文档。添加导航链接所需的代码如代码 8.24 所示。注意其中和 Bootstrap 下拉菜单有关的 CSS id 和 class。</p>

<div class="codeblock has-caption" id="codeblock-8-24"><p class="caption"><span>代码 8.24：</span>根据登录状态改变导航链接</p><p class="file"><code>app/views/layouts/_header.html.erb</code></p><div class="highlight type-erb"><pre><span class="nt">&lt;header</span> <span class="na">class=</span><span class="s">"navbar navbar-fixed-top navbar-inverse"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"navbar-inner"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"container"</span><span class="nt">&gt;</span>
      <span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"sample app"</span><span class="p">,</span> <span class="n">root_path</span><span class="p">,</span> <span class="ss">id: </span><span class="s2">"logo"</span> <span class="cp">%&gt;</span>
      <span class="nt">&lt;nav&gt;</span>
        <span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">"nav pull-right"</span><span class="nt">&gt;</span>
          <span class="nt">&lt;li&gt;</span><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Home"</span><span class="p">,</span> <span class="n">root_path</span> <span class="cp">%&gt;</span><span class="nt">&lt;/li&gt;</span>
          <span class="nt">&lt;li&gt;</span><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Help"</span><span class="p">,</span> <span class="n">help_path</span> <span class="cp">%&gt;</span><span class="nt">&lt;/li&gt;</span>
          <span class="cp">&lt;%</span> <span class="k">if</span> <span class="n">signed_in?</span> <span class="cp">%&gt;</span>
            <span class="nt">&lt;li&gt;</span><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Users"</span><span class="p">,</span> <span class="s1">'#'</span> <span class="cp">%&gt;</span><span class="nt">&lt;/li&gt;</span>
            <span class="nt">&lt;li</span> <span class="na">id=</span><span class="s">"fat-menu"</span> <span class="na">class=</span><span class="s">"dropdown"</span><span class="nt">&gt;</span>
              <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"#"</span> <span class="na">class=</span><span class="s">"dropdown-toggle"</span> <span class="na">data-toggle=</span><span class="s">"dropdown"</span><span class="nt">&gt;</span>
                Account <span class="nt">&lt;b</span> <span class="na">class=</span><span class="s">"caret"</span><span class="nt">&gt;&lt;/b&gt;</span>
              <span class="nt">&lt;/a&gt;</span>
              <span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">"dropdown-menu"</span><span class="nt">&gt;</span>
                <span class="nt">&lt;li&gt;</span><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Profile"</span><span class="p">,</span> <span class="n">current_user</span> <span class="cp">%&gt;</span><span class="nt">&lt;/li&gt;</span>
                <span class="nt">&lt;li&gt;</span><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Settings"</span><span class="p">,</span> <span class="s1">'#'</span> <span class="cp">%&gt;</span><span class="nt">&lt;/li&gt;</span>
                <span class="nt">&lt;li</span> <span class="na">class=</span><span class="s">"divider"</span><span class="nt">&gt;&lt;/li&gt;</span>
                <span class="nt">&lt;li&gt;</span>
                  <span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Sign out"</span><span class="p">,</span> <span class="n">signout_path</span><span class="p">,</span> <span class="ss">method: </span><span class="s2">"delete"</span> <span class="cp">%&gt;</span>
                <span class="nt">&lt;/li&gt;</span>
              <span class="nt">&lt;/ul&gt;</span>
            <span class="nt">&lt;/li&gt;</span>
          <span class="cp">&lt;%</span> <span class="k">else</span> <span class="cp">%&gt;</span>
            <span class="nt">&lt;li&gt;</span><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Sign in"</span><span class="p">,</span> <span class="n">signin_path</span> <span class="cp">%&gt;</span><span class="nt">&lt;/li&gt;</span>
          <span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
        <span class="nt">&lt;/ul&gt;</span>
      <span class="nt">&lt;/nav&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
  <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/header&gt;</span>
</pre></div>
</div>
<p>实现下拉菜单还要用到 Bootstrap 中的 JavaScript 代码，我们可以编辑应用程序的 JavaScript 文件，通过 asset pipeline 引入所需的文件，如代码 8.25 所示。</p>

<div class="figure" id="figure-8-9">
  <img src="figures/profile_with_signout_link_bootstrap.png" alt="profile with signout link bootstrap" />
  <p class="caption"><span>图 8.9：</span>登录后显示了新链接和下拉菜单</p>
</div>
<div class="codeblock has-caption" id="codeblock-8-25"><p class="caption"><span>代码 8.25：</span>把 Bootstrap 的 JavaScript 代码加入 <code>application.js</code></p><p class="file"><code>app/assets/javascripts/application.js</code></p><div class="highlight type-javascript"><pre><span class="c1">//= require jquery</span>
<span class="c1">//= require jquery_ujs</span>
<span class="c1">//= require bootstrap</span>
<span class="c1">//= require turbolinks</span>
<span class="c1">//= require_tree .</span>
</pre></div>
</div>
<p>引入文件的功能是由 Sprockets 实现的，而文件本身是由 <a href="chapter5.html#section-5-1-2">5.1.2 节</a>中添加的 <code>bootstrap-sass</code> gem 提供的。</p>

<p>添加了代码 8.24 之后，所有的测试应该都可以通过了：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>bundle <span class="nb">exec </span>rspec spec/
</pre></div>
</div>
<p>现在登入的用户就可以看到代码 8.24 新添加的链接和下拉菜单了，如图 8.9 所示。</p>

<p>现在你可以验证一下是否可以登录，然后关闭浏览器，再打开看一下是否还是登入的状态。如果需要，你还可以直接查看浏览器的 cookies，如图 8.10 所示。</p>

<div class="figure" id="figure-8-10">
  <img src="figures/cookie_in_browser.png" alt="cookie in browser" />
  <p class="caption"><span>图 8.10：</span>查看浏览器中的记忆权标 cookie</p>
</div>
<h3 id='section-8-2-5'><span>8.2.5</span> 注册后直接登录</h3>


<p>虽然现在基本完成了用户身份验证功能，但是新注册的用户可能还是会困惑，为什么注册后没有登录呢。在实现退出功能之前，我们还要实现注册后直接登录的功能。我们要先编写测试，在身份验证的测试中加入一行代码，如代码 8.26 所示。这段代码要用到<a href="chapter7.html">第 7 章</a>一个练习中的“after saving the user” <code>describe</code> 块（参见代码 7.32），如果之前你没有做这个练习的话，现在请添加相应的测试代码。</p>

<div class="codeblock has-caption" id="codeblock-8-26"><p class="caption"><span>代码 8.26：</span>测试刚注册的用户是否会自动登录</p><p class="file"><code>spec/requests/user_pages_spec.rb</code></p><div class="highlight type-ruby"><pre><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="s2">"User pages"</span> <span class="k">do</span>
    <span class="p">.</span>
    <span class="nf">.</span>
    <span class="p">.</span>
    <span class="nf">describe</span> <span class="s2">"with valid information"</span> <span class="k">do</span>
      <span class="p">.</span>
      <span class="nf">.</span>
      <span class="p">.</span>
      <span class="nf">describe</span> <span class="s2">"after saving the user"</span> <span class="k">do</span>
        <span class="n">before</span> <span class="p">{</span> <span class="n">click_button</span> <span class="n">submit</span> <span class="p">}</span>
        <span class="n">let</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span> <span class="p">{</span> <span class="no">User</span><span class="p">.</span><span class="nf">find_by</span><span class="p">(</span><span class="ss">email: </span><span class="s1">'user@example.com'</span><span class="p">)</span> <span class="p">}</span>

        <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">have_link</span><span class="p">(</span><span class="s1">'Sign out'</span><span class="p">)</span> <span class="p">}</span>
        <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">have_title</span><span class="p">(</span><span class="n">user</span><span class="p">.</span><span class="nf">name</span><span class="p">)</span> <span class="p">}</span>
        <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">have_selector</span><span class="p">(</span><span class="s1">'div.alert.alert-success'</span><span class="p">,</span> <span class="ss">text: </span><span class="s1">'Welcome'</span><span class="p">)</span> <span class="p">}</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>我们检测页面中有没有退出链接，来验证用户注册后是否登录了。</p>

<p>有了 <a href="chapter8.html#section-8-2">8.2 节</a>中定义的 <code>sign_in</code> 方法，要让这个测试通过就很简单了：在用户保存到数据库中之后加上 <code>sign_in @user</code> 就可以了，如代码 8.27 所示。</p>

<div class="codeblock has-caption" id="codeblock-8-27"><p class="caption"><span>代码 8.27：</span>用户注册后直接登录</p><p class="file"><code>app/controllers/users_controller.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">UsersController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="p">.</span>
  <span class="nf">.</span>
  <span class="p">.</span>
  <span class="nf">def</span> <span class="n">create</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">user_params</span><span class="p">)</span>
    <span class="k">if</span> <span class="vi">@user</span><span class="p">.</span><span class="nf">save</span>
      <span class="n">sign_in</span> <span class="vi">@user</span>
      <span class="n">flash</span><span class="p">[</span><span class="ss">:success</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"Welcome to the Sample App!"</span>
      <span class="n">redirect_to</span> <span class="vi">@user</span>
    <span class="k">else</span>
      <span class="n">render</span> <span class="s1">'new'</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="p">.</span>
  <span class="nf">.</span>
  <span class="p">.</span>
<span class="nf">end</span>
</pre></div>
</div>
<h3 id='section-8-2-6'><span>8.2.6</span> 退出</h3>


<p>在 <a href="chapter8.html#section-8-1">8.1 节</a>中介绍过，我们要实现的身份验证机制会记住用户的登录状态，直到用户点击退出链接为止。本小节，我们就要实现退出功能。</p>

<p>目前为止，Sessions 控制器的动作完全遵从了 REST 架构，<code>new</code> 动作用于登录页面，<code>create</code> 动作实现登录的过程。我们还要添加一个 <code>destroy</code> 动作，删除 session，实现退出功能。针对退出功能的测试，我们可以检测点击退出链接后，页面中是否有登录链接，如代码 8.28 所示。</p>

<div class="codeblock has-caption" id="codeblock-8-28"><p class="caption"><span>代码 8.28：</span>测试用户退出</p><p class="file"><code>spec/requests/authentication_pages_spec.rb</code></p><div class="highlight type-ruby"><pre><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="s2">"Authentication"</span> <span class="k">do</span>
  <span class="p">.</span>
  <span class="nf">.</span>
  <span class="p">.</span>
  <span class="nf">describe</span> <span class="s2">"signin"</span> <span class="k">do</span>
    <span class="p">.</span>
    <span class="nf">.</span>
    <span class="p">.</span>
    <span class="nf">describe</span> <span class="s2">"with valid information"</span> <span class="k">do</span>
      <span class="p">.</span>
      <span class="nf">.</span>
      <span class="p">.</span>
      <span class="nf">describe</span> <span class="s2">"followed by signout"</span> <span class="k">do</span>
        <span class="n">before</span> <span class="p">{</span> <span class="n">click_link</span> <span class="s2">"Sign out"</span> <span class="p">}</span>
        <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">have_link</span><span class="p">(</span><span class="s1">'Sign in'</span><span class="p">)</span> <span class="p">}</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>登录功能是由 <code>sign_in</code> 方法实现的，对应的，我们会使用 <code>sign_out</code> 方法实现退出功能，如代码 8.29 所示。</p>

<div class="codeblock has-caption" id="codeblock-8-29"><p class="caption"><span>代码 8.29：</span>销毁 session，实现退出功能</p><p class="file"><code>app/controllers/sessions_controller.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">SessionsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="p">.</span>
  <span class="nf">.</span>
  <span class="p">.</span>
  <span class="nf">def</span> <span class="n">destroy</span>
    <span class="n">sign_out</span>
    <span class="n">redirect_to</span> <span class="n">root_path</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>和其他身份验证相关的方法一样，我们会在 Sessions 控制器的帮助方法模块中定义 <code>sign_out</code> 方法。具体的定义如代码 8.30 所示：先修改数据库中保存的记忆权标，以防 cookie 被窃取用来验证用户；然后在 cookies 上调用 <code>delete</code> 方法从 session 中删除记忆权标；最后一行代码是可选的，把当前用户设为 <code>nil</code>。（其实这里没必要把当前用户设为 <code>nil</code>，因为在 <code>destroy</code> 动作中我们加入了转向操作。这里我们之所以这么做是为了兼容不转向的退出操作。）</p>

<div class="codeblock has-caption" id="codeblock-8-30"><p class="caption"><span>代码 8.30：</span>Sessions 帮助方法模块中定义的 <code>sign_out</code> 方法</p><p class="file"><code>app/helpers/sessions_helper.rb</code></p><div class="highlight type-ruby"><pre><span class="k">module</span> <span class="nn">SessionsHelper</span>

  <span class="k">def</span> <span class="nf">sign_in</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="n">remember_token</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">new_remember_token</span>
    <span class="n">cookies</span><span class="p">.</span><span class="nf">permanent</span><span class="p">[</span><span class="ss">:remember_token</span><span class="p">]</span> <span class="o">=</span> <span class="n">remember_token</span>
    <span class="n">user</span><span class="p">.</span><span class="nf">update_attribute</span><span class="p">(</span><span class="ss">:remember_token</span><span class="p">,</span> <span class="no">User</span><span class="p">.</span><span class="nf">hash</span><span class="p">(</span><span class="n">remember_token</span><span class="p">))</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">current_user</span> <span class="o">=</span> <span class="n">user</span>
  <span class="k">end</span>
  <span class="p">.</span>
  <span class="nf">.</span>
  <span class="p">.</span>
  <span class="nf">def</span> <span class="n">sign_out</span>
    <span class="n">current_user</span><span class="p">.</span><span class="nf">update_attribute</span><span class="p">(</span><span class="ss">:remember_token</span><span class="p">,</span>
                                  <span class="no">User</span><span class="p">.</span><span class="nf">hash</span><span class="p">(</span><span class="no">User</span><span class="p">.</span><span class="nf">new_remember_token</span><span class="p">))</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">current_user</span> <span class="o">=</span> <span class="kp">nil</span>
    <span class="n">cookies</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="ss">:remember_token</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>现在，注册、登录和退出三个功能都实现了，测试也应该可以通过了：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>bundle <span class="nb">exec </span>rspec spec/
</pre></div>
</div>
<p>有一点需要注意，我们的测试覆盖了身份验证机制的大多数功能，但不是全部。例如，我们没有测试“记住我”到底记住了多久，也没测试是否设置了记忆权标。我们当然可以加入这些测试，不过经验告诉我们，直接测试 cookie 的值不可靠，而且要依赖具体的实现细节，而实现的方法在不同的 Rails 版本中可能会有所不同，即便应用程序可以使用，测试却会失败。所以我们只关注抽象的功能（验证用户是否可以登录，是否可以保持登录状态，以及是否可以退出），编写的测试没必要针对实现的细节。</p>

<h2 id='section-8-3'><span>8.3</span> Cucumber 简介（选读）</h2>


<p>前面两节基本完成了示例程序的身份验证系统，这一节我们将介绍如何使用 Cucumber 编写登录测试。Cucumber 是一个流行的行为驱动开发（Behavior-driven Development, BDD）工具，在 Ruby 社区中占据着一定的地位。本节的内容是选读的，你可以直接跳过，不会影响后续内容。</p>

<p>Cucumber 使用纯文本的故事（story）描述应用程序的行为，很多 Rails 开发者发现使用 Cucumber 处理客户案例时十分方便，因为非技术人员也能读懂这些行为描述，Cucumber 测试可以用于和客户沟通，甚至经常是由客户来编写的。当然，使用不是纯 Ruby 代码组成的测试框架有它的局限性，而且我还发现纯文本的故事很啰嗦。不管怎样，Cucumber 在 Ruby 测试工具中还是有其存在意义的，我特别欣赏它对抽象行为的关注，而不是死盯底层的具体实现。</p>

<p>因为本书着重介绍的是 RSpec 和 Capybara，所以本节对 Cucumber 的介绍很浅显，也不完整，很多内容都没做详细说明，我只是想让你体验一下如何使用 Cucumber，如果你感觉不错，可以阅读专门介绍 Cucumber 的书籍深入学习。（一般我会推荐你阅读 David Chelimsky 的《The RSpec Book》，Ryan Bigg 和 Yehuda Katz 的《Rails 3 in Action》，以及 Matt Wynne 和 Aslak Hellesøy 的《The Cucumber Book》。）</p>

<h3 id='section-8-3-1'><span>8.3.1</span> 安装和设置</h3>


<p>若要安装 Cucumber，需要在 <code>Gemfile</code> 的 <code>:test</code> 组中加入 <code>cucumber-rails</code> 和 <code>database_cleaner</code> 这两个 gem，如代码 8.31 所示。</p>

<p><strong>代码 8.31</strong> 在 <code>Gemfile</code> 中加入 <code>cucumber-rails</code></p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="p">.</span>
<span class="nf">.</span>
<span class="p">.</span>
<span class="nf">group</span> <span class="ss">:test</span> <span class="k">do</span>
  <span class="p">.</span>
  <span class="nf">.</span>
  <span class="p">.</span>
  <span class="nf">gem</span> <span class="s1">'cucumber-rails'</span><span class="p">,</span> <span class="s1">'1.4.0'</span><span class="p">,</span> <span class="ss">:require</span> <span class="o">=&gt;</span> <span class="kp">false</span>
  <span class="n">gem</span> <span class="s1">'database_cleaner'</span><span class="p">,</span> <span class="ss">github: </span><span class="s1">'bmabey/database_cleaner'</span>
<span class="k">end</span>
<span class="p">.</span>
<span class="nf">.</span>
<span class="o">.</span>
</pre></div>
</div>
<p>然后和之前一样运行一下命令安装：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>bundle install
</pre></div>
</div>
<p>如果要在程序中使用 Cucumber，我们先要生成一些所需的文件和文件夹：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>rails generate cucumber:install
</pre></div>
</div>
<p>这个命令会在根目录中创建 <code>features</code> 文件夹，Cucumber 相关的文件都会存在这个文件夹中。</p>

<h3 id='section-8-3-2'><span>8.3.2</span> 功能和步骤定义</h3>


<p>Cucumber 中的“功能（feature）”就是希望应用程序实现的行为，使用一种名为 Gherkin 的纯文本语言编写。使用 Gherkin 编写的测试和写的很好的 RSpec 测试用例差不多，不过因为 Gherkin 是纯文本，所以特别适合那些不是很懂 Ruby 代码而可以理解英语的人使用。</p>

<p>下面我们要编写一些 Cucumber 功能，实现代码 8.5 和代码 8.6 中针对登录功能的部分测试用例。首先，我们在 <code>features</code> 文件夹中新建名为 <code>signing_in.feature</code> 的文件。</p>

<p>Cucumber 的功能由一个简短的描述文本开始，如下所示：</p>

<div class="codeblock"><div class="highlight type-gherkin"><pre><span class="kd">Feature</span><span class="p">:</span> Signing in
</pre></div>
</div>
<p>然后再添加一定数量相对独立的场景（scenario）。例如，要测试登录失败的情况，我们可以按照如下的方式编写场景：</p>

<div class="codeblock"><div class="highlight type-gherkin"><pre>  <span class="kn">Scenario</span><span class="p">:</span> Unsuccessful signin
    <span class="nf">Given</span> a user visits the signin page
    <span class="nf">When</span> he submits invalid signin information
    <span class="nf">Then</span> he should see an error message
</pre></div>
</div>
<p>类似的，测试登录成功时，我们可以加入如下的场景：</p>

<div class="codeblock"><div class="highlight type-gherkin"><pre>  <span class="kn">Scenario</span><span class="p">:</span> Successful signin
    <span class="nf">Given</span> a user visits the signin page
    <span class="nf">And</span> the user has an account
    <span class="nf">When</span> the user submits valid signin information
    <span class="nf">Then</span> he should see his profile page
    <span class="nf">And</span> he should see a signout link
</pre></div>
</div>
<p>把上述的文本放在一起，就组成了代码 8.32 所示的 Cucumber 功能文件。</p>

<div class="codeblock has-caption" id="codeblock-8-31"><p class="caption"><span>代码 8.31：</span>测试用户登录功能</p><p class="file"><code>features/signing_in.feature</code></p><div class="highlight type-gherkin"><pre><span class="kd">Feature</span><span class="p">:</span> Signing in

  <span class="kn">Scenario</span><span class="p">:</span> Unsuccessful signin
    <span class="nf">Given</span> a user visits the signin page
    <span class="nf">When</span> he submits invalid signin information
    <span class="nf">Then</span> he should see an error message

  <span class="kn">Scenario</span><span class="p">:</span> Successful signin
    <span class="nf">Given</span> a user visits the signin page
    <span class="nf">And</span> the user has an account
    <span class="nf">When</span> the user submits valid signin information
    <span class="nf">Then</span> he should see his profile page
    <span class="nf">And</span> he should see a signout link
</pre></div>
</div>
<p>然后使用 <code>cucumber</code> 命令运行这个功能：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>bundle <span class="nb">exec </span>cucumber features/
</pre></div>
</div>
<p>上述命令和执行 RSpec 测试的命令类似：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>bundle <span class="nb">exec </span>rspec spec/
</pre></div>
</div>
<p>提示一下，Cucumber 和 RSpec 一样，可以通过 Rake 命令执行：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>bundle <span class="nb">exec </span>rake cucumber
</pre></div>
</div>
<p>（鉴于某些原因，我经常使用的命令是 <code>rake cucumber:ok</code>。）</p>

<p>我们只是写了一些纯文本，所以毫不意外，Cucumber 场景现在不会通过。若要让测试通过，我们要新建一个步骤定义文件，把场景中的纯文本和 Ruby 代码对应起来。步骤定义文件存放在 <code>features/step_definition</code> 文件夹中，我们要将其命名为 <code>authentication_steps.rb</code>。</p>

<p>以 <code>Feature</code> 和 <code>Scenario</code> 开头的行基本上只被视作文档，其他的行则都要和 Ruby 代码对应。例如，功能文件中下面这行</p>

<div class="codeblock"><div class="highlight type-gherkin"><pre><span class="nf">Given</span> a user visits the signin page
</pre></div>
</div>
<p>对应到步骤定义中的</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="no">Given</span> <span class="sr">/</span>/<span class="sr">ˆa user visits the signin page$/</span> <span class="k">do</span>
  <span class="n">visit</span> <span class="n">signin_path</span>
<span class="k">end</span>
</pre></div>
</div>
<p>在功能文件中，<code>Given</code> 只是普通的字符串，而在步骤定义中 <code>Given</code> 则是一个方法，可以接受一个正则表达式作为参数，后面还可以跟着一个块。<code>Given</code> 方法的正则表达式参数是用来匹配功能文件中某个特定行的，块中的代码则是实现描述的行为所需的 Ruby 代码。本例中的“a user visits the signin page”是由下面这行代码实现的：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">visit</span> <span class="n">signin_path</span>
</pre></div>
</div>
<p>你可能觉得这行代码很眼熟，不错，这就是前面用过的 Capybara 提供的方法，Cucumber 的步骤定义文件会自动引入 Capybara。接下来的两行代码实现也同样眼熟。如下的场景步骤：</p>

<div class="codeblock"><div class="highlight type-gherkin"><pre><span class="nf">When</span> he submits invalid signin information
<span class="nf">Then</span> he should see an error message
</pre></div>
</div>
<p>对应到步骤定义文件中的</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="no">When</span> <span class="sr">/</span>/<span class="sr">^he submits invalid signin information$/</span> <span class="k">do</span>
  <span class="n">click_button</span> <span class="s2">"Sign in"</span>
<span class="k">end</span>

<span class="no">Then</span> <span class="sr">/</span>/<span class="sr">^he should see an error message$/</span> <span class="k">do</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">page</span><span class="p">).</span><span class="nf">to</span> <span class="n">have_selector</span><span class="p">(</span><span class="s1">'div.alert.alert-error'</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>上面这段代码的第一步还是用了 Capybara，第二步则结合了 Capybara 的 <code>page</code> 和 RSpec。很明显，之前我们使用 RSpec 和 Capybara 编写的测试，在 Cucumber 中也是有用武之地的。</p>

<p>场景中接下来的步骤也可以做类似的处理。最终的步骤定义文件如代码 8.33 所示。你可以一次只添加一个步骤，然后执行下面的代码，直到测试都通过为止：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>bundle <span class="nb">exec </span>cucumber features/
</pre></div>
</div>
<div class="codeblock has-caption" id="codeblock-8-32"><p class="caption"><span>代码 8.32：</span>使登录功能通过的步骤定义</p><p class="file"><code>features/step_definitions/authentication_steps.rb</code></p><div class="highlight type-ruby"><pre><span class="no">Given</span> <span class="sr">/</span>/<span class="sr">^a user visits the signin page$/</span> <span class="k">do</span>
  <span class="n">visit</span> <span class="n">signin_path</span>
<span class="k">end</span>

<span class="no">When</span> <span class="sr">/</span>/<span class="sr">^he submits invalid signin information$/</span> <span class="k">do</span>
  <span class="n">click_button</span> <span class="s2">"Sign in"</span>
<span class="k">end</span>

<span class="no">Then</span> <span class="sr">/</span>/<span class="sr">^he should see an error message$/</span> <span class="k">do</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">page</span><span class="p">).</span><span class="nf">to</span> <span class="n">have_selector</span><span class="p">(</span><span class="s1">'div.alert.alert-error'</span><span class="p">)</span>
<span class="k">end</span>

<span class="no">Given</span> <span class="sr">/</span>/<span class="sr">^the user has an account$/</span> <span class="k">do</span>
  <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">name: </span><span class="s2">"Example User"</span><span class="p">,</span> <span class="ss">email: </span><span class="s2">"user@example.com"</span><span class="p">,</span>
                      <span class="ss">password: </span><span class="s2">"foobar"</span><span class="p">,</span> <span class="ss">password_confirmation: </span><span class="s2">"foobar"</span><span class="p">)</span>
<span class="k">end</span>

<span class="no">When</span> <span class="sr">/</span>/<span class="sr">^the user submits valid signin information$/</span> <span class="k">do</span>
  <span class="n">fill_in</span> <span class="s2">"Email"</span><span class="p">,</span>    <span class="ss">with: </span><span class="vi">@user</span><span class="p">.</span><span class="nf">email</span>
  <span class="n">fill_in</span> <span class="s2">"Password"</span><span class="p">,</span> <span class="ss">with: </span><span class="vi">@user</span><span class="p">.</span><span class="nf">password</span>
  <span class="n">click_button</span> <span class="s2">"Sign in"</span>
<span class="k">end</span>

<span class="no">Then</span> <span class="sr">/</span>/<span class="sr">^he should see his profile page$/</span> <span class="k">do</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">page</span><span class="p">).</span><span class="nf">to</span> <span class="n">have_title</span><span class="p">(</span><span class="vi">@user</span><span class="p">.</span><span class="nf">name</span><span class="p">)</span>
<span class="k">end</span>

<span class="no">Then</span> <span class="sr">/</span>/<span class="sr">^he should see a signout link$/</span> <span class="k">do</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">page</span><span class="p">).</span><span class="nf">to</span> <span class="n">have_link</span><span class="p">(</span><span class="s1">'Sign out'</span><span class="p">,</span> <span class="ss">href: </span><span class="n">signout_path</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>添加了代码 8.33，Cucumber 测试应该就可以通过了：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>bundle <span class="nb">exec </span>cucumber features/
</pre></div>
</div>
<h3 id='section-8-3-3'><span>8.3.3</span> 小技巧：自定义 RSpec 匹配器</h3>


<p>编写了一些简单的 Cucumber 场景之后，我们来和相应的 RSpec 测试用例对比一下。先看一下代码 8.32 中的 Cucumber 功能和代码 8.33 中的步骤定义，然后再看一下如下的 RSpec 集成测试：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">describe</span> <span class="s2">"Authentication"</span> <span class="k">do</span>

  <span class="n">subject</span> <span class="p">{</span> <span class="n">page</span> <span class="p">}</span>

  <span class="n">describe</span> <span class="s2">"signin"</span> <span class="k">do</span>
    <span class="n">before</span> <span class="p">{</span> <span class="n">visit</span> <span class="n">signin_path</span> <span class="p">}</span>

    <span class="n">describe</span> <span class="s2">"with invalid information"</span> <span class="k">do</span>
      <span class="n">before</span> <span class="p">{</span> <span class="n">click_button</span> <span class="s2">"Sign in"</span> <span class="p">}</span>

      <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">have_title</span><span class="p">(</span><span class="s1">'Sign in'</span><span class="p">)</span> <span class="p">}</span>
      <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">have_selector</span><span class="p">(</span><span class="s1">'div.alert.alert-error'</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">end</span>

    <span class="n">describe</span> <span class="s2">"with valid information"</span> <span class="k">do</span>
      <span class="n">let</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span> <span class="p">{</span> <span class="no">FactoryGirl</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span> <span class="p">}</span>
      <span class="n">before</span> <span class="k">do</span>
        <span class="n">fill_in</span> <span class="s2">"Email"</span><span class="p">,</span>    <span class="ss">with: </span><span class="n">user</span><span class="p">.</span><span class="nf">email</span><span class="p">.</span><span class="nf">upcase</span>
        <span class="n">fill_in</span> <span class="s2">"Password"</span><span class="p">,</span> <span class="ss">with: </span><span class="n">user</span><span class="p">.</span><span class="nf">password</span>
        <span class="n">click_button</span> <span class="s2">"Sign in"</span>
      <span class="k">end</span>

      <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">have_title</span><span class="p">(</span><span class="n">user</span><span class="p">.</span><span class="nf">name</span><span class="p">)</span> <span class="p">}</span>
      <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">have_link</span><span class="p">(</span><span class="s1">'Profile'</span><span class="p">,</span>     <span class="ss">href: </span><span class="n">user_path</span><span class="p">(</span><span class="n">user</span><span class="p">))</span> <span class="p">}</span>
      <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">have_link</span><span class="p">(</span><span class="s1">'Sign out'</span><span class="p">,</span>    <span class="ss">href: </span><span class="n">signout_path</span><span class="p">)</span> <span class="p">}</span>
      <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">have_link</span><span class="p">(</span><span class="s1">'Sign in'</span><span class="p">,</span> <span class="ss">href: </span><span class="n">signin_path</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>由此你大概就可以看出 Cucumber 和集成测试各自的优缺点了。Cucumber 功能可读性很好，但是却和测试代码分隔开了，同时削弱了功能和测试代码的作用。我觉得 Cucumber 测试读起来很顺口，但是写起来怪怪的；而集成测试读起来不太顺口，但是很容易编写。</p>

<p>Cucumber 把功能描述和步骤定义分开，可以很好的实现抽象层面的行为。例如，下面这个描述</p>

<div class="codeblock"><div class="highlight type-gherkin"><pre><span class="nf">Then</span> he should see an error message
</pre></div>
</div>
<p>表达的意思是，期望看到一个错误提示信息。如下的步骤定义则检测了能否实现这个期望：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="no">Then</span> <span class="sr">/</span>/<span class="sr">^he should see an error message$/</span> <span class="k">do</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">page</span><span class="p">).</span><span class="nf">to</span> <span class="n">have_selector</span><span class="p">(</span><span class="s1">'div.alert.alert-error'</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Cucumber 这种分离方式特别便捷的地方在于，只有步骤定义是依赖具体实现的，所以假如我们修改了错误提示信息所用的 CSS class，功能描述文件是不需要修改的。</p>

<p>那么，如果你只是想检测页面中是否显示有错误提示信息，就不想在多个地方重复的编写下面的测试：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">should</span> <span class="n">have_selector</span><span class="p">(</span><span class="s1">'div.alert.alert-error'</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你真的这么做了，就把测试和具体的实现绑死了，一旦改变了实现方式，就要到处修改测试。在 RSpec 中，可以自定义匹配器来解决这个问题，我们可以直接这么写：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">should</span> <span class="n">have_error_message</span><span class="p">(</span><span class="s1">'Invalid'</span><span class="p">)</span>
</pre></div>
</div>
<p>我们可以在 <a href="chapter5.html#section-5-3-4">5.3.4 节</a> 中定义 <code>full_title</code> 测试帮助方法的文件中定义这个匹配器，代码如下：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="no">RSpec</span><span class="o">::</span><span class="no">Matchers</span><span class="p">.</span><span class="nf">define</span> <span class="ss">:have_error_message</span> <span class="k">do</span> <span class="o">|</span><span class="n">message</span><span class="o">|</span>
  <span class="n">match</span> <span class="k">do</span> <span class="o">|</span><span class="n">page</span><span class="o">|</span>
    <span class="n">expect</span><span class="p">(</span><span class="n">page</span><span class="p">).</span><span class="nf">to</span> <span class="n">have_selector</span><span class="p">(</span><span class="s1">'div.alert.alert-error'</span><span class="p">,</span> <span class="ss">text: </span><span class="n">message</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>我们还可以为一些常用的操作定义帮助方法，例如：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="k">def</span> <span class="nf">valid_signin</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
  <span class="n">fill_in</span> <span class="s2">"Email"</span><span class="p">,</span>    <span class="ss">with: </span><span class="n">user</span><span class="p">.</span><span class="nf">email</span>
  <span class="n">fill_in</span> <span class="s2">"Password"</span><span class="p">,</span> <span class="ss">with: </span><span class="n">user</span><span class="p">.</span><span class="nf">password</span>
  <span class="n">click_button</span> <span class="s2">"Sign in"</span>
<span class="k">end</span>
</pre></div>
</div>
<p>最终的文件如代码 8.34 所示（把 <a href="chapter5.html#section-5-6">5.6 节</a>中的代码 5.38 和代码 5.39 合并了）。我觉得这种方法比 Cucumber 的步骤定义还要灵活，特别是当匹配器和帮助方法可以接受一个参数时，例如 <code>valid_signin(user)</code>。我们也可以用步骤定义中的正则表达式匹配来实现这种功能，不过太过繁杂。</p>

<div class="codeblock has-caption" id="codeblock-8-33"><p class="caption"><span>代码 8.33：</span>添加一个帮助函数和一个 RSpec 自定义匹配器</p><p class="file"><code>spec/support/utilities.rb</code></p><div class="highlight type-ruby"><pre><span class="kp">include</span> <span class="no">ApplicationHelper</span>

<span class="k">def</span> <span class="nf">valid_signin</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
  <span class="n">fill_in</span> <span class="s2">"Email"</span><span class="p">,</span>    <span class="ss">with: </span><span class="n">user</span><span class="p">.</span><span class="nf">email</span>
  <span class="n">fill_in</span> <span class="s2">"Password"</span><span class="p">,</span> <span class="ss">with: </span><span class="n">user</span><span class="p">.</span><span class="nf">password</span>
  <span class="n">click_button</span> <span class="s2">"Sign in"</span>
<span class="k">end</span>

<span class="no">RSpec</span><span class="o">::</span><span class="no">Matchers</span><span class="p">.</span><span class="nf">define</span> <span class="ss">:have_error_message</span> <span class="k">do</span> <span class="o">|</span><span class="n">message</span><span class="o">|</span>
  <span class="n">match</span> <span class="k">do</span> <span class="o">|</span><span class="n">page</span><span class="o">|</span>
    <span class="n">expect</span><span class="p">(</span><span class="n">page</span><span class="p">).</span><span class="nf">to</span> <span class="n">have_selector</span><span class="p">(</span><span class="s1">'div.alert.alert-error'</span><span class="p">,</span> <span class="ss">text: </span><span class="n">message</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>添加了代码 8.34 之后，我们就可以直接写</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">have_error_message</span><span class="p">(</span><span class="s1">'Invalid'</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>和</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">describe</span> <span class="s2">"with valid information"</span> <span class="k">do</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span> <span class="p">{</span> <span class="no">FactoryGirl</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">before</span> <span class="p">{</span> <span class="n">valid_signin</span><span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">.</span>
  <span class="nf">.</span>
  <span class="o">.</span>
</pre></div>
</div>
<p>还有很多测试用例把测试和具体的实现绑缚在一起了，我们会在 <a href="chapter8.html#section-8-5">8.5 节</a>的练习中彻底的搜查现有的测试组件，使用自定义匹配器和帮助方法解耦测试和具体实现。</p>

<h2 id='section-8-4'><span>8.4</span> 小结</h2>


<p>本章我们介绍了很多基础知识，也为稍显简陋的应用程序实现了注册和登录功能。实现了用户身份验证功能后，我们就可以根据登录状态和用户的身份限制对特定页面的访问权限。在实现限制访问的过程中，我们会为用户添加编辑个人信息的功能，还会为管理员添加删除用户的功能。这些是<a href="chapter9.html">第 9 章</a>的主要内容。</p>

<p>在继续阅读之前，先把本章的改动合并到主分支吧：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>git add .
<span class="gp">$ </span>git commit -m <span class="s2">"Finish sign in"</span>
<span class="gp">$ </span>git checkout master
<span class="gp">$ </span>git merge sign-in-out
</pre></div>
</div>
<p>然后再推送到 GitHub 和 Heroku “生产环境”服务器：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>git push
<span class="gp">$ </span>git push heroku
<span class="gp">$ </span>heroku run rake db:migrate
</pre></div>
</div>
<h2 id='section-8-5'><span>8.5</span> 练习</h2>


<ol>
  <li>
    <p>重构登录表单，把 <code>form_for</code> 换成 <code>form_tag</code>，确保测试还是可以通过的。提示：可以参照 Railscasts 第 270 集《<a href="http://railscasts.com/episodes/270-authentication-in-rails-3-1">Authentication in Rails 3.1</a>》，特别留意一下 <code>params</code> Hash 结构的变化。</p>
  </li>
  <li>
    <p>参照 <a href="chapter8.html#section-8-3-3">8.3.3 节</a>中的示例，遍览用户和身份验证相关的集成测试，在 <code>spec/support/utilities.rb</code> 中定义帮助函数，解耦测试和具体实现。附加题：把这些帮助方法放到不同的文件和模块中，然后再引入相应的模块。</p>
  </li>
</ol>

<div class="footnotes">
  <ol>
    <li id="fn-8-1">
      <p>另外一个常见的 session 处理方式是，在一定时间之后失效。这种方式特别适合包含敏感信息的网站，例如银行和交易账户。<a href="#fnref-8-1" rel="reference">↩</a></p>
    </li>
    <li id="fn-8-2">
      <p>图片来自 <a href="http://www.flickr.com/photos/hermanusbackpackers/3343254977/">http://www.flickr.com/photos/hermanusbackpackers/3343254977/</a><a href="#fnref-8-2" rel="reference">↩</a></p>
    </li>
    <li id="fn-8-3">
      <p>我选择这么生成记忆权标是因为看了 Railscasts 第 274 集《<a href="http://railscasts.com/episodes/274-remember-me-reset-password">Remember Me &amp; Reset Password</a>》。<a href="#fnref-8-3" rel="reference">↩</a></p>
    </li>
    <li id="fn-8-4">
      <p>Active Record 支持的其他回调函数<a href="http://guides.rubyonrails.org/v3.2.13/active_record_validations_callbacks.html">在 Rails 指南中</a>有介绍。<a href="#fnref-8-4" rel="reference">↩</a></p>
    </li>
    <li id="fn-8-t4">
      <p>译者注：其实 <code>private</code> 是方法而不是关键字，请参阅《Ruby 编程语言》P233<a href="#fnref-8-t4" rel="reference">↩</a></p>
    </li>
    <li id="fn-8-6">
      <p>其实这两种方式是完全等效的，<code>attr_accessor</code> 会自动创建取值和设定方法。<a href="#fnref-8-6" rel="reference">↩</a></p>
    </li>
    <li id="fn-8-t3">
      <p>译者注：如果按照 bbatsov 的《<a href="https://github.com/bbatsov/ruby-style-guide">Ruby 编程风格指南</a>》来编写 Ruby 代码的话，就没必要多加一层缩进。<a href="#fnref-8-t3" rel="reference">↩</a></p>
    </li>
    <li id="fn-8-5">
      <p>如果方法不需要在实例上调用，就要定义为类方法。<a href="#fnref-8-5" rel="reference">↩</a></p>
    </li>
    <li id="fn-8-8">
      <p>这也是一种备忘（memoization），详情参见<a href="chapter6.html#section-6-3">旁注 6.3</a>。<a href="#fnref-8-8" rel="reference">↩</a></p>
    </li>
    <li id="fn-8-7">
      <p>一般来说，这句话的意思是把初始值为 <code>nil</code> 的变量附上了新值，不过 <code>||=</code> 也会把初始值为 <code>false</code> 的变量附上新值。<a href="#fnref-8-7" rel="reference">↩</a></p>
    </li>
    <li id="fn-8-t2">
      <p>译者注：这里对 <code>||=</code> 的分析和 Peter Cooper 的分析有点差异，我推荐你看以下 Ruby Inside 中的《<a href="http://www.rubyinside.com/what-rubys-double-pipe-or-equals-really-does-5488.html">What Ruby’s ||= (Double Pipe / Or Equals) Really Does</a>》一文。<a href="#fnref-8-t2" rel="reference">↩</a></p>
    </li>
    <li id="fn-8-9">
      <p>浏览器其实并不能发送 <code>DELETE</code> 请求，Rails 是通过 JavaScript 模仿的。<a href="#fnref-8-9" rel="reference">↩</a></p>
    </li>
  </ol>
</div>

  	</div>
</div>

			
				
				<div class="navigation">
					
						<a class="prev_page" href="chapter7.html">&laquo; 第 7 章用户注册</a>
					
					
						<a class="next_page" href="chapter9.html">第 9 章更新、显示和删除用户 &raquo;</a>
					
				</div>
				
			
		</div>
		<div class="footer">
        	<p>&copy;2013 <a href="http://about.ac" title="Andor Chen 的个人网站">Andor Chen</a> 保留部分权力。在线阅读版本基于<a href="http://creativecommons.org/licenses/by-sa/3.0/" title="Creative Commons Attribution-ShareAlike 3.0 Unported License" target="_blank">“CC 3.0 BY-SA 协议”</a>发布</p>
		</div>
	</div>
</body>
</html>
