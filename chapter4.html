<!doctype html>
<html lang="zh_CN">
<head>
	<meta charset="utf-8" />
	<title>第 4 章 Rails 背后的 Ruby</title>
    <meta name="author" content="Andor Chen" />
    <link rel="stylesheet" href="/assets/styles/style.css" />
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/global.js"></script>
</head>

<body>
	<div class="wrapper">
		<div class="header">
            <h1 class="logo"><a class="ir" href="http://railstutorial-china.org">Ruby on Rails 教程</a></h1>
            <p class="subtitle">Ruby on Rails Tutorial 原书第 2 版（涵盖 Rails 4）</p>
        </div>
        <div class="content">
			
<div class="item chapter">
	<h1 id="chapter-4"><span>第 4 章</span> Rails 背后的 Ruby</h1>
	<ol class="toc">          <li class="level-2">
            <a href="#section-4-1">4.1 导言</a>
          </li>
          <li class="level-2">
            <a href="#section-4-2">4.2 字符串和方法</a>
          </li>
          <li class="level-3">
            <a href="#section-4-2-1">4.2.1 注释</a>
          </li>
          <li class="level-3">
            <a href="#section-4-2-2">4.2.2 字符串</a>
          </li>
          <li class="level-3">
            <a href="#section-4-2-3">4.2.3 对象及向其传递消息</a>
          </li>
          <li class="level-3">
            <a href="#section-4-2-4">4.2.4 定义方法</a>
          </li>
          <li class="level-3">
            <a href="#section-4-2-5">4.2.5 回顾一下标题的帮助方法</a>
          </li>
          <li class="level-2">
            <a href="#section-4-3">4.3 其他的数据类型</a>
          </li>
          <li class="level-3">
            <a href="#section-4-3-1">4.3.1 数组和 Range</a>
          </li>
          <li class="level-3">
            <a href="#section-4-3-2">4.3.2 块</a>
          </li>
          <li class="level-3">
            <a href="#section-4-3-3">4.3.3 Hash 和 Symbol</a>
          </li>
          <li class="level-3">
            <a href="#section-4-3-4">4.3.4 重温引入 CSS 的代码</a>
          </li>
          <li class="level-2">
            <a href="#section-4-4">4.4 Ruby 类</a>
          </li>
          <li class="level-3">
            <a href="#section-4-4-1">4.4.1 构造器</a>
          </li>
          <li class="level-3">
            <a href="#section-4-4-2">4.4.2 类的继承</a>
          </li>
          <li class="level-3">
            <a href="#section-4-4-3">4.4.3 修改内置的类</a>
          </li>
          <li class="level-3">
            <a href="#section-4-4-4">4.4.4 控制器类</a>
          </li>
          <li class="level-3">
            <a href="#section-4-4-5">4.4.5 用户类</a>
          </li>
          <li class="level-2">
            <a href="#section-4-5">4.5 小结</a>
          </li>
          <li class="level-2">
            <a href="#section-4-6">4.6 练习</a>
          </li>
</ol>
  	<div class="main">
  		<p>有了<a href="chapter3.html">第 3 章</a>中的例子做铺垫，本章将为你介绍一些对 Rails 来说很重要的 Ruby 知识。Ruby 语言的知识点很多，不过对一个 Rails 开发者而言需要掌握的很少。我们采用的是有别于常规的 Ruby 学习过程，我们的目标是开发动态的 Web 应用程序，所以我建议你先学习 Rails，在这个过程中学习一些 Ruby 知识。如果要成为一个 Rails 专家，你就要更深入的掌握 Ruby 了。本书会为你在成为专家的路途上奠定一个坚实的基础。如 <a href="chapter1.html#section-1-1-1">1.1.1 节</a>中说过的，读完本书后我建议你阅读一本专门针对 Ruby 的书，例如《<a href="http://www.amazon.com/gp/product/1430223634">Ruby 入门</a>》、《<a href="http://www.amazon.com/gp/product/1933988657">The Well-Grounded Rubyist</a>》或《<a href="http://www.amazon.com/gp/product/0672328844">Ruby 之道</a>》。</p>

<p>本章介绍了很多内容，第一遍阅读没有掌握全部是可以理解的。在后续的章节我会经常提到本章的内容。</p>

<h2 id='section-4-1'><span>4.1</span> 导言</h2>


<p>从上一章我们可以看到，即使不懂任何背后用到的 Ruby 语言，我们也可以创建一个 Rails 应用程序骨架，也可以进行测试。不过我们依赖的是本教程中提供的测试代码，得到错误信息，然后让其通过。我们不能总是这样做，所以这一章我们要暂别网站开发学习，正视我们的 Ruby 短肋。</p>

<p>上次接触应用程序时，我们已经使用 Rails 布局去掉了几乎是静态的页面中的代码重复，参见代码 4.1，这段代码就是重新排版一下代码 3.26。</p>

<div class="codeblock has-caption" id="codeblock-4-1"><p class="caption"><span>代码 4.1：</span>示例程序的网站布局</p><p class="file"><code>app/views/layouts/application.html.erb</code></p><div class="highlight type-erb"><pre><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;title&gt;</span>Ruby on Rails Tutorial Sample App | <span class="cp">&lt;%=</span> <span class="k">yield</span><span class="p">(</span><span class="ss">:title</span><span class="p">)</span> <span class="cp">%&gt;</span><span class="nt">&lt;/title&gt;</span>
    <span class="cp">&lt;%=</span> <span class="n">stylesheet_link_tag</span> <span class="s2">"application"</span><span class="p">,</span> <span class="ss">media: </span><span class="s2">"all"</span><span class="p">,</span>
                                           <span class="s2">"data-turbolinks-track"</span> <span class="o">=&gt;</span> <span class="kp">true</span> <span class="cp">%&gt;</span>
    <span class="cp">&lt;%=</span> <span class="n">javascript_include_tag</span> <span class="s2">"application"</span><span class="p">,</span> <span class="s2">"data-turbolinks-track"</span> <span class="o">=&gt;</span> <span class="kp">true</span> <span class="cp">%&gt;</span>
    <span class="cp">&lt;%=</span> <span class="n">csrf_meta_tags</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="cp">&lt;%=</span> <span class="k">yield</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></div>
</div>
<p>让我们把注意力集中在代码 4.1 中的这一行：</p>

<div class="codeblock"><div class="highlight type-erb"><pre><span class="cp">&lt;%=</span> <span class="n">stylesheet_link_tag</span> <span class="s2">"application"</span><span class="p">,</span> <span class="ss">media: </span><span class="s2">"all"</span><span class="p">,</span>
                                       <span class="s2">"data-turbolinks-track"</span> <span class="o">=&gt;</span> <span class="kp">true</span> <span class="cp">%&gt;</span>
</pre></div>
</div>
<p>这行代码使用 Rails 内置的方法 <code>stylesheet_link_tag</code>（更多内容请查看 <a href="http://api.rubyonrails.org/v3.2.0/classes/ActionView/Helpers/AssetTagHelper/StylesheetTagHelpers.html#method-i-stylesheet_link_tag">Rails API 文档</a>）为所有的<a href="http://www.w3.org/TR/CSS2/media.html">媒介类型</a>引入了 <code>application.css</code>。对于经验丰富的 Rails 开发者来说，这一行很简单，但是这里却至少包含了困惑着你的四个 Ruby 知识点：内置的 Rails 方法，不用括号的方法调用，Symbol 和 Hash。这几点本章都会介绍。</p>

<p>除了提供很多内置的方法供我们在视图中使用之外，Rails 还允许我们自行创建。自行创建的这些方法叫做帮助方法（helper）。要说明如何自行创建一个帮助方法，我们要来看看代码 4.1 中标题那一行：</p>

<div class="codeblock"><div class="highlight type-erb"><pre>Ruby on Rails Tutorial Sample App | <span class="cp">&lt;%=</span> <span class="k">yield</span><span class="p">(</span><span class="ss">:title</span><span class="p">)</span> <span class="cp">%&gt;</span>
</pre></div>
</div>
<p>这行代码依赖于每个视图中定义的页面标题（使用 <code>provide</code>），例如</p>

<div class="codeblock"><div class="highlight type-erb"><pre><span class="cp">&lt;%</span> <span class="n">provide</span><span class="p">(</span><span class="ss">:title</span><span class="p">,</span> <span class="s1">'Home'</span><span class="p">)</span> <span class="cp">%&gt;</span>
<span class="nt">&lt;h1&gt;</span>Sample App<span class="nt">&lt;/h1&gt;</span>
<span class="nt">&lt;p&gt;</span>
  This is the home page for the
  <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"http://railstutorial.org/"</span><span class="nt">&gt;</span>Ruby on Rails Tutorial<span class="nt">&lt;/a&gt;</span>
  sample application.
<span class="nt">&lt;/p&gt;</span>
</pre></div>
</div>
<p>那么如果我们不提供标题会怎样呢？我们的标题一般都包含一个公共部分，如果想更具体些就要加上一个变动的部分了。我们在布局中用了个小技巧，基本上已经实现了这样的标题。如果我们删除视图中的 <code>provide</code> 方法调用，输出的标题就没有了变动的那部分：</p>

<div class="codeblock"><div class="highlight type-plaintext"><pre>Ruby on Rails Tutorial Sample App |
</pre></div>
</div>
<p>公共部分已经输出了，而且后面还有一个竖杠 <code>|</code>。</p>

<p>为了解决这个标题问题，我们会自定义一个帮助方法，叫做 <code>full_title</code>。如果视图中没有定义标题，<code>full_title</code> 会返回标题的公共部分，即“Ruby on Rails Tutorial Sample App”；如果定义了，则会在公共部分后面加上一个竖杠，然后再接上该页面的标题（如代码 4.2）。<sup class="footnote" id="fnref-4-1"><a href="#fn-4-1" rel="footnote">1</a></sup></p>

<div class="codeblock has-caption" id="codeblock-4-2"><p class="caption"><span>代码 4.2：</span>定义 <code>full_title</code> 帮助方法</p><p class="file"><code>app/helpers/application_helper.rb</code></p><div class="highlight type-ruby"><pre><span class="k">module</span> <span class="nn">ApplicationHelper</span>

  <span class="c1"># Returns the full title on a per-page basis.</span>
  <span class="k">def</span> <span class="nf">full_title</span><span class="p">(</span><span class="n">page_title</span><span class="p">)</span>
    <span class="n">base_title</span> <span class="o">=</span> <span class="s2">"Ruby on Rails Tutorial Sample App"</span>
    <span class="k">if</span> <span class="n">page_title</span><span class="p">.</span><span class="nf">empty?</span>
      <span class="n">base_title</span>
    <span class="k">else</span>
      <span class="s2">"</span><span class="si">#{</span><span class="n">base_title</span><span class="si">}</span><span class="s2"> | </span><span class="si">#{</span><span class="n">page_title</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>现在我们已经定义了一个帮助方法，我们可以用它来简化布局，将</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="o">&lt;</span><span class="n">title</span><span class="o">&gt;</span><span class="no">Ruby</span> <span class="n">on</span> <span class="no">Rails</span> <span class="no">Tutorial</span> <span class="no">Sample</span> <span class="no">App</span> <span class="o">|</span> <span class="o">&lt;</span><span class="sx">%= yield(:title) %&gt;&lt;/title&gt;
</span></pre></div>
</div>
<p>替换成</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="o">&lt;</span><span class="n">title</span><span class="o">&gt;&lt;</span><span class="sx">%= full_title(yield(:title)) %&gt;&lt;/title&gt;
</span></pre></div>
</div>
<p>如代码 4.3 所示。</p>

<div class="codeblock has-caption" id="codeblock-4-3"><p class="caption"><span>代码 4.3：</span>示例程序的网站布局</p><p class="file"><code>app/views/layouts/application.html.erb</code></p><div class="highlight type-erb"><pre><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;title&gt;</span><span class="cp">&lt;%=</span> <span class="n">full_title</span><span class="p">(</span><span class="k">yield</span><span class="p">(</span><span class="ss">:title</span><span class="p">))</span> <span class="cp">%&gt;</span><span class="nt">&lt;/title&gt;</span>
    <span class="cp">&lt;%=</span> <span class="n">stylesheet_link_tag</span> <span class="s2">"application"</span><span class="p">,</span> <span class="ss">media: </span><span class="s2">"all"</span><span class="p">,</span>
                                           <span class="s2">"data-turbolinks-track"</span> <span class="o">=&gt;</span> <span class="kp">true</span> <span class="cp">%&gt;</span>
    <span class="cp">&lt;%=</span> <span class="n">javascript_include_tag</span> <span class="s2">"application"</span><span class="p">,</span> <span class="s2">"data-turbolinks-track"</span> <span class="o">=&gt;</span> <span class="kp">true</span> <span class="cp">%&gt;</span>
    <span class="cp">&lt;%=</span> <span class="n">csrf_meta_tags</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="cp">&lt;%=</span> <span class="k">yield</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></div>
</div>
<p>为了让这个帮助方法起作用，我们要在“首页”视图中将不必要的“Home”这个词删掉，让标题只保留公共部分。首先我们要按照代码 4.4 的内容更新现有的测试，增加对没包含 <code>'Home'</code> 的标题测试。</p>

<div class="codeblock has-caption" id="codeblock-4-4"><p class="caption"><span>代码 4.4：</span>更新“首页”标题的测试</p><p class="file"><code>spec/requests/static_pages_spec.rb</code></p><div class="highlight type-ruby"><pre><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="s2">"Static pages"</span> <span class="k">do</span>

  <span class="n">describe</span> <span class="s2">"Home page"</span> <span class="k">do</span>

    <span class="n">it</span> <span class="s2">"should have the content 'Sample App'"</span> <span class="k">do</span>
      <span class="n">visit</span> <span class="s1">'/static_pages/home'</span>
      <span class="n">expect</span><span class="p">(</span><span class="n">page</span><span class="p">).</span><span class="nf">to</span> <span class="n">have_content</span><span class="p">(</span><span class="s1">'Sample App'</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">it</span> <span class="s2">"should have the base title"</span> <span class="k">do</span>
      <span class="n">visit</span> <span class="s1">'/static_pages/home'</span>
      <span class="n">expect</span><span class="p">(</span><span class="n">page</span><span class="p">).</span><span class="nf">to</span> <span class="n">have_title</span><span class="p">(</span><span class="s2">"Ruby on Rails Tutorial Sample App"</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">it</span> <span class="s2">"should not have a custom page title"</span> <span class="k">do</span>
      <span class="n">visit</span> <span class="s1">'/static_pages/home'</span>
      <span class="n">expect</span><span class="p">(</span><span class="n">page</span><span class="p">).</span><span class="nf">not_to</span> <span class="n">have_title</span><span class="p">(</span><span class="s1">'| Home'</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div>
<p>试试看你能否猜到为什么我们添加了一个新测试而不是直接修改之前的测试。（提示：答案在 <a href="chapter3.html#section-3-3-1">3.3.1 节</a>中。）</p>

<p>运行测试，查看是否有一个测试失败了：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>bundle <span class="nb">exec </span>rspec spec/requests/static_pages_spec.rb
</pre></div>
</div>
<p>为了让测试通过，我们要将“首页”视图中的 <code>provide</code> 那行删除，如代码 4.5 所示。</p>

<div class="codeblock has-caption" id="codeblock-4-5"><p class="caption"><span>代码 4.5：</span>删除标题定义后的“首页”</p><p class="file"><code>app/views/static_pages/home.html.erb</code></p><div class="highlight type-erb"><pre><span class="nt">&lt;h1&gt;</span>Sample App<span class="nt">&lt;/h1&gt;</span>
<span class="nt">&lt;p&gt;</span>
  This is the home page for the
  <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"http://railstutorial.org/"</span><span class="nt">&gt;</span>Ruby on Rails Tutorial<span class="nt">&lt;/a&gt;</span>
  sample application.
<span class="nt">&lt;/p&gt;</span>
</pre></div>
</div>
<p>现在测试应该可以通过了：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>bundle <span class="nb">exec </span>rspec spec/requests/static_pages_spec.rb
</pre></div>
</div>
<p>和引入应用程序样式表那行代码一样，代码 4.2 的内容对经验丰富的 Rails 开发者来说看起来很简单，但是充满了很多会让人困惑的 Ruby 知识：module，注释，局部变量的赋值，布尔值，流程控制，字符串插值，还有返回值。这章也会介绍这些知识。</p>

<h2 id='section-4-2'><span>4.2</span> 字符串和方法</h2>


<p>学习 Ruby 我们主要使用的工具是 Rails 控制台，它是用来和 Rails 应用程序交互的命令行，在 <a href="chapter2.html#section-2-3-3">2.3.3 节</a>中介绍过。这个控制台是基于 Ruby 的交互程序（<code>irb</code>）开发的，因此也就能使用 Ruby 语言的全部功能。（在 <a href="chapter4.html#section-4-4-4">4.4.4 节</a>中会介绍，控制台还可以进入 Rails 环境。）使用下面的方法在命令行中启动控制台：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>rails console
Loading development environment
&gt;&gt;
</pre></div>
</div>
<p>默认情况下，控制台是以开发环境启用的，这是 Rails 定义的三个独立的环境之一（其他两个是测试环境和生产环境）。三个环境的区别在本章还不需要知道，我们会在 <a href="chapter7.html#section-7-1-1">7.1.1 节</a>中更详细的介绍。</p>

<p>控制台是个很好的学习工具，你不用有所畏惧尽情的使用吧，没必要担心，你（几乎）不会破坏任何东西。如果你在控制台中遇到问题了可以使用 Ctrl-C 结束当前执行的命令，或者使用 Ctrl-D 直接退出控制台。在阅读本章后面的内容时，你会发现查阅 <a href="http://ruby-doc.org/core-2.0/">Ruby API</a> 会很有用。API 包含很多信息，例如，如果你想查看关于 Ruby 字符串更多的内容，可以查看其中的 <code>String</code> 类页面。</p>

<h3 id='section-4-2-1'><span>4.2.1</span> 注释</h3>


<p>Ruby 中的注释以井号 <code>#</code>（也叫“Hash Mark”，或者更诗意的叫“散列字元”）开头，一直到行尾结束。Ruby 会忽略注释，但是注释对代码阅读者（包括代码的创作者）却很有用。在下面的代码中</p>

<div class="codeblock"><div class="highlight type-ruby"><pre>  <span class="c1"># Returns the full title on a per-page basis.</span>
  <span class="k">def</span> <span class="nf">full_title</span><span class="p">(</span><span class="n">page_title</span><span class="p">)</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">.</span>
  <span class="k">end</span>
</pre></div>
</div>
<p>第一行就是注释，说明了后面方法的作用。</p>

<p>一般无需在控制台中写注释，不过为了说明代码，我会按照下面的形式加上注释，例如：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>rails console
<span class="gp">&gt;&gt; </span>17 + 42   <span class="c"># Integer addition</span>
<span class="gp">=&gt; </span>59
</pre></div>
</div>
<p>在本节的阅读过程中，在控制台中输入或者复制粘贴命令时，如果愿意你可以不复制注释，反正控制台会忽略注释。</p>

<h3 id='section-4-2-2'><span>4.2.2</span> 字符串</h3>


<p>字符串算是 Web 应用程序中最有用的数据结构了，因为网页的内容就是从数据库发送到浏览器的字符串。我们先在控制台中体验一下字符串，这次我们使用 <code>rails c</code> 启动控制台，这是 <code>rails console</code> 的简写形式：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>rails c
<span class="gp">&gt;&gt; </span><span class="s2">""</span>         <span class="c"># 空字符串</span>
<span class="gp">=&gt; </span><span class="s2">""</span>
<span class="gp">&gt;&gt; </span><span class="s2">"foo"</span>      <span class="c"># 非空的字符串</span>
<span class="gp">=&gt; </span><span class="s2">"foo"</span>
</pre></div>
</div>
<p>上面的字符串是字面量（字面量字符串，literal string），通过双引号（<code>"</code>）创建。控制台回显的是每一行的计算结果，本例中字符串字面量的结果就是字符串本身。</p>

<p>我们还可以使用 <code>+</code> 号连接字符串：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span><span class="s2">"foo"</span> + <span class="s2">"bar"</span>    <span class="c"># 字符串连接</span>
<span class="gp">=&gt; </span><span class="s2">"foobar"</span>
</pre></div>
</div>
<p><code>"foo"</code> 连接 <code>"bar"</code> 的运行结果是字符串 <code>"foobar"</code>。<sup class="footnote" id="fnref-4-2"><a href="#fn-4-2" rel="footnote">2</a></sup></p>

<p>另外一种创建字符串的方式是通过一个特殊的句法（<code>#{}</code>）进行插值操作：<sup class="footnote" id="fnref-4-3"><a href="#fn-4-3" rel="footnote">3</a></sup></p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>first_name <span class="o">=</span> <span class="s2">"Michael"</span>    <span class="c"># 变量赋值</span>
<span class="gp">=&gt; </span><span class="s2">"Michael"</span>
<span class="gp">&gt;&gt; </span><span class="s2">"#{first_name} Hartl"</span>     <span class="c"># 字符串插值</span>
<span class="gp">=&gt; </span><span class="s2">"Michael Hartl"</span>
</pre></div>
</div>
<p>我们先把“<code>Michael</code>”赋值给变量 <code>first_name</code>，然后将其插入到字符串 <code>"#{first_name} Hartl"</code> 中。我们可以将两个字符串都赋值给变量：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>first_name <span class="o">=</span> <span class="s2">"Michael"</span>
<span class="gp">=&gt; </span><span class="s2">"Michael"</span>
<span class="gp">&gt;&gt; </span>last_name <span class="o">=</span> <span class="s2">"Hartl"</span>
<span class="gp">=&gt; </span><span class="s2">"Hartl"</span>
<span class="gp">&gt;&gt; </span>first_name + <span class="s2">" "</span> + last_name    <span class="c"># 字符串连接，中间加了空格</span>
<span class="gp">=&gt; </span><span class="s2">"Michael Hartl"</span>
<span class="gp">&gt;&gt; </span><span class="s2">"#{first_name} #{last_name}"</span>    <span class="c"># 作用相同的插值</span>
<span class="gp">=&gt; </span><span class="s2">"Michael Hartl"</span>
</pre></div>
</div>
<p>注意，两个表达式的结果是相同的，不过我倾向使用插值的方式。在两个字符串中加入一个空格（<code>" "</code>）显得很别扭。</p>

<h4 id='section-4-2-2-1'><span></span>打印字符串</h4>


<p>打印字符串最常用的 Ruby 方法是 <code>puts</code>（读作“put ess”，意思是“打印字符串”）：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>puts <span class="s2">"foo"</span>     <span class="c"># 打印字符串</span>
foo
<span class="gp">=&gt; </span>nil
</pre></div>
</div>
<p><code>puts</code> 方法还有一个副作用（side-effect）：<code>puts "foo"</code> 首先会将字符串打印到屏幕上，然后再返回<a href="http://www.answers.com/nil">空值字面量</a>：<code>nil</code> 是 Ruby 中的“什么都没有”。（后续内容中为了行文简洁我会省略 <code>=&gt; nil</code>。）</p>

<p><code>puts</code> 方法会自动在输出的字符串后面加入换行符 <code>\n</code>，功能类似的 <code>print</code> 方法则不会：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>print <span class="s2">"foo"</span>    <span class="c"># 打印字符串（和 puts 类似，但没有添加换行符）</span>
<span class="gp">foo=&gt; </span>nil
<span class="gp">&gt;&gt; </span>print <span class="s2">"foo</span><span class="se">\n</span><span class="s2">"</span>  <span class="c"># 和 puts "foo" 一样</span>
<span class="gp">=&gt; </span>nil
</pre></div>
</div>
<h4 id='section-4-2-2-2'><span></span>单引号字符串</h4>


<p>目前介绍的例子都是使用双引号创建的字符串，不过 Ruby 也支持用单引号创建字符串。大多数情况下这两种字符串的效果是一样的：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span><span class="s1">'foo'</span>          <span class="c"># 单引号创建的字符串</span>
<span class="gp">=&gt; </span><span class="s2">"foo"</span>
<span class="gp">&gt;&gt; </span><span class="s1">'foo'</span> + <span class="s1">'bar'</span>
<span class="gp">=&gt; </span><span class="s2">"foobar"</span>
</pre></div>
</div>
<p>不过两种方法还是有个很重要的区别：Ruby 不会对单引号字符串进行插值操作：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span><span class="s1">'#{foo} bar'</span>     <span class="c"># 单引号字符串不能进行插值操作</span>
<span class="gp">=&gt; </span><span class="s2">"</span><span class="se">\#</span><span class="s2">{foo} bar"</span>
</pre></div>
</div>
<p>注意控制台是如何使用双引号返回结果的，需要使用反斜线转义特殊字符，例如 <code>#</code>。</p>

<p>如果双引号字符串可以做单引号所做的所有事，而且还能进行插值，那么单引号字符串存在的意义是什么呢？单引号字符串的用处在于它们真的就是字面值，只包含你输入的字符。例如，反斜线在很多系统中都很特殊，就像换行符（<code>\n</code>）一样。如果有一个变量需要包含一个反斜线，使用单引号就很简单：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span><span class="s1">'\n'</span>       <span class="c"># 反斜线和 n 字面值</span>
<span class="gp">=&gt; </span><span class="s2">"</span><span class="se">\\</span><span class="s2">n"</span>
</pre></div>
</div>
<p>和前例的 <code>#</code> 字符一样，Ruby 要使用一个额外的反斜线来转义反斜线，在双引号字符串中，要表达一个反斜线就要使用两个反斜线。对简单的例子来说，这省不了多少事，不过如果有很多需要转义的字符就显得出它的作用了：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span><span class="s1">'Newlines (\n) and tabs (\t) both use the backslash character \.'</span>
<span class="gp">=&gt; </span><span class="s2">"Newlines (</span><span class="se">\\</span><span class="s2">n) and tabs (</span><span class="se">\\</span><span class="s2">t) both use the backslash character </span><span class="se">\\</span><span class="s2">."</span>
</pre></div>
</div>
<h3 id='section-4-2-3'><span>4.2.3</span> 对象及向其传递消息</h3>


<p>Ruby 中一切皆对象，包括字符串和 <code>nil</code> 都是。我们会在 <a href="chapter4.html#section-4-4-2">4.4.2 节</a>介绍对象技术层面上的意义，不过一般很难通过阅读一本书就理解对象，你要多看一些例子才能建立对对象的感性认识。</p>

<p>不过说出对象的作用就很简单：它可以响应消息。例如，一个字符串对象可以响应 <code>length</code> 这个消息，它返回字符串包含的字符数量：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span><span class="s2">"foobar"</span>.length        <span class="c"># 把 length 消息传递给字符串</span>
<span class="gp">=&gt; </span>6
</pre></div>
</div>
<p>这样传递给对象的消息叫做方法，它是在对象中定义的函数。<sup class="footnote" id="fnref-4-4"><a href="#fn-4-4" rel="footnote">4</a></sup>字符串还可以响应 <code>empty?</code> 方法：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span><span class="s2">"foobar"</span>.empty?
<span class="gp">=&gt; </span><span class="nb">false</span>
<span class="gp">&gt;&gt; </span><span class="s2">""</span>.empty?
<span class="gp">=&gt; </span><span class="nb">true</span>
</pre></div>
</div>
<p>注意 <code>empty?</code> 方法末尾的问号，这是 Ruby 的一个约定，说明方法的返回值是布尔值：<code>true</code> 或 <code>false</code>。布尔值在流程控制中特别有用：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>s <span class="o">=</span> <span class="s2">"foobar"</span>
<span class="gp">&gt;&gt; </span><span class="k">if </span>s.empty?
<span class="gp">&gt;&gt;   </span><span class="s2">"The string is empty"</span>
<span class="gp">&gt;&gt; </span><span class="k">else</span>
<span class="gp">&gt;&gt;   </span><span class="s2">"The string is nonempty"</span>
<span class="gp">&gt;&gt; </span>end
<span class="gp">=&gt; </span><span class="s2">"The string is nonempty"</span>
</pre></div>
</div>
<p>布尔值还可以使用 <code>&amp;&amp;</code>（和）、<code>||</code>（或）和 <code>!</code>（非）操作符结合使用：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>x <span class="o">=</span> <span class="s2">"foo"</span>
<span class="gp">=&gt; </span><span class="s2">"foo"</span>
<span class="gp">&gt;&gt; </span>y <span class="o">=</span> <span class="s2">""</span>
<span class="gp">=&gt; </span><span class="s2">""</span>
<span class="gp">&gt;&gt; </span>puts <span class="s2">"Both strings are empty"</span> <span class="k">if </span>x.empty? <span class="o">&amp;&amp;</span> y.empty?
<span class="gp">=&gt; </span>nil
<span class="gp">&gt;&gt; </span>puts <span class="s2">"One of the strings is empty"</span> <span class="k">if </span>x.empty? <span class="o">||</span> y.empty?
<span class="s2">"One of the strings is empty"</span>
<span class="gp">=&gt; </span>nil
<span class="gp">&gt;&gt; </span>puts <span class="s2">"x is not empty"</span> <span class="k">if</span> !x.empty?
<span class="s2">"x is not empty"</span>
<span class="gp">=&gt; </span>nil
</pre></div>
</div>
<p>因为 Ruby 中的一切都是对象，那么 <code>nil</code> 也是对象，所以它也可以响应方法。举个例子，<code>to_s</code> 方法基本上可以把任何对象转换成字符串：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>nil.to_s
<span class="gp">=&gt; </span><span class="s2">""</span>
</pre></div>
</div>
<p>结果显然是个空字符串，我们可以通过下面的方法串联（chain）验证这一点：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>nil.empty?
NoMethodError: You have a nil object when you didn<span class="se">\'</span>t expect it!
You might have expected an instance of Array.
The error occurred <span class="k">while </span>evaluating nil.empty?
<span class="gp">&gt;&gt; </span>nil.to_s.empty?      <span class="c"># 消息串联</span>
<span class="gp">=&gt; </span><span class="nb">true</span>
</pre></div>
</div>
<p>我们看到，<code>nil</code> 对象本身无法响应 <code>empty?</code> 方法，但是 <code>nil.to_s</code> 可以。</p>

<p>有一个特殊的方法可以测试对象是否为空，你应该能猜到这个方法：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span><span class="s2">"foo"</span>.nil?
<span class="gp">=&gt; </span><span class="nb">false</span>
<span class="gp">&gt;&gt; </span><span class="s2">""</span>.nil?
<span class="gp">=&gt; </span><span class="nb">false</span>
<span class="gp">&gt;&gt; </span>nil.nil?
<span class="gp">=&gt; </span><span class="nb">true</span>
</pre></div>
</div>
<p>下面的代码</p>

<div class="codeblock"><div class="highlight type-shell"><pre>puts <span class="s2">"x is not empty"</span> <span class="k">if</span> !x.empty?
</pre></div>
</div>
<p>说明了关键词 <code>if</code> 的另一种用法：你可以编写一个当且只当 <code>if</code> 后面的表达式为真时才执行的语句。对应的，关键词 <code>unless</code> 也可以这么用：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>string <span class="o">=</span> <span class="s2">"foobar"</span>
<span class="gp">&gt;&gt; </span>puts <span class="s2">"The string '#{string}' is nonempty."</span> unless string.empty?
The string <span class="s1">'foobar'</span> is nonempty.
<span class="gp">=&gt; </span>nil
</pre></div>
</div>
<p>我们需要注意一下 <code>nil</code> 的特殊性，除了 <code>false</code> 本身之外，所有的 Ruby 对象中它是唯一一个布尔值为“假”的：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span><span class="k">if </span>nil
<span class="gp">&gt;&gt;   </span><span class="nb">true</span>
<span class="gp">&gt;&gt; </span><span class="k">else</span>
<span class="gp">&gt;&gt;   </span><span class="nb">false</span>        <span class="c"># nil 是假值</span>
<span class="gp">&gt;&gt; </span>end
<span class="gp">=&gt; </span><span class="nb">false</span>
</pre></div>
</div>
<p>基本上所有其他的 Ruby 对象都是“真”的，包括 0：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span><span class="k">if </span>0
<span class="gp">&gt;&gt;   </span><span class="nb">true</span>        <span class="c"># 0（除了 nil 和 false 之外的一切对象）是真值</span>
<span class="gp">&gt;&gt; </span><span class="k">else</span>
<span class="gp">&gt;&gt;   </span><span class="nb">false</span>
<span class="gp">&gt;&gt; </span>end
<span class="gp">=&gt; </span><span class="nb">true</span>
</pre></div>
</div>
<h3 id='section-4-2-4'><span>4.2.4</span> 定义方法</h3>


<p>在控制台中，我们可以像定义 <code>home</code> 动作（代码 3.6）和 <code>full_title</code> 帮助方法（代码 4.2）一样进行方法定义。（在控制台中定义方法有点麻烦，我们一般会在文件中定义，不过用来演示还行。）例如，我们要定义一个名为 <code>string_message</code> 的方法，可以接受一个参数，返回值取决于参数是否为空：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>def string_message<span class="o">(</span>string<span class="o">)</span>
<span class="gp">&gt;&gt;   </span><span class="k">if </span>string.empty?
<span class="gp">&gt;&gt;     </span><span class="s2">"It's an empty string!"</span>
<span class="gp">&gt;&gt;   </span><span class="k">else</span>
<span class="gp">&gt;&gt;     </span><span class="s2">"The string is nonempty."</span>
<span class="gp">&gt;&gt;   </span>end
<span class="gp">&gt;&gt; </span>end
<span class="gp">=&gt; </span>nil
<span class="gp">&gt;&gt; </span>puts string_message<span class="o">(</span><span class="s2">""</span><span class="o">)</span>
It<span class="se">\'</span>s an empty string!
<span class="gp">&gt;&gt; </span>puts string_message<span class="o">(</span><span class="s2">"foobar"</span><span class="o">)</span>
The string is nonempty.
</pre></div>
</div>
<p>注意 Ruby 方法会非显式的返回值：返回最后一个语句的值。在上面的这个例子中，返回的值会根据参数是否为空而返回两个字符串中的一个。Ruby 也支持显式的指定返回值，下面的代码和上面的效果一样：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>def string_message<span class="o">(</span>string<span class="o">)</span>
<span class="gp">&gt;&gt;   </span><span class="k">return</span> <span class="s2">"It's an empty string!"</span> <span class="k">if </span>string.empty?
<span class="gp">&gt;&gt;   </span><span class="k">return</span> <span class="s2">"The string is nonempty."</span>
<span class="gp">&gt;&gt; </span>end
</pre></div>
</div>
<p>细心的读者可能会发现其实这里第二个 <code>return</code> 不是必须的，作为方法的最后一个表达式，不管有没有 <code>return</code>，字符串 <code>"The string is nonempty."</code> 都会作为返回值。不过两处都加上 <code>return</code> 看起来更好看。</p>

<h3 id='section-4-2-5'><span>4.2.5</span> 回顾一下标题的帮助方法</h3>


<p>下面我们来理解一下代码 4.2 中的 <code>full_title</code> 帮助方法：<sup class="footnote" id="fnref-4-5"><a href="#fn-4-5" rel="footnote">5</a></sup></p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="k">module</span> <span class="nn">ApplicationHelper</span>

  <span class="c1"># 根据所在页面返回完整的标题                           # 在文档中显示的注释</span>
  <span class="k">def</span> <span class="nf">full_title</span><span class="p">(</span><span class="n">page_title</span><span class="p">)</span>                          <span class="c1"># 方法定义</span>
    <span class="n">base_title</span> <span class="o">=</span> <span class="s2">"Ruby on Rails Tutorial Sample App"</span>  <span class="c1"># 变量赋值</span>
    <span class="k">if</span> <span class="n">page_title</span><span class="p">.</span><span class="nf">empty?</span>                              <span class="c1"># 布尔测试</span>
      <span class="n">base_title</span>                                      <span class="c1"># 非显式返回值</span>
    <span class="k">else</span>
      <span class="s2">"</span><span class="si">#{</span><span class="n">base_title</span><span class="si">}</span><span class="s2"> | </span><span class="si">#{</span><span class="n">page_title</span><span class="si">}</span><span class="s2">"</span>                 <span class="c1"># 字符串插值</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>方法定义、变量赋值、布尔测试、流程控制和字符串插值——组合在一起定义了一个可以在网站布局中使用的帮助方法。还用到了 <code>module ApplicationHelper</code>：module 为我们提供了一种把相关方法组织在一起的方式，稍后我们可以使用 <code>include</code> 把它插入其他的类中。编写一般的 Ruby 程序时，你要自己定义一个 module 然后再显式的将其引入类中，但是对于帮助方法所在的 module 就交由 Rails 来处理引入了，最终的结果是 <code>full_title</code> 方法<a href="http://catb.org/jargon/html/A/automagically.html">自动的</a>就可以在所有的视图中使用了。</p>

<h2 id='section-4-3'><span>4.3</span> 其他的数据类型</h2>


<p>虽然 Web 程序一般都是处理字符串，但也需要其他的数据类型来生成字符串。本节我们就来介绍一些对开发 Rails 应用程序很重要的 Ruby 中的其他数据类型。</p>

<h3 id='section-4-3-1'><span>4.3.1</span> 数组和 Range</h3>


<p>数组就是一组顺序特定的元素。本书尚且没有用过数组，不过理解了数组就能很好的理解 Hash （<a href="chapter4.html#section-4-3-3">4.3.3 节</a>），也有助于理解 Rails 中的数据模型（例如 <a href="chapter2.html#section-2-3-3">2.3.3 节</a>中用到的 <code>has_many</code> 关联，<a href="chapter10.html#section-10-1-3">10.1.3 节</a>会做详细介绍）。</p>

<p>目前我们已经花了很多的时间理解字符串，从字符串过渡到数组可以从 <code>split</code> 方法开始：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt;  </span><span class="s2">"foo bar     baz"</span>.split     <span class="c"># 把字符串分割成有三个元素的数组</span>
<span class="gp">=&gt; </span><span class="o">[</span><span class="s2">"foo"</span>, <span class="s2">"bar"</span>, <span class="s2">"baz"</span><span class="o">]</span>
</pre></div>
</div>
<p>上述代码的返回结果是一个有三个元素的数组。默认情况下，<code>split</code> 在空格处把字符串分割成数组，当然你几乎可以在任何地方进行分割：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span><span class="s2">"fooxbarxbazx"</span>.split<span class="o">(</span><span class="s1">'x'</span><span class="o">)</span>
<span class="gp">=&gt; </span><span class="o">[</span><span class="s2">"foo"</span>, <span class="s2">"bar"</span>, <span class="s2">"baz"</span><span class="o">]</span>
</pre></div>
</div>
<p>和其他编程语言的习惯一样，Ruby 中数组的索引（index）也是从零开始的，数组中第一个元素的索引是 0，第二个元素的索引是 1，依此类推：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>a <span class="o">=</span> <span class="o">[</span>42, 8, 17]
<span class="gp">=&gt; </span><span class="o">[</span>42, 8, 17]
<span class="gp">&gt;&gt; </span>a[0]               <span class="c"># Ruby 使用方括号获取数组元素</span>
<span class="gp">=&gt; </span>42
<span class="gp">&gt;&gt; </span>a[1]
<span class="gp">=&gt; </span>8
<span class="gp">&gt;&gt; </span>a[2]
<span class="gp">=&gt; </span>17
<span class="gp">&gt;&gt; </span>a[-1]              <span class="c"># 索引还可以是负数</span>
<span class="gp">=&gt; </span>17
</pre></div>
</div>
<p>我们看到，在 Ruby 中是使用方括号来获取数组元素的。除了这种方法，Ruby 还为一些常用的元素获取操作提供了别名（synonym）：<sup class="footnote" id="fnref-4-6"><a href="#fn-4-6" rel="footnote">6</a></sup></p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>a                  <span class="c"># 只是为了看一下 a 的值是什么</span>
<span class="gp">=&gt; </span><span class="o">[</span>42, 8, 17]
<span class="gp">&gt;&gt; </span>a.first
<span class="gp">=&gt; </span>42
<span class="gp">&gt;&gt; </span>a.second
<span class="gp">=&gt; </span>8
<span class="gp">&gt;&gt; </span>a.last
<span class="gp">=&gt; </span>17
<span class="gp">&gt;&gt; </span>a.last <span class="o">==</span> a[-1]    <span class="c"># 用 == 进行对比</span>
<span class="gp">=&gt; </span><span class="nb">true</span>
</pre></div>
</div>
<p>最后一行介绍了相等比较操作符 <code>==</code>，Ruby 和其他语言一样还提供了对应的 <code>!=</code>（不等）等其他的操作符：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>x <span class="o">=</span> a.length       <span class="c"># 和字符串一样，数组也可以响应 length 方法</span>
<span class="gp">=&gt; </span>3
<span class="gp">&gt;&gt; </span>x <span class="o">==</span> 3
<span class="gp">=&gt; </span><span class="nb">true</span>
<span class="gp">&gt;&gt; </span>x <span class="o">==</span> 1
<span class="gp">=&gt; </span><span class="nb">false</span>
<span class="gp">&gt;&gt; </span>x !<span class="o">=</span> 1
<span class="gp">=&gt; </span><span class="nb">true</span>
<span class="gp">&gt;&gt; </span>x &gt;<span class="o">=</span> 1
<span class="gp">=&gt; </span><span class="nb">true</span>
<span class="gp">&gt;&gt; </span>x &lt; 1
<span class="gp">=&gt; </span><span class="nb">false</span>
</pre></div>
</div>
<p>除了 <code>length</code>（上述代码的第一行）之外，数组还可以响应一堆其他的方法：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>a
<span class="gp">=&gt; </span><span class="o">[</span>42, 8, 17]
<span class="gp">&gt;&gt; </span>a.sort
<span class="gp">=&gt; </span><span class="o">[</span>8, 17, 42]
<span class="gp">&gt;&gt; </span>a.reverse
<span class="gp">=&gt; </span><span class="o">[</span>17, 8, 42]
<span class="gp">&gt;&gt; </span>a.shuffle
<span class="gp">=&gt; </span><span class="o">[</span>17, 42, 8]
<span class="gp">&gt;&gt; </span>a
<span class="gp">=&gt; </span><span class="o">[</span>42, 8, 17]
</pre></div>
</div>
<p>注意，上面的方法都没有修改 <code>a</code> 的值。如果你想修改数组的值要使用对应的“炸弹（bang）”方法（之所以这么叫是因为这里的感叹号经常都读作“bang”）：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>a
<span class="gp">=&gt; </span><span class="o">[</span>42, 8, 17]
<span class="gp">&gt;&gt; </span>a.sort!
<span class="gp">=&gt; </span><span class="o">[</span>8, 17, 42]
<span class="gp">&gt;&gt; </span>a
<span class="gp">=&gt; </span><span class="o">[</span>8, 17, 42]
</pre></div>
</div>
<p>你还可以使用 <code>push</code> 方法向数组中添加元素，或者使用等价的 <code>&lt;&lt;</code> 操作符：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>a.push<span class="o">(</span>6<span class="o">)</span>                  <span class="c"># 把 6 加到数组结尾</span>
<span class="gp">=&gt; </span><span class="o">[</span>42, 8, 17, 6]
<span class="gp">&gt;&gt; </span>a <span class="sh">&lt;&lt; 7                     # 把 7 加到数组结尾
=&gt; [42, 8, 17, 6, 7]
&gt;&gt; a &lt;&lt; "foo" &lt;&lt; "bar"        # 串联操作
=&gt; [42, 8, 17, 6, 7, "foo", "bar"]
</span></pre></div>
</div>
<p>最后一个例子说明你可以把添加操作串在一起操作；同时也说明，Ruby 不像很多其他的语言，数组可以包含不同类型的数据（本例中是数字和字符串混合）。</p>

<p>前面我们用 <code>split</code> 把字符串分割成字符串，我们还可以使用 <code>join</code> 方法进行相反的操作：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>a
<span class="gp">=&gt; </span><span class="o">[</span>42, 8, 17, 7, <span class="s2">"foo"</span>, <span class="s2">"bar"</span><span class="o">]</span>
<span class="gp">&gt;&gt; </span>a.join                       <span class="c"># 没有连接符</span>
<span class="gp">=&gt; </span><span class="s2">"428177foobar"</span>
<span class="gp">&gt;&gt; </span>a.join<span class="o">(</span><span class="s1">', '</span><span class="o">)</span>                 <span class="c"># 连接符是一个逗号和空格</span>
<span class="gp">=&gt; </span><span class="s2">"42, 8, 17, 7, foo, bar"</span>
</pre></div>
</div>
<p>和数组有点类似的是 Range，使用 <code>to_a</code> 方法把它转换成数组或许更好理解：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>0..9
<span class="gp">=&gt; </span>0..9
<span class="gp">&gt;&gt; </span>0..9.to_a              <span class="c"># 错了，to_a 在 9 上调用了</span>
NoMethodError: undefined method <span class="sb">`</span>to_a<span class="se">\'</span> <span class="k">for </span>9:Fixnum
<span class="gp">&gt;&gt; </span><span class="o">(</span>0..9<span class="o">)</span>.to_a            <span class="c"># 调用 to_a 要用括号包住 Range</span>
<span class="gp">=&gt; </span><span class="o">[</span>0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</pre></div>
</div>
<p>虽然 <code>0..9</code> 是一个合法的 Range，不过上面第二个表达式告诉我们调用方法时要加上括号。</p>

<p>Range 经常被用来获取一组数组元素：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>a <span class="o">=</span> %w[foo bar baz quux]         <span class="c"># %w 创建一个元素为字符串的数组</span>
<span class="gp">=&gt; </span><span class="o">[</span><span class="s2">"foo"</span>, <span class="s2">"bar"</span>, <span class="s2">"baz"</span>, <span class="s2">"quux"</span><span class="o">]</span>
<span class="gp">&gt;&gt; </span>a[0..2]
<span class="gp">=&gt; </span><span class="o">[</span><span class="s2">"foo"</span>, <span class="s2">"bar"</span>, <span class="s2">"baz"</span><span class="o">]</span>
</pre></div>
</div>
<p>Range 也可使用字母：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span><span class="o">(</span><span class="s1">'a'</span>..<span class="s1">'e'</span><span class="o">)</span>.to_a
<span class="gp">=&gt; </span><span class="o">[</span><span class="s2">"a"</span>, <span class="s2">"b"</span>, <span class="s2">"c"</span>, <span class="s2">"d"</span>, <span class="s2">"e"</span><span class="o">]</span>
</pre></div>
</div>
<h3 id='section-4-3-2'><span>4.3.2</span> 块</h3>


<p>数组和 Range 可以响应的方法中有很多都可以跟着一个块（block），这是 Ruby 中最强大也是最难理解的功能：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span><span class="o">(</span>1..5<span class="o">)</span>.each <span class="o">{</span> |i| puts 2 <span class="k">*</span> i <span class="o">}</span>
2
4
6
8
10
<span class="gp">=&gt; </span>1..5
</pre></div>
</div>
<p>这个代码在 Range <code>(1..5)</code> 上调用了 <code>each</code> 方法，然后又把 <code>{ |i| puts 2*i }</code> 这个块传递给 <code>each</code> 方法。<code>|i|</code> 两边的竖杠在 Ruby 句法中是用来定义块变量的。只有这个方法才知道如何处理后面跟着的块。本例中，Range 的 <code>each</code> 方法会处理后面的块，块中有一个本地变量 <code>i</code>，<code>each</code> 会将 Range 中的各个值传进块中然后执行相应的操作。</p>

<p>花括号是一种定义块的方法，还有另一种方法可用：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span><span class="o">(</span>1..5<span class="o">)</span>.each <span class="k">do</span> |i|
<span class="gp">?&gt;   </span>puts 2 <span class="k">*</span> i
<span class="gp">&gt;&gt; </span>end
2
4
6
8
10
<span class="gp">=&gt; </span>1..5
</pre></div>
</div>
<p>块可以多于一行，也经常是多于一行的。本书中我们会遵照一个常用的约定，当块只有一行简单的代码时使用花括号形式；当块是一行很长的代码，或者多行时使用 <code>do..end</code> 形式：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span><span class="o">(</span>1..5<span class="o">)</span>.each <span class="k">do</span> |number|
<span class="gp">?&gt;   </span>puts 2 <span class="k">*</span> number
<span class="gp">&gt;&gt;   </span>puts <span class="s1">'--'</span>
<span class="gp">&gt;&gt; </span>end
2
--
4
--
6
--
8
--
10
--
<span class="gp">=&gt; </span>1..5
</pre></div>
</div>
<p>上面的代码用 <code>number</code> 代替了 <code>i</code>，我想告诉你的是任何变量名都可以使用。</p>

<p>除非你已经有了一些编程知识，否则对块的理解是没有捷径的。你要做的是多看，看得多了最后你就会习惯它的用法了。<sup class="footnote" id="fnref-4-7"><a href="#fn-4-7" rel="footnote">7</a></sup> 幸好人类擅长于从实例中归纳出一般性。下面是一些例子，其中几个用到了 <code>map</code> 方法：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>3.times <span class="o">{</span> puts <span class="s2">"Betelgeuse!"</span> <span class="o">}</span>   <span class="c"># 3.times 后跟的块没有变量</span>
<span class="s2">"Betelgeuse!"</span>
<span class="s2">"Betelgeuse!"</span>
<span class="s2">"Betelgeuse!"</span>
<span class="gp">=&gt; </span>3
<span class="gp">&gt;&gt; </span><span class="o">(</span>1..5<span class="o">)</span>.map <span class="o">{</span> |i| i<span class="k">**</span>2 <span class="o">}</span>          <span class="c"># ** 表示幂</span>
<span class="gp">=&gt; </span><span class="o">[</span>1, 4, 9, 16, 25]
<span class="gp">&gt;&gt; </span>%w[a b c]                        <span class="c"># 再说一下，%w 可以创建元素为字符串的数组</span>
<span class="gp">=&gt; </span><span class="o">[</span><span class="s2">"a"</span>, <span class="s2">"b"</span>, <span class="s2">"c"</span><span class="o">]</span>
<span class="gp">&gt;&gt; </span>%w[a b c].map <span class="o">{</span> |char| char.upcase <span class="o">}</span>
<span class="gp">=&gt; </span><span class="o">[</span><span class="s2">"A"</span>, <span class="s2">"B"</span>, <span class="s2">"C"</span><span class="o">]</span>
<span class="gp">&gt;&gt; </span>%w[A B C].map <span class="o">{</span> |char| char.downcase <span class="o">}</span>
<span class="gp">=&gt; </span><span class="o">[</span><span class="s2">"a"</span>, <span class="s2">"b"</span>, <span class="s2">"c"</span><span class="o">]</span>
</pre></div>
</div>
<p>上面的代码说明，<code>map</code> 方法返回的是在数组或 Range 的每个元素上执行块中代码后的结果。</p>

<p>现在我们就可以来理解一下我在 <a href="chapter1.html#section-1-4-4">1.4.4 节</a>中用来生成随机二级域名的那行 Ruby 代码了：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="o">(</span><span class="s1">'a'</span>..<span class="s1">'z'</span><span class="o">)</span>.to_a.shuffle[0..7].join
</pre></div>
</div>
<p>我们一步一步分解一下：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span><span class="o">(</span><span class="s1">'a'</span>..<span class="s1">'z'</span><span class="o">)</span>.to_a                     <span class="c"># 字母表数组</span>
<span class="gp">=&gt; </span><span class="o">[</span><span class="s2">"a"</span>, <span class="s2">"b"</span>, <span class="s2">"c"</span>, <span class="s2">"d"</span>, <span class="s2">"e"</span>, <span class="s2">"f"</span>, <span class="s2">"g"</span>, <span class="s2">"h"</span>, <span class="s2">"i"</span>, <span class="s2">"j"</span>, <span class="s2">"k"</span>, <span class="s2">"l"</span>, <span class="s2">"m"</span>, <span class="s2">"n"</span>, <span class="s2">"o"</span>,
<span class="s2">"p"</span>, <span class="s2">"q"</span>, <span class="s2">"r"</span>, <span class="s2">"s"</span>, <span class="s2">"t"</span>, <span class="s2">"u"</span>, <span class="s2">"v"</span>, <span class="s2">"w"</span>, <span class="s2">"x"</span>, <span class="s2">"y"</span>, <span class="s2">"z"</span><span class="o">]</span>
<span class="gp">&gt;&gt; </span><span class="o">(</span><span class="s1">'a'</span>..<span class="s1">'z'</span><span class="o">)</span>.to_a.shuffle             <span class="c"># 打乱数组</span>
<span class="gp">=&gt; </span><span class="o">[</span><span class="s2">"c"</span>, <span class="s2">"g"</span>, <span class="s2">"l"</span>, <span class="s2">"k"</span>, <span class="s2">"h"</span>, <span class="s2">"z"</span>, <span class="s2">"s"</span>, <span class="s2">"i"</span>, <span class="s2">"n"</span>, <span class="s2">"d"</span>, <span class="s2">"y"</span>, <span class="s2">"u"</span>, <span class="s2">"t"</span>, <span class="s2">"j"</span>, <span class="s2">"q"</span>,
<span class="s2">"b"</span>, <span class="s2">"r"</span>, <span class="s2">"o"</span>, <span class="s2">"f"</span>, <span class="s2">"e"</span>, <span class="s2">"w"</span>, <span class="s2">"v"</span>, <span class="s2">"m"</span>, <span class="s2">"a"</span>, <span class="s2">"x"</span>, <span class="s2">"p"</span><span class="o">]</span>
<span class="gp">&gt;&gt; </span><span class="o">(</span><span class="s1">'a'</span>..<span class="s1">'z'</span><span class="o">)</span>.to_a.shuffle[0..7]       <span class="c"># 取出前面的 8 个元素</span>
<span class="gp">=&gt; </span><span class="o">[</span><span class="s2">"f"</span>, <span class="s2">"w"</span>, <span class="s2">"i"</span>, <span class="s2">"a"</span>, <span class="s2">"h"</span>, <span class="s2">"p"</span>, <span class="s2">"c"</span>, <span class="s2">"x"</span><span class="o">]</span>
<span class="gp">&gt;&gt; </span><span class="o">(</span><span class="s1">'a'</span>..<span class="s1">'z'</span><span class="o">)</span>.to_a.shuffle[0..7].join  <span class="c"># 将取出的元素合并成字符串</span>
<span class="gp">=&gt; </span><span class="s2">"mznpybuj"</span>
</pre></div>
</div>
<h3 id='section-4-3-3'><span>4.3.3</span> Hash 和 Symbol</h3>


<p>Hash 本质上就是数组，只不过它的索引不局限于使用数字。（实际上在一些语言中，特别是 Perl，因为这个原因就把 Hash 叫做关联数组（associative array）。）Hash 的索引（或者叫“键”）几乎可以是任何对象。例如，我们可以使用字符串当键：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>user <span class="o">=</span> <span class="o">{}</span>                          <span class="c"># {} 是一个空 Hash</span>
<span class="gp">=&gt; </span><span class="o">{}</span>
<span class="gp">&gt;&gt; </span>user[<span class="s2">"first_name"</span><span class="o">]</span> <span class="o">=</span> <span class="s2">"Michael"</span>     <span class="c"># 键为 "first_name"，值为 "Michael"</span>
<span class="gp">=&gt; </span><span class="s2">"Michael"</span>
<span class="gp">&gt;&gt; </span>user[<span class="s2">"last_name"</span><span class="o">]</span> <span class="o">=</span> <span class="s2">"Hartl"</span>        <span class="c"># 键为 "last_name"，值为 "Hartl"</span>
<span class="gp">=&gt; </span><span class="s2">"Hartl"</span>
<span class="gp">&gt;&gt; </span>user[<span class="s2">"first_name"</span><span class="o">]</span>                 <span class="c"># 获取元素的方式类似数组</span>
<span class="gp">=&gt; </span><span class="s2">"Michael"</span>
<span class="gp">&gt;&gt; </span>user                               <span class="c"># Hash 的字面量形式</span>
<span class="gp">=&gt; </span><span class="o">{</span><span class="s2">"last_name"</span><span class="o">=</span>&gt;<span class="s2">"Hartl"</span>, <span class="s2">"first_name"</span><span class="o">=</span>&gt;<span class="s2">"Michael"</span><span class="o">}</span>
</pre></div>
</div>
<p>Hash 通过一对花括号中包含一些键值对的形式表示，只有一对花括号而没有键值对（<code>{}</code>）就是一个空 Hash。需要注意，Hash 中的花括号和块中的花括号不是一个概念。（是的，这可能会让你迷惑。）不过，Hash 虽然和数组类似，但却有一个很重要的区别：Hash 的元素没有特定的顺序。<sup class="footnote" id="fnref-4-8"><a href="#fn-4-8" rel="footnote">8</a></sup> 如果顺序很重要的话就要使用数组了。</p>

<p>通过方括号的形式每次定义一个元素的方式不太敏捷，使用 <code>=&gt;</code> 分隔的键值对这种字面量的形式定义 Hash 要简洁得多，我们称后一种方式为“hashrocket”：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>user <span class="o">=</span> <span class="o">{</span> <span class="s2">"first_name"</span> <span class="o">=</span>&gt; <span class="s2">"Michael"</span>, <span class="s2">"last_name"</span> <span class="o">=</span>&gt; <span class="s2">"Hartl"</span> <span class="o">}</span>
<span class="gp">=&gt; </span><span class="o">{</span><span class="s2">"last_name"</span><span class="o">=</span>&gt;<span class="s2">"Hartl"</span>, <span class="s2">"first_name"</span><span class="o">=</span>&gt;<span class="s2">"Michael"</span><span class="o">}</span>
</pre></div>
</div>
<p>在上面的代码中我用到了一个 Ruby 句法约定，在左花括号后面和右花括号前面加入了一个空格，控制台会忽略这些空格。（不要问我为什么这些空格是约定俗成的，或许是某个 Ruby 编程大牛喜欢这种形式，然后约定就产生了。）</p>

<p>目前为止我们的键用的都是字符串，但在 Rails 中用 Symbol 当键却很常见。Symbol 看起来像字符串，只不过没有包含在一对引号中，而是在前面加一个冒号。例如，<code>:name</code> 就是一个 Symbol。你可以把 Symbol 看成没有约束的字符串：<sup class="footnote" id="fnref-4-9"><a href="#fn-4-9" rel="footnote">9</a></sup></p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span><span class="s2">"name"</span>.split<span class="o">(</span><span class="s1">''</span><span class="o">)</span>
<span class="gp">=&gt; </span><span class="o">[</span><span class="s2">"n"</span>, <span class="s2">"a"</span>, <span class="s2">"m"</span>, <span class="s2">"e"</span><span class="o">]</span>
<span class="gp">&gt;&gt; </span>:name.split<span class="o">(</span><span class="s1">''</span><span class="o">)</span>
NoMethodError: undefined method <span class="sb">`</span>split<span class="s1">' for :name:Symbol
&gt;&gt; "foobar".reverse
=&gt; "raboof"
&gt;&gt; :foobar.reverse
NoMethodError: undefined method `reverse'</span> <span class="k">for</span> :foobar:Symbol
</pre></div>
</div>
<p>Symbol 是 Ruby 特有的一个数据类型，其他语言很少用到，初看起来感觉很奇怪，不过 Rails 经常用到它，所以你很快就会习惯的。</p>

<p>用 Symbol 当键，我们可以按照如下的方式定义一个 <code>user</code> Hash：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>user <span class="o">=</span> <span class="o">{</span> :name <span class="o">=</span>&gt; <span class="s2">"Michael Hartl"</span>, :email <span class="o">=</span>&gt; <span class="s2">"michael@example.com"</span> <span class="o">}</span>
<span class="gp">=&gt; </span><span class="o">{</span>:name<span class="o">=</span>&gt;<span class="s2">"Michael Hartl"</span>, :email<span class="o">=</span>&gt;<span class="s2">"michael@example.com"</span><span class="o">}</span>
<span class="gp">&gt;&gt; </span>user[:name]              <span class="c"># 获取 :name 对应的值</span>
<span class="gp">=&gt; </span><span class="s2">"Michael Hartl"</span>
<span class="gp">&gt;&gt; </span>user[:password]          <span class="c"># 获取一个未定义的键对应的值</span>
<span class="gp">=&gt; </span>nil
</pre></div>
</div>
<p>从上面的例子我们可以看出，Hash 中没有定义的键对应的值是 <code>nil</code>。</p>

<p>因为 Symbol 当键的情况太普遍了，Ruby 1.9 干脆就为这种情况定义了一个新的句法：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>h1 <span class="o">=</span> <span class="o">{</span> :name <span class="o">=</span>&gt; <span class="s2">"Michael Hartl"</span>, :email <span class="o">=</span>&gt; <span class="s2">"michael@example.com"</span> <span class="o">}</span>
<span class="gp">=&gt; </span><span class="o">{</span>:name<span class="o">=</span>&gt;<span class="s2">"Michael Hartl"</span>, :email<span class="o">=</span>&gt;<span class="s2">"michael@example.com"</span><span class="o">}</span>
<span class="gp">&gt;&gt; </span>h2 <span class="o">=</span> <span class="o">{</span> name: <span class="s2">"Michael Hartl"</span>, email: <span class="s2">"michael@example.com"</span> <span class="o">}</span>
<span class="gp">=&gt; </span><span class="o">{</span>:name<span class="o">=</span>&gt;<span class="s2">"Michael Hartl"</span>, :email<span class="o">=</span>&gt;<span class="s2">"michael@example.com"</span><span class="o">}</span>
<span class="gp">&gt;&gt; </span>h1 <span class="o">==</span> h2
<span class="gp">=&gt; </span><span class="nb">true</span>
</pre></div>
</div>
<p>第二个命令把 hashrocket 形式的键值对变成了键后跟着一个冒号然后再跟着一个值的形式：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="p">{</span> <span class="nb">name</span><span class="p">:</span> <span class="s2">"Michael Hartl"</span><span class="p">,</span> <span class="ss">email: </span><span class="s2">"michael@example.com"</span> <span class="p">}</span>
</pre></div>
</div>
<p>这种结构更好的沿袭了其他语言（例如 JavaScript）中 Hash 的表现方式，在 Rails 社区中也越来越受欢迎。这两种方式现在都在使用，所以你要能识别它们。</p>

<p>Hash 元素的值可以是任何对象，甚至是一个 Hash，如代码 4.6 所示。</p>

<div class="codeblock has-caption" id="codeblock-4-6"><p class="caption"><span>代码 4.6：</span>Hash 嵌套</p><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>params <span class="o">=</span> <span class="o">{}</span>        <span class="c"># 定义一个名为 params（parameters 的简称）的 Hash</span>
<span class="gp">=&gt; </span><span class="o">{}</span>
<span class="gp">&gt;&gt; </span>params[:user] <span class="o">=</span> <span class="o">{</span> name: <span class="s2">"Michael Hartl"</span>, email: <span class="s2">"mhartl@example.com"</span> <span class="o">}</span>
<span class="gp">=&gt; </span><span class="o">{</span>:name<span class="o">=</span>&gt;<span class="s2">"Michael Hartl"</span>, :email<span class="o">=</span>&gt;<span class="s2">"mhartl@example.com"</span><span class="o">}</span>
<span class="gp">&gt;&gt; </span>params
<span class="gp">=&gt; </span><span class="o">{</span>:user<span class="o">=</span>&gt;<span class="o">{</span>:name<span class="o">=</span>&gt;<span class="s2">"Michael Hartl"</span>, :email<span class="o">=</span>&gt;<span class="s2">"mhartl@example.com"</span><span class="o">}}</span>
<span class="gp">&gt;&gt;  </span>params[:user][:email]
<span class="gp">=&gt; </span><span class="s2">"mhartl@example.com"</span>
</pre></div>
</div>
<p>这种 Hash 中有 Hash 的形式（或称为 Hash 嵌套）在 Rails 中大量的使用，我们从 <a href="chapter7.html#section-7-3">7.3 节</a>开始会接触到。</p>

<p>与数组和 Range 一样，Hash 也可以响应 <code>each</code> 方法。例如，一个名为 <code>flash</code> 的 Hash，它的键是两个条件判断，<code>:success</code> 和 <code>:error</code>：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>flash <span class="o">=</span> <span class="o">{</span> success: <span class="s2">"It worked!"</span>, error: <span class="s2">"It failed."</span> <span class="o">}</span>
<span class="gp">=&gt; </span><span class="o">{</span>:success<span class="o">=</span>&gt;<span class="s2">"It worked!"</span>, :error<span class="o">=</span>&gt;<span class="s2">"It failed."</span><span class="o">}</span>
<span class="gp">&gt;&gt; </span>flash.each <span class="k">do</span> |key, value|
<span class="gp">?&gt;   </span>puts <span class="s2">"Key #{key.inspect} has value #{value.inspect}"</span>
<span class="gp">&gt;&gt; </span>end
Key :success has value <span class="s2">"It worked!"</span>
Key :error has value <span class="s2">"It failed."</span>
</pre></div>
</div>
<p>注意，数组的 <code>each</code> 方法后面的块只有一个变量，而 Hash 的 <code>each</code> 后面的块接受两个变量，<code>key</code> 和 <code>value</code>。所以 Hash 的 <code>each</code> 方法每次遍历都会以一个键值对为基本单位进行。</p>

<p>上面的示例中用到了很有用的 <code>inspect</code> 方法，返回被调用对象的字符串字面量表现形式：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>puts <span class="o">(</span>1..5<span class="o">)</span>.to_a            <span class="c"># 把数组作为字符串输出</span>
1
2
3
4
5
<span class="gp">&gt;&gt; </span>puts <span class="o">(</span>1..5<span class="o">)</span>.to_a.inspect    <span class="c"># 输出一个数组字面量形式</span>
<span class="o">[</span>1, 2, 3, 4, 5]
<span class="gp">&gt;&gt; </span>puts :name, :name.inspect
name
:name
<span class="gp">&gt;&gt; </span>puts <span class="s2">"It worked!"</span>, <span class="s2">"It worked!"</span>.inspect
It worked!
<span class="s2">"It worked!"</span>
</pre></div>
</div>
<p>顺便说一下，因为使用 <code>inspect</code> 输出对象的方式经常使用，为此还有一个专门的快捷方式，<code>p</code> 方法：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>p :name             <span class="c"># 等价于 puts :name.inspect</span>
:name
</pre></div>
</div>
<h3 id='section-4-3-4'><span>4.3.4</span> 重温引入 CSS 的代码</h3>


<p>现在我们要重新认识一下代码 4.1 中在布局中引入 CSS 的代码：</p>

<div class="codeblock"><div class="highlight type-erb"><pre><span class="cp">&lt;%=</span> <span class="n">stylesheet_link_tag</span> <span class="s2">"application"</span><span class="p">,</span> <span class="ss">media: </span><span class="s2">"all"</span><span class="p">,</span>
                                       <span class="s2">"data-turbolinks-track"</span> <span class="o">=&gt;</span> <span class="kp">true</span> <span class="cp">%&gt;</span>
</pre></div>
</div>
<p>我们现在基本上可以理解这行代码了。在 <a href="chapter4.html#section-4-1">4.1 节</a>中简单的提到过，Rails 定义了一个特殊的函数用来引入样式表，下面的代码</p>

<div class="codeblock"><div class="highlight type-erb"><pre>stylesheet_link_tag "application", media: "all",
                                   "data-turbolinks-track" =&gt; true
</pre></div>
</div>
<p>就是对这个函数的调用。不过还有几个奇怪的地方。第一，括号哪儿去了？因为在 Ruby 中，括号是可以省略的，下面的两行代码是等价的：</p>

<div class="codeblock"><div class="highlight type-erb"><pre># Parentheses on function calls are optional.
stylesheet_link_tag("application", media: "all",
                                   "data-turbolinks-track" =&gt; true)
stylesheet_link_tag "application", media: "all",
                                   "data-turbolinks-track" =&gt; true
</pre></div>
</div>
<p>第二，<code>media</code> 部分显然是一个 Hash，但是怎么没用花括号？因为在调用函数时，如果 Hash 是最后一个参数，它的花括号是可以省略的。下面的两行代码是等价的：</p>

<div class="codeblock"><div class="highlight type-erb"><pre># Curly braces on final hash arguments are optional.
stylesheet_link_tag "application", { media: "all",
                                     "data-turbolinks-track" =&gt; true }
stylesheet_link_tag "application", media: "all",
                                   "data-turbolinks-track" =&gt; true
</pre></div>
</div>
<p>还有，为什么 <code>data-turbolinks-track</code> 这个键值对使用旧句法？因为如果使用新句法，写成</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">data</span><span class="o">-</span><span class="n">turbolinks</span><span class="o">-</span><span class="ss">track: </span><span class="kp">true</span>
</pre></div>
</div>
<p>因为其中包含了连字符，所以这个 Symbol 是不合法的。所以就只能使用旧句法，写成</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="s2">"data-turbolinks-track"</span> <span class="o">=&gt;</span> <span class="kp">true</span>
</pre></div>
</div>
<p>最后，为什么下面这两行代码</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">stylesheet_link_tag</span> <span class="s2">"application"</span><span class="p">,</span> <span class="ss">media: </span><span class="s2">"all"</span><span class="p">,</span>
                                   <span class="s2">"data-turbolinks-track"</span> <span class="o">=&gt;</span> <span class="kp">true</span>
</pre></div>
</div>
<p>为什么可以这么写，中间有空格也可以？当然可以，Ruby 不关心有没有换行。[^1-10]我之所以把代码拆成两行，是要保持每行代码不超过 80 列。[^1-11]</p>

<p>所以我们就看到了这样一行代码</p>

<div class="codeblock"><div class="highlight type-erb"><pre>stylesheet_link_tag "application", media: "all",
                                   "data-turbolinks-track" =&gt; true
</pre></div>
</div>
<p>它调用了 <code>stylesheet_link_tag</code> 函数，传进两个参数：一个是字符串，指明样式表的路径；另一个是 Hash，包含两个元素，指明媒介类型，并启用 <a href="https://github.com/rails/turbolinks">Turbolink</a> 功能(Rails 4 的新功能，本书的后续草稿会深入介绍)。因为使用的是 <code>&lt;%= %&gt;</code>，函数的执行结果会通过 ERb 插入模板中，如果你在浏览器中查看网页的源代码就会看到引入样式表所用的 HTML（参见代码 4.7）。（你可能会在 CSS 的文件名后看到额外的字符，例如 <code>?body=1</code>。这是 Rails 加入的，可以确保 CSS 修改后浏览器会重新加载它。）</p>

<div class="codeblock has-caption" id="codeblock-4-7"><p class="caption"><span>代码 4.7：</span>引入 CSS 的代码生成的 HTML</p><div class="highlight type-html"><pre><span class="nt">&lt;link</span> <span class="na">data-turbolinks-track=</span><span class="s">"true"</span> <span class="na">href=</span><span class="s">"/assets/application.css"</span> <span class="na">media=</span><span class="s">"all"</span>
<span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="nt">/&gt;</span>
</pre></div>
</div>
<p>如果你打开 <a href="http://localhost:3000/assets/application.css">http://localhost:3000/assets/application.css</a> 查看 CSS 的话，会发现是空的（除了一些注释）。在<a href="chapter5.html">第 5 章</a>中我们会看介绍如何添加样式。</p>

<h2 id='section-4-4'><span>4.4</span> Ruby 类</h2>


<p>我们之前已经说过 Ruby 中的一切都是对象，本节我们就会自己定义一些对象。Ruby 和其他面向对象（object-oriented）编程语言一样，使用类来组织方法。然后实例化（instantiate）类创建对象。如果你刚接触面向对象编程，这些都似天书一般，那么让我们来看一些实际的例子吧。</p>

<h3 id='section-4-4-1'><span>4.4.1</span> 构造器</h3>


<p>我们看过很多例子使用类初始化对象，不过还没有正式的初始化过。例如，我们使用一个双引号初始化一个字符串，双引号是字符串的字面构造器（literal constructor）：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>s <span class="o">=</span> <span class="s2">"foobar"</span>       <span class="c"># 使用双引号的字面构造器</span>
<span class="gp">=&gt; </span><span class="s2">"foobar"</span>
<span class="gp">&gt;&gt; </span>s.class
<span class="gp">=&gt; </span>String
</pre></div>
</div>
<p>我们看到字符串可以响应 <code>class</code> 方法，返回的结果是字符串所属的类。</p>

<p>除了使用字面构造器之外，我们还可以使用等价的具名构造器（named constructor），即在类名上调用 <code>new</code> 方法：<sup class="footnote" id="fnref-4-12"><a href="#fn-4-12" rel="footnote">10</a></sup></p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>s <span class="o">=</span> String.new<span class="o">(</span><span class="s2">"foobar"</span><span class="o">)</span>   <span class="c"># 字符串的具名构造器</span>
<span class="gp">=&gt; </span><span class="s2">"foobar"</span>
<span class="gp">&gt;&gt; </span>s.class
<span class="gp">=&gt; </span>String
<span class="gp">&gt;&gt; </span>s <span class="o">==</span> <span class="s2">"foobar"</span>
<span class="gp">=&gt; </span><span class="nb">true</span>
</pre></div>
</div>
<p>上面的代码和字面构造器是等价的，只是更能表现我们的意图。</p>

<p>数组和字符串类似：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>a <span class="o">=</span> Array.new<span class="o">([</span>1, 3, 2]<span class="o">)</span>
<span class="gp">=&gt; </span><span class="o">[</span>1, 3, 2]
</pre></div>
</div>
<p>不过 Hash 就有些不同了。数组的构造器 <code>Array.new</code> 可接受一个可选的参数指明数组的初始值，<code>Hash.new</code> 可接受一个参数指明元素的默认值，就是当键不存在时返回的值：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>h <span class="o">=</span> Hash.new
<span class="gp">=&gt; </span><span class="o">{}</span>
<span class="gp">&gt;&gt; </span>h[:foo]            <span class="c"># 试图获取不存在的键 :foo 对应的值</span>
<span class="gp">=&gt; </span>nil
<span class="gp">&gt;&gt; </span>h <span class="o">=</span> Hash.new<span class="o">(</span>0<span class="o">)</span>    <span class="c"># 设置不存在的键返回 0 而不是 nil</span>
<span class="gp">=&gt; </span><span class="o">{}</span>
<span class="gp">&gt;&gt; </span>h[:foo]
<span class="gp">=&gt; </span>0
</pre></div>
</div>
<p>在类上调用的方法，如本例的 <code>new</code>，我们称之为类方法（class method）。在类上调用 <code>new</code> 得到的结果是这个类的一个对象，也叫做这个类的实例（instance）。在实例上调用的方法，例如 <code>length</code>，叫做实例方法（instance method）。</p>

<h3 id='section-4-4-2'><span>4.4.2</span> 类的继承</h3>


<p>学习类时，理清类的继承关系会很有用，我们可以使用 <code>superclass</code> 方法：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>s <span class="o">=</span> String.new<span class="o">(</span><span class="s2">"foobar"</span><span class="o">)</span>
<span class="gp">=&gt; </span><span class="s2">"foobar"</span>
<span class="gp">&gt;&gt; </span>s.class                        <span class="c"># 查找 s 所属的类</span>
<span class="gp">=&gt; </span>String
<span class="gp">&gt;&gt; </span>s.class.superclass             <span class="c"># 查找 String 的父类</span>
<span class="gp">=&gt; </span>Object
<span class="gp">&gt;&gt; </span>s.class.superclass.superclass  <span class="c"># Ruby 1.9 使用 BasicObject 作为基类</span>
<span class="gp">=&gt; </span>BasicObject
<span class="gp">&gt;&gt; </span>s.class.superclass.superclass.superclass
<span class="gp">=&gt; </span>nil
</pre></div>
</div>
<p>这个继承关系如图 4.1 所示。我们可以看到，<code>String</code> 的父类是 <code>Object</code>，<code>Object</code> 的父类是 <code>BasicObject</code>，但是 <code>BasicObject</code> 就没有父类了。这样的关系对每个 Ruby 对象都是适用的：只要在类的继承关系上往上多走几层就会发现 Ruby 中的每个类最终都是继承自 <code>BasicObject</code>，而其本身没有父类。这就是“Ruby 中一切皆对象”技术层面的意义。</p>

<div class="figure" id="figure-4-1">
  <img src="figures/string_inheritance_ruby_1_9.png" alt="string inheritance ruby19" /><p class="caption"><span>图 4.1：</span><code>String</code> 类的继承关系</p>
</div>
<p>要更深入的理解类，最好的方法就是自己动手编写。我们来创建一个名为 <code>Word</code> 的类，包含一个名为 <code>palindrome?</code> 方法，如果单词顺读和反读时都一样则返回 <code>true</code>：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>class Word
<span class="gp">&gt;&gt;   </span>def palindrome?<span class="o">(</span>string<span class="o">)</span>
<span class="gp">&gt;&gt;     </span>string <span class="o">==</span> string.reverse
<span class="gp">&gt;&gt;   </span>end
<span class="gp">&gt;&gt; </span>end
<span class="gp">=&gt; </span>nil
</pre></div>
</div>
<p>我们可以按照下面的方式使用：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>w <span class="o">=</span> Word.new              <span class="c"># 创建一个 Word 对象</span>
<span class="gp">=&gt; </span><span class="c">#&lt;Word:0x22d0b20&gt;</span>
<span class="gp">&gt;&gt; </span>w.palindrome?<span class="o">(</span><span class="s2">"foobar"</span><span class="o">)</span>
<span class="gp">=&gt; </span><span class="nb">false</span>
<span class="gp">&gt;&gt; </span>w.palindrome?<span class="o">(</span><span class="s2">"level"</span><span class="o">)</span>
<span class="gp">=&gt; </span><span class="nb">true</span>
</pre></div>
</div>
<p>如果你觉得这个例子有点大题小做，很好，我们的目的达到了。定义一个新类，可是只创建一个可以接受一个字符串参数的方法，这么做很古怪。既然单词是字符串，让 <code>Word</code> 继承 <code>String</code> 不就行了，如代码 4.8 所示。（你要退出控制台然后再在控制台中输入这写代码，这样才能把之前的 <code>Word</code> 定义清除掉。）</p>

<div class="codeblock has-caption" id="codeblock-4-8"><p class="caption"><span>代码 4.8：</span>在控制台中定义 <code>Word</code> 类</p><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>class Word &lt; String             <span class="c"># Word 继承自 String</span>
<span class="gp">&gt;&gt;   </span><span class="c"># 如果字符串和自己反转后相等则返回 true</span>
<span class="gp">&gt;&gt;   </span>def palindrome?
<span class="gp">&gt;&gt;     </span>self <span class="o">==</span> self.reverse        <span class="c"># self 代表这个字符串本身</span>
<span class="gp">&gt;&gt;   </span>end
<span class="gp">&gt;&gt; </span>end
<span class="gp">=&gt; </span>nil
</pre></div>
</div>
<p>上面代码中的 <code>Word &lt; String</code> 在 Ruby 中表示继承（<a href="chapter3.html#section-3-1">3.1 节</a>中简单介绍过），这样除了刚定义的 <code>palindrome?</code> 方法之外，<code>Word</code> 还拥有所有字符串拥有的方法：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>s <span class="o">=</span> Word.new<span class="o">(</span><span class="s2">"level"</span><span class="o">)</span>    <span class="c"># 创建一个新的 Word，初始值为 level</span>
<span class="gp">=&gt; </span><span class="s2">"level"</span>
<span class="gp">&gt;&gt; </span>s.palindrome?            <span class="c"># Word 实例可以响应 palindrome? 方法</span>
<span class="gp">=&gt; </span><span class="nb">true</span>
<span class="gp">&gt;&gt; </span>s.length                 <span class="c"># Word 实例还继承了字符串所有的常规方法</span>
<span class="gp">=&gt; </span>5
</pre></div>
</div>
<p><code>Word</code> 继承自 <code>String</code>，我们可以在控制台中查看类的继承关系：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>s.class
<span class="gp">=&gt; </span>Word
<span class="gp">&gt;&gt; </span>s.class.superclass
<span class="gp">=&gt; </span>String
<span class="gp">&gt;&gt; </span>s.class.superclass.superclass
<span class="gp">=&gt; </span>Object
</pre></div>
</div>
<p>继承关系如图 4.2 所示。</p>

<div class="figure" id="figure-4-2">
  <img src="figures/word_inheritance_ruby_1_9.png" alt="word inheritance ruby19" /><p class="caption"><span>图 4.2：</span>代码 4.8 中定义的 <code>Word</code> 类（非内置类）的继承关系</p>
</div>
<p>在代码 4.8 中，注意，要检查单词和单词的反转是否相同，要在 <code>Word</code> 类中引用这个单词，在 Ruby 中我们使用 <code>self</code> 进行引用：在 <code>Word</code> 类中，<code>self</code> 代表的就是对象本身。所以我们可以使用</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="nb">self</span> <span class="o">==</span> <span class="nb">self</span><span class="p">.</span><span class="nf">reverse</span>
</pre></div>
</div>
<p>来检查单词是否是一个回文。<sup class="footnote" id="fnref-4-13"><a href="#fn-4-13" rel="footnote">11</a></sup></p>

<h3 id='section-4-4-3'><span>4.4.3</span> 修改内置的类</h3>


<p>虽然继承是个很强大的功能，不过在回文判断的例子中，如果能把 <code>palindrome?</code> 加入 <code>String</code> 类就更好了，这样（除了其他对象外）我们就可以在字符串字面量上调用 <code>palindrome?</code> 方法了。现在我们还不能直接调用：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span><span class="s2">"level"</span>.palindrome?
NoMethodError: undefined method <span class="sb">`</span>palindrome?<span class="se">\'</span> <span class="k">for</span> <span class="s2">"level"</span>:String
</pre></div>
</div>
<p>有点令人惊讶的是，Ruby 允许你这么做，Ruby 中的类可以被打开进行修改，允许像我们自己这样的普通人添加一些方法：<sup class="footnote" id="fnref-4-14"><a href="#fn-4-14" rel="footnote">12</a></sup></p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>class String
<span class="gp">&gt;&gt;   </span><span class="c"># 如果字符串和自己反转后相等则返回 true</span>
<span class="gp">&gt;&gt;   </span>def palindrome?
<span class="gp">&gt;&gt;     </span>self <span class="o">==</span> self.reverse
<span class="gp">&gt;&gt;   </span>end
<span class="gp">&gt;&gt; </span>end
<span class="gp">=&gt; </span>nil
<span class="gp">&gt;&gt; </span><span class="s2">"deified"</span>.palindrome?
<span class="gp">=&gt; </span><span class="nb">true</span>
</pre></div>
</div>
<p>（我不知道哪一个更牛：Ruby 允许向内置的类中添加方法，或“<code>deified</code>（神化，奉为神明）”是个回文。）</p>

<p>可以修改内置的类是个很强大的功能，不过功能强大意味着责任也大，如果没有一个很好的理由，向内置的类中添加方法被认为是不好的习惯。Rails 自然有很好的理由，例如，在 Web 应用程序中我们经常要避免变量是空白（blank）的，像用户名之类的就不应该是空格或空白，所以 Rails 为 Ruby 添加了一个 <code>blank?</code> 方法。因为 Rails 控制台会自动加载 Rails 添加的扩展功能，我们可以看一下示例（在 <code>irb</code> 就不可以）：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span><span class="s2">""</span>.blank?
<span class="gp">=&gt; </span><span class="nb">true</span>
<span class="gp">&gt;&gt; </span><span class="s2">"      "</span>.empty?
<span class="gp">=&gt; </span><span class="nb">false</span>
<span class="gp">&gt;&gt; </span><span class="s2">"      "</span>.blank?
<span class="gp">=&gt; </span><span class="nb">true</span>
<span class="gp">&gt;&gt; </span>nil.blank?
<span class="gp">=&gt; </span><span class="nb">true</span>
</pre></div>
</div>
<p>我们可以看到，一个包含空格的字符串不是空的（empty），却是空白的（blank）。还要注意，<code>nil</code> 也是空白的。因为 <code>nil</code> 不是字符串，所以上面的代码说明了 Rails 其实是把 <code>blank?</code> 添加到 <code>String</code> 的基类 <code>Object</code> 上的。我们会在 <a href="chapter8.html#section-8-2-1">8.2.1 节</a>中介绍一些 Rails 扩展 Ruby 类的例子。）</p>

<h3 id='section-4-4-4'><span>4.4.4</span> 控制器类</h3>


<p>讨论类和继承时你可能觉得似曾相识，不错，我们之前介绍过，在使用 StaticPages 控制器时（代码 3.16）：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">StaticPagesController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">home</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">help</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">about</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>你现在可以理解，至少有点能理解，这些代码的意思了：<code>StaticPagesController</code> 是一个类，继承自 <code>ApplicationController</code>，<code>StaticPagesController</code> 类中有三个方法 <code>home</code>、<code>help</code> 和 <code>about</code>。因为 Rails 控制台会加载本地的 Rails 环境，所以我们可以在控制台中创建一个控制器来查看一下它的继承关系：<sup class="footnote" id="fnref-4-15"><a href="#fn-4-15" rel="footnote">13</a></sup></p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>controller <span class="o">=</span> StaticPagesController.new
<span class="gp">=&gt; </span><span class="c">#&lt;StaticPagesController:0x22855d0&gt;</span>
<span class="gp">&gt;&gt; </span>controller.class
<span class="gp">=&gt; </span>StaticPagesController
<span class="gp">&gt;&gt; </span>controller.class.superclass
<span class="gp">=&gt; </span>ApplicationController
<span class="gp">&gt;&gt; </span>controller.class.superclass.superclass
<span class="gp">=&gt; </span>ActionController::Base
<span class="gp">&gt;&gt; </span>controller.class.superclass.superclass.superclass
<span class="gp">=&gt; </span>ActionController::Metal
<span class="gp">&gt;&gt; </span>controller.class.superclass.superclass.superclass.superclass
<span class="gp">=&gt; </span>AbstractController::Base
<span class="gp">&gt;&gt; </span>controller.class.superclass.superclass.superclass.superclass.superclass
<span class="gp">=&gt; </span>Object
</pre></div>
</div>
<p>这个继承关系如图 4.3 所示。</p>

<p>我们还可以在控制台中调用控制器的动作，动作其实就是方法：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>controller.home
<span class="gp">=&gt; </span>nil
</pre></div>
</div>
<p><code>home</code> 动作的返回值为 <code>nil</code>，因为它是空的。</p>

<p>注意，动作没有返回值，或至少没返回真正需要的值。如我们在第 3 章看到的，<code>home</code> 动作的目的是渲染网页，而不是返回一个值。不过，我记得没有在任何地方调用过 <code>StaticPagesController.new</code>，这是怎么回事？</p>

<p>原因在于，Rails 是用 Ruby 编写的，但 Rails 不是 Ruby。有些 Rails 类就像普通的 Ruby 类一样，不过也有些则得益于 Rails 的强大功能。Rails 是单独的一门学问，应该区别于 Ruby 进行学习和理解。这就是为什么，如果你的兴趣是开发 Web 应用程序，我建议你先学 Rails 再学 Ruby，然后再回到 Rails 上的原因。</p>

<h3 id='section-4-4-5'><span>4.4.5</span> 用户类</h3>


<p>我们通过创建一个完整的类来结束对 Ruby 的介绍，一个 <code>User</code> 类，提前实现<a href="chapter6.html">第 6 章</a>的 User 模型。</p>

<p>到目前为止，我们都是在控制台中定义类的，这样很快捷，但也有点不爽。现在我们要在应用程序的根目录创建一个名为 <code>example_user.rb</code> 的文件，写入代码 4.9 中的内容。</p>

<div class="figure" id="figure-4-3">
  <img src="figures/static_pages_controller_inheritance.png" alt="static pages controller inheritance" /><p class="caption"><span>图 4.3：</span>StaticPages 控制器的继承关系</p>
</div>
<div class="codeblock has-caption" id="codeblock-4-9"><p class="caption"><span>代码 4.9：</span><code>User</code> 类的代码</p><p class="file"><code>example_user.rb</code></p><div class="highlight type-ruby"><pre><span class="k">class</span> <span class="nc">User</span>
  <span class="kp">attr_accessor</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">attributes</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="vi">@name</span>  <span class="o">=</span> <span class="n">attributes</span><span class="o">[</span><span class="ss">:name</span><span class="o">]</span>
    <span class="vi">@email</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">[</span><span class="ss">:email</span><span class="o">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">formatted_email</span>
    <span class="s2">"</span><span class="si">#{</span><span class="vi">@name</span><span class="si">}</span><span class="s2"> &lt;</span><span class="si">#{</span><span class="vi">@email</span><span class="si">}</span><span class="s2">&gt;"</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>上面的代码有很多要说明的，我们一步步来。先看下面这行：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre>  <span class="kp">attr_accessor</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>
</pre></div>
</div>
<p>它为用户的名字和 Email 地址创建了属性访问器（attribute accessors）。也就是定义了“获取（getter）”和“设定（setter）”方法，用来取回和赋值 <code>@name</code> 和 <code>@email</code> 实例变量，我们在 <a href="chapter2.html#section-2-2-2">2.2.2 节</a>中介绍过实例变量。在 Rails 中，实例变量的意义在于，它们自动的在视图中可用。而通常实例变量的作用是用来在 Ruby 类中不同的方法之间传递变量值。（稍后会更详细的介绍这点。）实例变量总是以 <code>@</code> 符号开头，如果未定义则其值为 <code>nil</code>。</p>

<p>第一个方法，<code>initialize</code>，在 Ruby 中有特殊意义：当我们执行 <code>User.new</code> 时会调用该方法。这个 <code>initialize</code> 方法可以接受一个参数，<code>attributes</code>：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre>  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">attributes</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="vi">@name</span>  <span class="o">=</span> <span class="n">attributes</span><span class="o">[</span><span class="ss">:name</span><span class="o">]</span>
    <span class="vi">@email</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">[</span><span class="ss">:email</span><span class="o">]</span>
  <span class="k">end</span>
</pre></div>
</div>
<p><code>attributes</code> 变量的初始值是一个空的 Hash，所以我们可以定义一个没有名字或没有 Email 地址的用户（回想一下 <a href="chapter4.html#section-4-3-3">4.3.3 节</a>，如果键不存在则返回 <code>nil</code>，所以如果没定义 <code>:name</code> 键，则 <code>attributes[:name]</code> 会返回 <code>nil</code>，<code>attributes[:email]</code> 也是一样）。</p>

<p>最后，定义了一个名为 <code>formatted_email</code> 的方法，它使用被赋了值的 <code>@name</code> 和 <code>@email</code> 变量进行插值，组成一个格式良好的用户 Email 地址（<a href="chapter4.html#section-4-2-2">4.2.2 节</a>）：</p>

<div class="codeblock"><div class="highlight type-ruby"><pre>  <span class="k">def</span> <span class="nf">formatted_email</span>
    <span class="s2">"</span><span class="si">#{</span><span class="vi">@name</span><span class="si">}</span><span class="s2"> &lt;</span><span class="si">#{</span><span class="vi">@email</span><span class="si">}</span><span class="s2">&gt;"</span>
  <span class="k">end</span>
</pre></div>
</div>
<p>因为 <code>@name</code> 和 <code>@email</code> 都是实例变量（如 <code>@</code> 符号指明），所以它们在 <code>formatted_email</code> 方法中自动可见。</p>

<p>让我们打开控制台，加载（<code>require</code>）这个文件，实际操作一下这个用户类：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>require <span class="s1">'./example_user'</span>     <span class="c"># 这就是加载文件的方式</span>
<span class="gp">=&gt; </span><span class="o">[</span><span class="s2">"User"</span><span class="o">]</span>
<span class="gp">&gt;&gt; </span>example <span class="o">=</span> User.new
<span class="gp">=&gt; </span><span class="c">#&lt;User:0x224ceec @email=nil, @name=nil&gt;</span>
<span class="gp">&gt;&gt; </span>example.name                 <span class="c"># 返回 nil，因为 attributes[:name] 是 nil</span>
<span class="gp">=&gt; </span>nil
<span class="gp">&gt;&gt; </span>example.name <span class="o">=</span> <span class="s2">"Example User"</span>           <span class="c"># 赋值一个非 nil 的名字</span>
<span class="gp">=&gt; </span><span class="s2">"Example User"</span>
<span class="gp">&gt;&gt; </span>example.email <span class="o">=</span> <span class="s2">"user@example.com"</span>      <span class="c"># 赋值一个非 nil 的 Email 地址</span>
<span class="gp">=&gt; </span><span class="s2">"user@example.com"</span>
<span class="gp">&gt;&gt; </span>example.formatted_email
<span class="gp">=&gt; </span><span class="s2">"Example User &lt;user@example.com&gt;"</span>
</pre></div>
</div>
<p>上面代码中的点号 <code>.</code> 在 Unix 中是指“当前目录”，<code>./example_user</code> 告诉 Ruby 在当前目录中寻找这个文件。接下来的代码创建了一个空的用户，然后通过直接赋值给相应的属性来提供他的名字和 Email 地址（因为有了代码 4.9 中 <code>attr_accessor</code> 那行才能进行赋值操作）。我们输入</p>

<div class="codeblock"><div class="highlight type-ruby"><pre><span class="n">example</span><span class="p">.</span><span class="nf">name</span> <span class="o">=</span> <span class="s2">"Example User"</span>
</pre></div>
</div>
<p>Ruby 会将 <code>@name</code> 变量的值设为 <code>"Example User"</code>（<code>email</code> 属性类似），然后可以在 <code>formatted_email</code> 中使用。</p>

<p>如 <a href="chapter4.html#section-4-3-4">4.3.4 节</a>中介绍的，如果最后一个参数是 Hash，我们就可以省略花括号，我们可以把一个预先定义好的 Hash 传递给 <code>initialize</code> 方法来创建另一用户：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">&gt;&gt; </span>user <span class="o">=</span> User.new<span class="o">(</span>name: <span class="s2">"Michael Hartl"</span>, email: <span class="s2">"mhartl@example.com"</span><span class="o">)</span>
<span class="gp">=&gt; </span><span class="c">#&lt;User:0x225167c @email="mhartl@example.com", @name="Michael Hartl"&gt;</span>
<span class="gp">&gt;&gt; </span>user.formatted_email
<span class="gp">=&gt; </span><span class="s2">"Michael Hartl &lt;mhartl@example.com&gt;"</span>
</pre></div>
</div>
<p>从第 7 章开始，我们会使用 Hash 初始化对象，这种技术叫做“mass assignment”，在 Rails 中很常用。</p>

<h2 id='section-4-5'><span>4.5</span> 小结</h2>


<p>现在结束对 Ruby 语言的介绍。在<a href="chapter5.html">第 5 章</a>我们会好好的利用这些知识来开发示例程序。</p>

<p>我们不会使用 <a href="chapter4.html#section-4-4-5">4.4.5 节</a>中创建的 <code>example_user.rb</code> 文件，所以我建议把它删除：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>rm example_user.rb
</pre></div>
</div>
<p>然后把其他的改动提交到代码仓库中：</p>

<div class="codeblock"><div class="highlight type-shell"><pre><span class="gp">$ </span>git add .
<span class="gp">$ </span>git commit -m <span class="s2">"Add a full_title helper"</span>
</pre></div>
</div>
<h2 id='section-4-6'><span>4.6</span> 练习</h2>


<ol><li>
    <p>将下面代码 4.10 中的问号换成合适的方法，结合<code>split</code>、<code>shuffle</code> 和 <code>join</code> 实现一个函数，把一个给定字符串中的字符顺序打乱。</p>
  </li>
  <li>
    <p>以下面代码 4.11 为蓝本，将 <code>shuffle</code> 方法添加到 <code>String</code> 类中。</p>
  </li>
  <li>
    <p>创建三个 Hash，分别名为 <code>person1</code>、<code>person2</code> 和 <code>person3</code>，将名和姓对应到 <code>:first</code> 和 <code>:last</code> 键上。再创建一个名为 <code>params</code> 的 Hash，使 <code>params[:father]</code> 对应 <code>person1</code>，<code>params[:mother]</code> 对应 <code>person2</code>，<code>params[:child]</code> 对应 <code>person3</code>。验证一下 <code>params[:father][:first]</code> 的值是否正确。</p>
  </li>
  <li>
    <p>找一个在线的 Ruby API 文档，阅读 <code>Hash</code> 的 <code>merge</code> 方法的使用方法。</p>
  </li>
  <li>
    <p><strong>（选做）</strong>跟着 <a href="http://rubykoans.com/">Ruby Koans</a> 学习 Ruby 入门知识。</p>
  </li>
</ol><div class="codeblock has-caption" id="codeblock-4-10"><p class="caption"><span>代码 4.10：</span>打乱字符串函数的骨架</p><div class="highlight type-ruby"><pre><span class="o">&gt;&gt;</span> <span class="k">def</span> <span class="nf">string_shuffle</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="o">&gt;&gt;</span>   <span class="n">s</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span><span class="o">.</span><span class="sc">?.</span><span class="p">?</span>
<span class="o">&gt;&gt;</span> <span class="k">end</span>
<span class="o">=&gt;</span> <span class="kp">nil</span>
<span class="o">&gt;&gt;</span> <span class="n">string_shuffle</span><span class="p">(</span><span class="s2">"foobar"</span><span class="p">)</span>
</pre></div>
</div>
<div class="codeblock has-caption" id="codeblock-4-11"><p class="caption"><span>代码 4.11：</span>添加到 <code>String</code> 类的 <code>shuffle</code> 方法骨架</p><div class="highlight type-ruby"><pre><span class="o">&gt;&gt;</span> <span class="k">class</span> <span class="nc">String</span>
<span class="o">&gt;&gt;</span>   <span class="k">def</span> <span class="nf">shuffle</span>
<span class="o">&gt;&gt;</span>     <span class="nb">self</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span><span class="o">.</span><span class="sc">?.</span><span class="p">?</span>
<span class="o">&gt;&gt;</span>   <span class="k">end</span>
<span class="o">&gt;&gt;</span> <span class="k">end</span>
<span class="o">=&gt;</span> <span class="kp">nil</span>
<span class="o">&gt;&gt;</span> <span class="s2">"foobar"</span><span class="p">.</span><span class="nf">shuffle</span>
</pre></div>
</div>
<div class="footnotes">
  <ol><li id="fn-4-1">
      <p>如果帮助函数是针对某个特定控制器的，你应该把它放进该控制器相应的帮助文件中。例如，为 StaticPages 控制器创建的帮助函数一般放在 <code>app/helper/static_pages_helper.rb</code> 中。在这个例子中，我们会把 <code>full_title</code> 这个帮助函数用在网站内所有的网页中，针对这种情况 Rails 提供了一个特别的文件：<code>app/helper/application_helper.rb</code>。<a href="#fnref-4-1" rel="reference">↩</a></p>
    </li>
    <li id="fn-4-2">
      <p>关于“foo”和“bar”，以及不太相关的“foobar”和“FUBAR”的起源，请查看 <a href="http://www.catb.org/jargon/html/F/foo.html">Jargon File 中介绍“foo”的文章</a>。<a href="#fnref-4-2" rel="reference">↩</a></p>
    </li>
    <li id="fn-4-3">
      <p>熟悉 Perl 或 PHP 的编程人员可以把这个功能与自动插值美元符号开头的变量相对应，例如 <code>"foo $bar"</code>。<a href="#fnref-4-3" rel="reference">↩</a></p>
    </li>
    <li id="fn-4-4">
      <p>很抱歉本章在函数和方法之间随意的来回使用。在 Ruby 中这二者是同一个概念：所有的方法都是函数，所有的函数也都是方法，因为一切皆对象。<a href="#fnref-4-4" rel="reference">↩</a></p>
    </li>
    <li id="fn-4-5">
      <p>其实这里还有一个地方我们还不能理解，那就是 Rails 是怎么把这些联系在一起的：把 URI 映射到动作上，<code>full_title</code> 帮助函数可以在视图中使用，等。这是个很有意思的话题，我建议你以后好好的了解一下，不过使用 Rails 并不需要完全了解 Rails 的运作机理。（若想更深入的了解 Rails，我推荐阅读 Obie Fernandez 的《<a href="http://www.amazon.com/gp/product/0321601661">Rails 3 之道</a>》。）<a href="#fnref-4-5" rel="reference">↩</a></p>
    </li>
    <li id="fn-4-6">
      <p>下面代码中使用的 <code>second</code> 方法不是 Ruby 定义的，而是 Rails 添加的。在这里可以使用这个方法是因为 Rails 控制台会自动加载 Rails 对 Ruby 的功能扩展。<a href="#fnref-4-6" rel="reference">↩</a></p>
    </li>
    <li id="fn-4-7">
      <p>块是闭包（closure），知道这一点对资深编程人员可能会有点帮助。闭包是一种匿名函数，其中附带了一些数据。<a href="#fnref-4-7" rel="reference">↩</a></p>
    </li>
    <li id="fn-4-8">
      <p>在 Ruby 1.9 中，其实会按照元素输入时的顺序保存 Hash，不过依赖顺序显然是不明智的。<a href="#fnref-4-8" rel="reference">↩</a></p>
    </li>
    <li id="fn-4-9">
      <p>没有了约束的好处是，Symbol 很容易进行比较，字符串要按照字母一个一个的比较，而 Symbol 只需进行一次操作。这就使得 Symbol 成为 Hash 键的最佳选择。<a href="#fnref-4-9" rel="reference">↩</a></p>
    </li>
    <li id="fn-4-12">
      <p>返回的结果可能由于 Ruby 版本的不同而有所不同。这个例子假设你使用的是 Ruby 1.9.3。<a href="#fnref-4-12" rel="reference">↩</a></p>
    </li>
    <li id="fn-4-13">
      <p>关于 Ruby 类和 <code>self</code> 关键字，请阅读 <a href="http://railstips.org/">RailsTips</a> 上的《<a href="http://railstips.org/blog/archives/2006/11/18/class-and-instance-variables-in-ruby/">Class and Instance Variables in Ruby</a>》一文。<a href="#fnref-4-13" rel="reference">↩</a></p>
    </li>
    <li id="fn-4-14">
      <p>了解 JavaScript 的人可能知道这个功能与使用内置的类原型对象扩充类的方式类似。（感谢读者 <a href="http://getsatisfaction.com/railstutorial/topics/adding_methods_to_built_in_classes_comparable_to_using_javascripts_prototype_object">Erik Eldridge</a> 指出这一点。）<a href="#fnref-4-14" rel="reference">↩</a></p>
    </li>
    <li id="fn-4-15">
      <p>你没必要知道继承关系中的每个类。我也不知道它们都是干什么的，而我从 2005 年就开始使用 Ruby on Rails 进行开发了。这可能意味着了以下两个问题中的一个，第一，我是个废柴，第二，你不需要知道所有的内在知识也能成为熟练的 Rails 开发者。我们当然都希望是第二点。<a href="#fnref-4-15" rel="reference">↩</a></p>
    </li>
  </ol></div>
  	</div>
</div>

			
				
				<div class="navigation">
					
						<a class="prev_page" href="/chapter3.html">&laquo; 第 3 章基本静态的页面</a>
					
					
						<a class="next_page" href="/chapter5.html">第 5 章完善布局 &raquo;</a>
					
				</div>
				
			
		</div>
		<div class="footer">
        	<p>&copy;2013 <a href="http://about.ac" title="Andor Chen 的个人网站">Andor Chen</a> 保留部分权力。在线阅读版本基于<a href="http://creativecommons.org/licenses/by-sa/3.0/" title="Creative Commons Attribution-ShareAlike 3.0 Unported License" target="_blank">“CC 3.0 BY-SA 协议”</a>发布</p>
		</div>
	</div>
</body>
</html>
